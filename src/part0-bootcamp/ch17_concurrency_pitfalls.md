# –ü—ñ–¥—Å—Ç—É–ø–Ω—ñ –∑–∞–¥–∞—á—ñ –∑ –ø–∞—Ä–∞–ª–µ–ª—ñ–∑–º–æ–º

---

## üìã –ê–Ω–æ—Ç–∞—Ü—ñ—è

–¶–µ–π —Ä–æ–∑–¥—ñ–ª —Ä–æ–∑–∫—Ä–∏–≤–∞—î –Ω–µ–æ—á–µ–≤–∏–¥–Ω—ñ –∞—Å–ø–µ–∫—Ç–∏ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ–≥–æ —Ç–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è, —è–∫—ñ –º–æ–∂—É—Ç—å –ø–µ—Ä–µ—Ç–≤–æ—Ä–∏—Ç–∏ —ñ–¥–µ–∞–ª—å–Ω–æ —Å–∫–æ–º–ø—ñ–ª—å–æ–≤–∞–Ω—É –ø—Ä–æ–≥—Ä–∞–º—É –Ω–∞ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω—É —Å–∏—Å—Ç–µ–º—É –∑ –≤–∏–ø–∞–¥–∫–æ–≤–∏–º–∏ –∑–±–æ—è–º–∏. –í–∏ –¥—ñ–∑–Ω–∞—î—Ç–µ—Å—å, —á–æ–º—É Rust –∑–∞—Ö–∏—â–∞—î –≤—ñ–¥ data races, –∞–ª–µ –Ω–µ –≤—ñ–¥ –ª–æ–≥—ñ—á–Ω–∏—Ö –≥–æ–Ω–æ–∫, —è–∫ –¥–≤–∞ –ø–æ—Ç–æ–∫–∏ –º–æ–∂—É—Ç—å –Ω–∞–∑–∞–≤–∂–¥–∏ –∑–∞–±–ª–æ–∫—É–≤–∞—Ç–∏ –æ–¥–∏–Ω –æ–¥–Ω–æ–≥–æ –≤ deadlock, —Ç–∞ —á–æ–º—É –≤–∏–∫–ª–∏–∫ –±–ª–æ–∫—É—é—á–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó –≤ async-–∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ –º–æ–∂–µ "–∑–∞–º–æ—Ä–æ–∑–∏—Ç–∏" –≤–µ—Å—å runtime. –£ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ —Ä–æ—é –ë–ü–õ–ê —Ü—ñ –∑–Ω–∞–Ω–Ω—è –∫—Ä–∏—Ç–∏—á–Ω—ñ: –∫–æ–∂–µ–Ω –¥—Ä–æ–Ω ‚Äî –æ–∫—Ä–µ–º–∏–π –ø–æ—Ç—ñ–∫ –∞–±–æ –∑–∞–¥–∞—á–∞, —ñ –ø–æ–º–∏–ª–∫–∞ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –∫–æ–ª—ñ–∑—ñ–π, –≤—Ç—Ä–∞—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü—ñ—ó –∞–±–æ –ø–æ–≤–Ω–æ–≥–æ –∑–∞–≤–∏—Å–∞–Ω–Ω—è —Å–∏—Å—Ç–µ–º–∏ –∫–µ—Ä—É–≤–∞–Ω–Ω—è.

---

## üéØ –¶—ñ–ª—ñ –Ω–∞–≤—á–∞–Ω–Ω—è

–ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ü—å–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É –≤–∏ –∑–º–æ–∂–µ—Ç–µ:

1. **–†–æ–∑—Ä—ñ–∑–Ω—è—Ç–∏** data races —Ç–∞ –ª–æ–≥—ñ—á–Ω—ñ –≥–æ–Ω–∫–∏ (race conditions)
2. **–†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞—Ç–∏** —Ç–∞ —É–Ω–∏–∫–∞—Ç–∏ deadlock-—ñ–≤
3. **–ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±–∏—Ä–∞—Ç–∏** –º—ñ–∂ Mutex, RwLock —Ç–∞ –∞—Ç–æ–º–∞—Ä–Ω–∏–º–∏ —Ç–∏–ø–∞–º–∏
4. **–£–Ω–∏–∫–∞—Ç–∏** –±–ª–æ–∫—É—é—á–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π –≤ async-–∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ
5. **–†–æ–∑—É–º—ñ—Ç–∏** –ø—Ä–æ–±–ª–µ–º–∏ –∑ –ø–æ—Ä—è–¥–∫–æ–º –æ–ø–µ—Ä–∞—Ü—ñ–π —É –±–∞–≥–∞—Ç–æ–ø–æ—Ç–æ–∫–æ–≤–æ–º—É –∫–æ–¥—ñ
6. **–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏** –∫–∞–Ω–∞–ª–∏ –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó –∫–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—ó
7. **–ü—Ä–æ–µ–∫—Ç—É–≤–∞—Ç–∏** —Å–∏—Å—Ç–µ–º–∏ –∑ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–º —Å–ø—ñ–ª—å–Ω–∏–º —Å—Ç–∞–Ω–æ–º

---

## üìö –ö–ª—é—á–æ–≤—ñ —Ç–µ—Ä–º—ñ–Ω–∏

| –¢–µ—Ä–º—ñ–Ω | –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è |
|--------|------------|
| **data race** | –û–¥–Ω–æ—á–∞—Å–Ω–∏–π –¥–æ—Å—Ç—É–ø –¥–æ –ø–∞–º'—è—Ç—ñ –∑ —Ö–æ—á–∞ –± –æ–¥–Ω–∏–º –∑–∞–ø–∏—Å–æ–º –±–µ–∑ —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó |
| **race condition** | –õ–æ–≥—ñ—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞ —á–µ—Ä–µ–∑ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –≤–∏–∫–æ–Ω–∞–Ω–Ω—è |
| **deadlock** | –°—Ç–∞–Ω, –∫–æ–ª–∏ –ø–æ—Ç–æ–∫–∏ –≤–∑–∞—î–º–Ω–æ –±–ª–æ–∫—É—é—Ç—å –æ–¥–∏–Ω –æ–¥–Ω–æ–≥–æ –Ω–∞–∑–∞–≤–∂–¥–∏ |
| **livelock** | –ü–æ—Ç–æ–∫–∏ –∞–∫—Ç–∏–≤–Ω—ñ, –∞–ª–µ –Ω–µ —Ä–æ–±–ª—è—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—É —á–µ—Ä–µ–∑ –ø–æ—Å—Ç—ñ–π–Ω—ñ –∫–æ–Ω—Ñ–ª—ñ–∫—Ç–∏ |
| **starvation** | –ü–æ—Ç—ñ–∫ –Ω–µ –æ—Ç—Ä–∏–º—É—î —Ä–µ—Å—É—Ä—Å —á–µ—Ä–µ–∑ "–∂–∞–¥—ñ–±–Ω—ñ—Å—Ç—å" —ñ–Ω—à–∏—Ö |
| **Mutex** | –ü—Ä–∏–º—ñ—Ç–∏–≤ –≤–∑–∞—î–º–Ω–æ–≥–æ –≤–∏–∫–ª—é—á–µ–Ω–Ω—è (mutual exclusion) |
| **RwLock** | –ë–ª–æ–∫—É–≤–∞–Ω–Ω—è –∑ —Ä–æ–∑–¥—ñ–ª–µ–Ω–Ω—è–º –Ω–∞ —á–∏—Ç–∞–Ω–Ω—è —Ç–∞ –∑–∞–ø–∏—Å |

---

## üí° –ú–æ—Ç–∏–≤–∞—Ü—ñ–π–Ω–∏–π –∫–µ–π—Å: –†—ñ–π, —â–æ –∑–∞–≤–∏—Å —É –ø–æ–≤—ñ—Ç—Ä—ñ

–ö–æ–º–∞–Ω–¥–∞ —Ä–æ–∑—Ä–æ–±–ª—è–ª–∞ —Å–∏—Å—Ç–µ–º—É –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü—ñ—ó —Ä–æ—é –∑ 50 –¥—Ä–æ–Ω—ñ–≤. –ö–æ–∂–µ–Ω –¥—Ä–æ–Ω –º–∞–≤ –ø–æ—Ç—ñ–∫ –¥–ª—è –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó, –ø–æ—Ç—ñ–∫ –¥–ª—è –∫–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—ó —Ç–∞ –ø–æ—Ç—ñ–∫ –¥–ª—è –æ–±—Ä–æ–±–∫–∏ —Å–µ–Ω—Å–æ—Ä—ñ–≤. –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∏–π —Å–µ—Ä–≤–µ—Ä –∫–æ–æ—Ä–¥–∏–Ω—É–≤–∞–≤ —Ä—É—Ö —á–µ—Ä–µ–∑ —Å–ø—ñ–ª—å–Ω—É –∫–∞—Ä—Ç—É.

–ü—ñ–¥ —á–∞—Å –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó —ñ–Ω–≤–µ—Å—Ç–æ—Ä–∞–º —Å—Ç–∞–ª–æ—Å—è –Ω–µ–º–∏—Å–ª–∏–º–µ: –≤—Å—ñ 50 –¥—Ä–æ–Ω—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ "–∑–∞–≤–º–µ—Ä–ª–∏" —É –ø–æ–≤—ñ—Ç—Ä—ñ. –ñ–æ–¥–Ω–∏—Ö –ø–æ–º–∏–ª–æ–∫ —É –ª–æ–≥–∞—Ö. –ñ–æ–¥–Ω–∏—Ö –ø–∞–Ω—ñ–∫. –°–∏—Å—Ç–µ–º–∞ –ø—Ä–æ—Å—Ç–æ –ø–µ—Ä–µ—Å—Ç–∞–ª–∞ —Ä–µ–∞–≥—É–≤–∞—Ç–∏.

–ü—ñ—Å–ª—è –≥–æ–¥–∏–Ω –¥–µ–±–∞–≥—É –∑–Ω–∞–π—à–ª–∏ –ø—Ä–∏—á–∏–Ω—É. –î–≤–∞ –ø–æ—Ç–æ–∫–∏ –≤–∏–∫–æ–Ω—É–≤–∞–ª–∏ —Ç–∞–∫–∏–π –∫–æ–¥:

```rust
// –ü–æ—Ç—ñ–∫ –Ω–∞–≤—ñ–≥–∞—Ü—ñ—ó
fn update_position(&self) {
    let _map = self.map.lock().unwrap();      // –ë–ª–æ–∫—É—î–º–æ map
    let _pos = self.position.lock().unwrap();  // –ü–æ—Ç—ñ–º position
    // –æ–Ω–æ–≤–ª–µ–Ω–Ω—è...
}

// –ü–æ—Ç—ñ–∫ –∫–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—ó
fn broadcast_status(&self) {
    let _pos = self.position.lock().unwrap();  // –ë–ª–æ–∫—É—î–º–æ position
    let _map = self.map.lock().unwrap();       // –ü–æ—Ç—ñ–º map
    // –≤—ñ–¥–ø—Ä–∞–≤–∫–∞...
}
```

–ö–ª–∞—Å–∏—á–Ω–∏–π deadlock: –ø–æ—Ç—ñ–∫ –ê —Ç—Ä–∏–º–∞—î `map` —ñ —á–µ–∫–∞—î `position`, –ø–æ—Ç—ñ–∫ –ë —Ç—Ä–∏–º–∞—î `position` —ñ —á–µ–∫–∞—î `map`. –û–±–∏–¥–≤–∞ —á–µ–∫–∞—é—Ç—å –Ω–∞–∑–∞–≤–∂–¥–∏.

–¶–µ–π deadlock –≤–∏–Ω–∏–∫–∞–≤ —Ä—ñ–¥–∫–æ ‚Äî –ª–∏—à–µ –∫–æ–ª–∏ –æ–±–∏–¥–≤–∞ –ø–æ—Ç–æ–∫–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ –≤—Ö–æ–¥–∏–ª–∏ —É —Å–≤–æ—ó —Ñ—É–Ω–∫—Ü—ñ—ó. –ü—Ä–∏ —Ç–µ—Å—Ç—É–≤–∞–Ω–Ω—ñ –∑ 5 –¥—Ä–æ–Ω–∞–º–∏ —Ü–µ —Ç—Ä–∞–ø–ª—è–ª–æ—Å—å —Ä–∞–∑ –Ω–∞ –∫—ñ–ª—å–∫–∞ –≥–æ–¥–∏–Ω. –ó 50 –¥—Ä–æ–Ω–∞–º–∏ ‚Äî –∑–∞ —Ö–≤–∏–ª–∏–Ω–∏. –ó–∞–∫–æ–Ω –ú–µ—Ä—Ñ—ñ —É –¥—ñ—ó: –ø—Ä–æ–±–ª–µ–º–∞ –ø—Ä–æ—è–≤–∏–ª–∞—Å—å —Å–∞–º–µ –ø—ñ–¥ —á–∞—Å –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—ó.

---

## –¢–ï–û–†–Ü–Ø: DATA RACE VS RACE CONDITION

### Data Race ‚Äî —Ç–µ, –≤—ñ–¥ —á–æ–≥–æ Rust –∑–∞—Ö–∏—â–∞—î

Data race –≤–∏–Ω–∏–∫–∞—î, –∫–æ–ª–∏:
1. –î–≤–∞ –∞–±–æ –±—ñ–ª—å—à–µ –ø–æ—Ç–æ–∫—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ –∑–≤–µ—Ä—Ç–∞—é—Ç—å—Å—è –¥–æ –æ–¥–Ω—ñ—î—ó –ø–∞–º'—è—Ç—ñ
2. –•–æ—á–∞ –± –æ–¥–∏–Ω –∑ –Ω–∏—Ö –∑–∞–ø–∏—Å—É—î
3. –ù–µ–º–∞—î —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó

Data race ‚Äî —Ü–µ undefined behavior. –†–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–∏–π: –ø–æ—à–∫–æ–¥–∂–µ–Ω—ñ –¥–∞–Ω—ñ, "–Ω–µ–º–æ–∂–ª–∏–≤—ñ" –∑–Ω–∞—á–µ–Ω–Ω—è, crash.

```rust
// Rust –ù–ï –î–û–ó–í–û–õ–ò–¢–¨ —Å–∫–æ–º–ø—ñ–ª—é–≤–∞—Ç–∏ —Ü–µ:
use std::thread;

fn main() {
    let mut counter = 0;
    
    let handle = thread::spawn(|| {
        counter += 1;  // –ü–û–ú–ò–õ–ö–ê: cannot borrow `counter` as mutable
    });
    
    counter += 1;
    handle.join().unwrap();
}
```

–°–∏—Å—Ç–µ–º–∞ ownership —Ç–∞ borrow checker –≥–∞—Ä–∞–Ω—Ç—É—é—Ç—å: —è–∫—â–æ –∫–æ–¥ —Å–∫–æ–º–ø—ñ–ª—é–≤–∞–≤—Å—è, data races –Ω–µ–º–æ–∂–ª–∏–≤—ñ. –¶–µ —É–Ω—ñ–∫–∞–ª—å–Ω–∞ –≥–∞—Ä–∞–Ω—Ç—ñ—è Rust.

### Race Condition ‚Äî —Ç–µ, –≤—ñ–¥ —á–æ–≥–æ Rust –ù–ï –∑–∞—Ö–∏—â–∞—î

Race condition ‚Äî —Ü–µ –ª–æ–≥—ñ—á–Ω–∞ –ø–æ–º–∏–ª–∫–∞, –∫–æ–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø–æ—Ä—è–¥–∫—É –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –æ–ø–µ—Ä–∞—Ü—ñ–π. –ö–æ–∂–Ω–∞ –æ–∫—Ä–µ–º–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –±–µ–∑–ø–µ—á–Ω–∞, –∞–ª–µ —ó—Ö –∫–æ–º–±—ñ–Ω–∞—Ü—ñ—è –¥–∞—î –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let balance = Arc::new(Mutex::new(100));
    
    let b1 = Arc::clone(&balance);
    let h1 = thread::spawn(move || {
        let current = *b1.lock().unwrap();  // –ß–∏—Ç–∞—î–º–æ 100
        // ... —è–∫–∞—Å—å —Ä–æ–±–æ—Ç–∞ ...
        if current >= 80 {
            *b1.lock().unwrap() -= 80;       // –ó–Ω—ñ–º–∞—î–º–æ 80
        }
    });
    
    let b2 = Arc::clone(&balance);
    let h2 = thread::spawn(move || {
        let current = *b2.lock().unwrap();  // –ß–∏—Ç–∞—î–º–æ 100
        // ... —è–∫–∞—Å—å —Ä–æ–±–æ—Ç–∞ ...
        if current >= 50 {
            *b2.lock().unwrap() -= 50;       // –ó–Ω—ñ–º–∞—î–º–æ 50
        }
    });
    
    h1.join().unwrap();
    h2.join().unwrap();
    
    println!("Balance: {}", balance.lock().unwrap());
    // –ú–æ–∂–µ –±—É—Ç–∏ -30! –û–±–∏–¥–≤–∞ –ø–æ—Ç–æ–∫–∏ –ø–æ–±–∞—á–∏–ª–∏ 100 —ñ –≤–∏—Ä—ñ—à–∏–ª–∏, —â–æ –º–æ–∂—É—Ç—å –∑–Ω—è—Ç–∏.
}
```

–ö–æ–¥ –∫–æ–º–ø—ñ–ª—é—î—Ç—å—Å—è –±–µ–∑ –ø–æ–º–∏–ª–æ–∫. –ö–æ–∂–µ–Ω lock/unlock –±–µ–∑–ø–µ—á–Ω–∏–π. –ê–ª–µ –ª–æ–≥—ñ–∫–∞ —Ö–∏–±–Ω–∞: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –±–∞–ª–∞–Ω—Å—É —Ç–∞ –∑–Ω—è—Ç—Ç—è –∫–æ—à—Ç—ñ–≤ ‚Äî –æ–∫—Ä–µ–º—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó. –ú—ñ–∂ –Ω–∏–º–∏ —ñ–Ω—à–∏–π –ø–æ—Ç—ñ–∫ –º–æ–∂–µ –∑–º—ñ–Ω–∏—Ç–∏ –±–∞–ª–∞–Ω—Å.

### –ß–æ–º—É Rust –Ω–µ –∑–∞—Ö–∏—â–∞—î –≤—ñ–¥ race conditions

Race condition ‚Äî —Ü–µ –ø–æ–º–∏–ª–∫–∞ –≤ –ª–æ–≥—ñ—Ü—ñ –ø—Ä–æ–≥—Ä–∞–º–∏, –Ω–µ –≤ –¥–æ—Å—Ç—É–ø—ñ –¥–æ –ø–∞–º'—è—Ç—ñ. –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –Ω–µ –º–æ–∂–µ –∑–Ω–∞—Ç–∏, —â–æ "–ø–µ—Ä–µ–≤—ñ—Ä–∫–∞" —ñ "–¥—ñ—è" –º–∞—é—Ç—å –±—É—Ç–∏ –∞—Ç–æ–º–∞—Ä–Ω–∏–º–∏. –¶–µ –±—ñ–∑–Ω–µ—Å-–ª–æ–≥—ñ–∫–∞, –Ω–µ —Ç–µ—Ö–Ω—ñ—á–Ω–∞ –≤–∏–º–æ–≥–∞.

Rust –≥–∞—Ä–∞–Ω—Ç—É—î memory safety (–≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å data races), –∞–ª–µ –Ω–µ logical correctness (–≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å race conditions). –¶–µ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å –ø—Ä–æ–≥—Ä–∞–º—ñ—Å—Ç–∞.

### –†—ñ—à–µ–Ω–Ω—è: –∞—Ç–æ–º–∞—Ä–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó

```rust
use std::sync::{Arc, Mutex};

fn withdraw(balance: &Mutex<i32>, amount: i32) -> bool {
    let mut guard = balance.lock().unwrap();
    if *guard >= amount {
        *guard -= amount;
        true  // –£—Å–ø—ñ—à–Ω–æ
    } else {
        false // –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–æ—à—Ç—ñ–≤
    }
}  // guard –∑–≤—ñ–ª—å–Ω—è—î—Ç—å—Å—è —Ç—É—Ç ‚Äî –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ –∑–Ω—è—Ç—Ç—è –∞—Ç–æ–º–∞—Ä–Ω—ñ
```

–¢–µ–ø–µ—Ä –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ —ñ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è –≤—ñ–¥–±—É–≤–∞—é—Ç—å—Å—è –ø—ñ–¥ –æ–¥–Ω–∏–º lock ‚Äî —ñ–Ω—à–∏–π –ø–æ—Ç—ñ–∫ –Ω–µ –º–æ–∂–µ –≤—Ç—Ä—É—Ç–∏—Ç–∏—Å—å.

---

## –¢–ï–û–†–Ü–Ø: DEADLOCK ‚Äî –í–ó–ê–Ñ–ú–ù–ï –ë–õ–û–ö–£–í–ê–ù–ù–Ø

### –©–æ —Ç–∞–∫–µ deadlock

Deadlock –≤–∏–Ω–∏–∫–∞—î, –∫–æ–ª–∏ –ø–æ—Ç–æ–∫–∏ —Ü–∏–∫–ª—ñ—á–Ω–æ —á–µ–∫–∞—é—Ç—å —Ä–µ—Å—É—Ä—Å–∏ –æ–¥–∏–Ω –æ–¥–Ω–æ–≥–æ:
- –ü–æ—Ç—ñ–∫ A —Ç—Ä–∏–º–∞—î —Ä–µ—Å—É—Ä—Å X —ñ —á–µ–∫–∞—î —Ä–µ—Å—É—Ä—Å Y
- –ü–æ—Ç—ñ–∫ B —Ç—Ä–∏–º–∞—î —Ä–µ—Å—É—Ä—Å Y —ñ —á–µ–∫–∞—î —Ä–µ—Å—É—Ä—Å X

–ù—ñ—Ö—Ç–æ –Ω–µ –º–æ–∂–µ –ø—Ä–æ–¥–æ–≤–∂–∏—Ç–∏. –°–∏—Å—Ç–µ–º–∞ "–∑–∞–≤–∏—Å–∞—î" –±–µ–∑ –∂–æ–¥–Ω–æ—ó –ø–æ–º–∏–ª–∫–∏.

### –ö–ª–∞—Å–∏—á–Ω–∏–π –ø—Ä–∏–∫–ª–∞–¥: –¥–≤–∞ –º'—é—Ç–µ–∫—Å–∏

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let resource_a = Arc::new(Mutex::new(0));
    let resource_b = Arc::new(Mutex::new(0));
    
    let a1 = Arc::clone(&resource_a);
    let b1 = Arc::clone(&resource_b);
    let thread1 = thread::spawn(move || {
        let _guard_a = a1.lock().unwrap();  // –ó–∞—Ö–æ–ø–ª—é—î A
        thread::sleep(std::time::Duration::from_millis(1));
        let _guard_b = b1.lock().unwrap();  // –ß–µ–∫–∞—î B
        println!("Thread 1 done");
    });
    
    let a2 = Arc::clone(&resource_a);
    let b2 = Arc::clone(&resource_b);
    let thread2 = thread::spawn(move || {
        let _guard_b = b2.lock().unwrap();  // –ó–∞—Ö–æ–ø–ª—é—î B
        thread::sleep(std::time::Duration::from_millis(1));
        let _guard_a = a2.lock().unwrap();  // –ß–µ–∫–∞—î A
        println!("Thread 2 done");
    });
    
    thread1.join().unwrap();
    thread2.join().unwrap();
    // –ü—Ä–æ–≥—Ä–∞–º–∞ –∑–∞–≤–∏—Å–Ω–µ ‚Äî –∂–æ–¥–µ–Ω –ø–æ—Ç—ñ–∫ –Ω–µ –∑–∞–≤–µ—Ä—à–∏—Ç—å—Å—è
}
```

### –ß–æ—Ç–∏—Ä–∏ —É–º–æ–≤–∏ deadlock (—É–º–æ–≤–∏ –ö–æ—Ñ—Ñ–º–∞–Ω–∞)

Deadlock –º–æ–∂–ª–∏–≤–∏–π, –ª–∏—à–µ —è–∫—â–æ –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è –í–°–Ü —á–æ—Ç–∏—Ä–∏ —É–º–æ–≤–∏:

1. **–í–∑–∞—î–º–Ω–µ –≤–∏–∫–ª—é—á–µ–Ω–Ω—è**: —Ä–µ—Å—É—Ä—Å –Ω–µ –º–æ–∂–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏—Å—å –∫—ñ–ª—å–∫–æ–º–∞ –ø–æ—Ç–æ–∫–∞–º–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ
2. **–£—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–∞ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è**: –ø–æ—Ç—ñ–∫ —Ç—Ä–∏–º–∞—î —Ä–µ—Å—É—Ä—Å —ñ —á–µ–∫–∞—î —ñ–Ω—à–∏–π
3. **–í—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å –ø—Ä–∏–º—É—Å–æ–≤–æ–≥–æ –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è**: –Ω–µ –º–æ–∂–Ω–∞ –≤—ñ–¥—ñ–±—Ä–∞—Ç–∏ —Ä–µ—Å—É—Ä—Å —É –ø–æ—Ç–æ–∫—É
4. **–¶–∏–∫–ª—ñ—á–Ω–µ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è**: —ñ—Å–Ω—É—î —Ü–∏–∫–ª –ø–æ—Ç–æ–∫—ñ–≤, –¥–µ –∫–æ–∂–µ–Ω —á–µ–∫–∞—î –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ

–ü–æ—Ä—É—à–µ–Ω–Ω—è –±—É–¥—å-—è–∫–æ—ó —É–º–æ–≤–∏ –∑–∞–ø–æ–±—ñ–≥–∞—î deadlock.

### –°—Ç—Ä–∞—Ç–µ–≥—ñ—ó –∑–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è

**–Ñ–¥–∏–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è** ‚Äî –∑–∞–≤–∂–¥–∏ –∑–∞—Ö–æ–ø–ª—é–π—Ç–µ –º'—é—Ç–µ–∫—Å–∏ –≤ –æ–¥–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É:

```rust
// –ó–∞–≤–∂–¥–∏ —Å–ø–æ—á–∞—Ç–∫—É A, –ø–æ—Ç—ñ–º B
fn safe_operation(a: &Mutex<i32>, b: &Mutex<i32>) {
    let _guard_a = a.lock().unwrap();
    let _guard_b = b.lock().unwrap();
    // ...
}
```

**try_lock –∑ –ø–æ–≤—Ç–æ—Ä–Ω–∏–º–∏ —Å–ø—Ä–æ–±–∞–º–∏**:

```rust
use std::sync::Mutex;
use std::thread;
use std::time::Duration;

fn try_lock_both<T, U>(
    a: &Mutex<T>, 
    b: &Mutex<U>,
    max_attempts: usize,
) -> Option<(std::sync::MutexGuard<T>, std::sync::MutexGuard<U>)> {
    for _ in 0..max_attempts {
        if let Ok(guard_a) = a.try_lock() {
            if let Ok(guard_b) = b.try_lock() {
                return Some((guard_a, guard_b));
            }
            // –ù–µ –≤–¥–∞–ª–æ—Å—è –∑–∞—Ö–æ–ø–∏—Ç–∏ B ‚Äî –∑–≤—ñ–ª—å–Ω—è—î–º–æ A —ñ –ø—Ä–æ–±—É—î–º–æ –∑–Ω–æ–≤—É
        }
        thread::sleep(Duration::from_micros(100));
    }
    None
}
```

**–¢–∞–π–º–∞—É—Ç–∏** (—É parking_lot crate):

```rust
use parking_lot::Mutex;
use std::time::Duration;

let guard = mutex.try_lock_for(Duration::from_secs(5))
    .ok_or(Error::LockTimeout)?;
```

**–£–Ω–∏–∫–∞–Ω–Ω—è –≤–∫–ª–∞–¥–µ–Ω–∏—Ö –±–ª–æ–∫—É–≤–∞–Ω—å**: —Ç—Ä–∏–º–∞—Ç–∏ –ª–∏—à–µ –æ–¥–∏–Ω –º'—é—Ç–µ–∫—Å –æ–¥–Ω–æ—á–∞—Å–Ω–æ, —è–∫—â–æ –º–æ–∂–ª–∏–≤–æ.

---

## –¢–ï–û–†–Ü–Ø: MUTEX POISONING

### –©–æ —Ç–∞–∫–µ poisoning

–ö–æ–ª–∏ –ø–æ—Ç—ñ–∫ –ø–∞–Ω—ñ–∫—É—î, —Ç—Ä–∏–º–∞—é—á–∏ MutexGuard, –º'—é—Ç–µ–∫—Å —Å—Ç–∞—î "–æ—Ç—Ä—É—î–Ω–∏–º" (poisoned). –ù–∞—Å—Ç—É–ø–Ω—ñ —Å–ø—Ä–æ–±–∏ –∑–∞—Ö–æ–ø–∏—Ç–∏ –π–æ–≥–æ –ø–æ–≤–µ—Ä—Ç–∞—é—Ç—å –ø–æ–º–∏–ª–∫—É:

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    let data = Arc::new(Mutex::new(vec![1, 2, 3]));
    
    let d = Arc::clone(&data);
    let handle = thread::spawn(move || {
        let mut guard = d.lock().unwrap();
        guard.push(4);
        panic!("Oops!");  // –ü–∞–Ω—ñ–∫–∞ –∑ –∞–∫—Ç–∏–≤–Ω–∏–º guard
    });
    
    let _ = handle.join();  // –ü–æ—Ç—ñ–∫ –≤–ø–∞–≤
    
    // –°–ø—Ä–æ–±–∞ –∑–∞—Ö–æ–ø–∏—Ç–∏ "–æ—Ç—Ä—É—î–Ω–∏–π" –º'—é—Ç–µ–∫—Å
    match data.lock() {
        Ok(guard) => println!("Data: {:?}", *guard),
        Err(poisoned) => {
            println!("Mutex was poisoned!");
            // –ú–æ–∂–Ω–∞ –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–∞–Ω—ñ –≤—Å–µ –æ–¥–Ω–æ:
            let guard = poisoned.into_inner();
            println!("Data anyway: {:?}", *guard);
        }
    }
}
```

### –ß–æ–º—É —Ü–µ –≤–∞–∂–ª–∏–≤–æ

Poisoning ‚Äî —Ü–µ —Å–∏–≥–Ω–∞–ª: "–¥–∞–Ω—ñ –º–æ–≥–ª–∏ –∑–∞–ª–∏—à–∏—Ç–∏—Å—å —É –Ω–µ–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–º—É —Å—Ç–∞–Ω—ñ". –ü–æ—Ç—ñ–∫ –ø–∞–Ω—ñ–∫–Ω—É–≤ –ø–æ—Å–µ—Ä–µ–¥ –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—ó ‚Äî —Ö—Ç–æ –∑–Ω–∞—î, –≤ —è–∫–æ–º—É —Å—Ç–∞–Ω—ñ –¥–∞–Ω—ñ?

–í–∞—Ä—ñ–∞–Ω—Ç–∏ –æ–±—Ä–æ–±–∫–∏:

**Propagate panic** ‚Äî —è–∫—â–æ –≤–∞—à –∫–æ–¥ —Ç–µ–∂ –º–∞—î –≤–ø–∞—Å—Ç–∏:
```rust
let guard = mutex.lock().unwrap();  // –ü–∞–Ω—ñ–∫–∞ —è–∫—â–æ poisoned
```

**Recover** ‚Äî —è–∫—â–æ –º–æ–∂–µ—Ç–µ –≤—ñ–¥–Ω–æ–≤–∏—Ç–∏—Å—å:
```rust
let guard = mutex.lock().unwrap_or_else(|poisoned| {
    log::warn!("Mutex was poisoned, recovering");
    poisoned.into_inner()
});
```

**Clear poison** ‚Äî —Å–∫–∏–Ω—É—Ç–∏ –ø—Ä–∞–ø–æ—Ä–µ—Ü—å –ø—ñ—Å–ª—è –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è:
```rust
if mutex.is_poisoned() {
    mutex.clear_poison();
}
```

### parking_lot::Mutex –Ω–µ –º–∞—î poisoning

–ö—Ä–µ–π—Ç `parking_lot` –Ω–∞–¥–∞—î –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ñ –ø—Ä–∏–º—ñ—Ç–∏–≤–∏ –±–µ–∑ poisoning:

```rust
use parking_lot::Mutex;

let mutex = Mutex::new(42);
let guard = mutex.lock();  // –ó–∞–≤–∂–¥–∏ –ø–æ–≤–µ—Ä—Ç–∞—î guard, –Ω–µ Result
```

–¶–µ —Å–ø—Ä–æ—â—É—î –∫–æ–¥, –∞–ª–µ –≤—Ç—Ä–∞—á–∞—î—Ç—å—Å—è –∑–∞—Ö–∏—Å—Ç –≤—ñ–¥ –Ω–µ–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–∏—Ö –¥–∞–Ω–∏—Ö. –í–∏–±—ñ—Ä –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ —Å–∏—Ç—É–∞—Ü—ñ—ó.

---

## –¢–ï–û–†–Ü–Ø: RWLOCK ‚Äî –ß–ò–¢–ê–ß–Ü –¢–ê –ü–ò–°–¨–ú–ï–ù–ù–ò–ö–ò

### –ö–æ–ª–∏ RwLock –∫—Ä–∞—â–µ –∑–∞ Mutex

RwLock –¥–æ–∑–≤–æ–ª—è—î:
- –ë–∞–≥–∞—Ç–æ –æ–¥–Ω–æ—á–∞—Å–Ω–∏—Ö —á–∏—Ç–∞—á—ñ–≤ (read lock)
- –õ–∏—à–µ –æ–¥–∏–Ω –ø–∏—Å—å–º–µ–Ω–Ω–∏–∫ (write lock)
- –ü–∏—Å—å–º–µ–Ω–Ω–∏–∫ –±–ª–æ–∫—É—î –≤—Å—ñ—Ö

–Ø–∫—â–æ —á–∏—Ç–∞–Ω–Ω—è –∑–Ω–∞—á–Ω–æ —á–∞—Å—Ç—ñ—à–µ –∑–∞ –∑–∞–ø–∏—Å ‚Äî RwLock –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–∏–π:

```rust
use std::sync::RwLock;

let config = RwLock::new(Config::default());

// –ë–∞–≥–∞—Ç–æ –ø–æ—Ç–æ–∫—ñ–≤ –º–æ–∂—É—Ç—å —á–∏—Ç–∞—Ç–∏ –æ–¥–Ω–æ—á–∞—Å–Ω–æ
let read_guard = config.read().unwrap();
println!("{:?}", *read_guard);

// –õ–∏—à–µ –æ–¥–∏–Ω –ø–æ—Ç—ñ–∫ –º–æ–∂–µ –ø–∏—Å–∞—Ç–∏
let mut write_guard = config.write().unwrap();
write_guard.timeout = 60;
```

### –ü–∞—Å—Ç–∫–∞: writer starvation

–Ø–∫—â–æ —á–∏—Ç–∞—á—ñ –ø–æ—Å—Ç—ñ–π–Ω–æ —Ç—Ä–∏–º–∞—é—Ç—å lock, –ø–∏—Å—å–º–µ–Ω–Ω–∏–∫ –º–æ–∂–µ –Ω—ñ–∫–æ–ª–∏ –Ω–µ –æ—Ç—Ä–∏–º–∞—Ç–∏ –¥–æ—Å—Ç—É–ø:

```rust
// –ü–æ—Ç—ñ–∫ 1: –ø–æ—Å—Ç—ñ–π–Ω–æ —á–∏—Ç–∞—î
loop {
    let _r = config.read().unwrap();
    // ... —Ç—Ä–∏–≤–∞–ª–∞ —Ä–æ–±–æ—Ç–∞ –∑ read lock ...
}

// –ü–æ—Ç—ñ–∫ 2: —Ö–æ—á–µ –∑–∞–ø–∏—Å–∞—Ç–∏
let _w = config.write().unwrap();  // –ú–æ–∂–µ —á–µ–∫–∞—Ç–∏ –≤—ñ—á–Ω–æ!
```

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∏–π RwLock —É Rust –Ω–µ –≥–∞—Ä–∞–Ω—Ç—É—î fairness. parking_lot::RwLock –º–∞—î —Ä–µ–∂–∏–º–∏ –∑ —Ä—ñ–∑–Ω–∏–º–∏ –≥–∞—Ä–∞–Ω—Ç—ñ—è–º–∏.

### –ü–∞—Å—Ç–∫–∞: upgrade –Ω–µ–º–æ–∂–ª–∏–≤–∏–π

–ù–µ –º–æ–∂–Ω–∞ "–ø—ñ–¥–≤–∏—â–∏—Ç–∏" read lock –¥–æ write lock:

```rust
let read_guard = rwlock.read().unwrap();
if needs_modification(&*read_guard) {
    // –•–æ—á–µ–º–æ –∑–∞–ø–∏—Å–∞—Ç–∏, –∞–ª–µ –º–∞—î–º–æ read lock
    // –ù–µ–º–æ–∂–ª–∏–≤–æ! –ü–æ—Ç—Ä—ñ–±–Ω–æ –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ read —ñ –∑–∞—Ö–æ–ø–∏—Ç–∏ write
    drop(read_guard);
    let mut write_guard = rwlock.write().unwrap();
    // –ê–ª–µ —Ç–µ–ø–µ—Ä –¥–∞–Ω—ñ –º–æ–≥–ª–∏ –∑–º—ñ–Ω–∏—Ç–∏—Å—å!
}
```

–†—ñ—à–µ–Ω–Ω—è: –æ–¥—Ä–∞–∑—É –∑–∞—Ö–æ–ø–ª—é–≤–∞—Ç–∏ write lock, —è–∫—â–æ —î –π–º–æ–≤—ñ—Ä–Ω—ñ—Å—Ç—å –º–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—ó, –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ parking_lot –∑ upgradable locks.

### –ü–∞—Å—Ç–∫–∞: deadlock —á–µ—Ä–µ–∑ –≤–∫–ª–∞–¥–µ–Ω—ñ read locks

```rust
let _r1 = rwlock.read().unwrap();
let _r2 = rwlock.read().unwrap();  // –ú–æ–∂–µ –∑–∞–≤–∏—Å–Ω—É—Ç–∏!
```

–î–µ—è–∫—ñ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—ó RwLock –Ω–µ –¥–æ–∑–≤–æ–ª—è—é—Ç—å –æ–¥–Ω–æ–º—É –ø–æ—Ç–æ–∫—É –¥–≤—ñ—á—ñ –∑–∞—Ö–æ–ø–∏—Ç–∏ read lock. –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞ –±—ñ–±–ª—ñ–æ—Ç–µ–∫–∞ Rust –¥–æ–∑–≤–æ–ª—è—î, –∞–ª–µ parking_lot ‚Äî –Ω—ñ (–∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º).

---

## –¢–ï–û–†–Ü–Ø: –ê–¢–û–ú–ê–†–ù–Ü –û–ü–ï–†–ê–¶–Ü–á

### –ö–æ–ª–∏ –∞—Ç–æ–º–∞—Ä–Ω—ñ —Ç–∏–ø–∏ –∫—Ä–∞—â–µ –∑–∞ Mutex

–î–ª—è –ø—Ä–æ—Å—Ç–∏—Ö —Ç–∏–ø—ñ–≤ (—á–∏—Å–ª–∞, –±—É–ª–µ–≤—ñ, –≤–∫–∞–∑—ñ–≤–Ω–∏–∫–∏) –∞—Ç–æ–º–∞—Ä–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à—ñ:

```rust
use std::sync::atomic::{AtomicU64, Ordering};

let counter = AtomicU64::new(0);

// –ê—Ç–æ–º–∞—Ä–Ω–∏–π —ñ–Ω–∫—Ä–µ–º–µ–Ω—Ç ‚Äî –±–µ–∑ lock!
counter.fetch_add(1, Ordering::SeqCst);

let value = counter.load(Ordering::SeqCst);
```

–ê—Ç–æ–º–∞—Ä–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –Ω–µ –±–ª–æ–∫—É—é—Ç—å –ø–æ—Ç–æ–∫–∏ ‚Äî –≤–æ–Ω–∏ –≤–∏–∫–æ–Ω—É—é—Ç—å—Å—è –∞–ø–∞—Ä–∞—Ç–Ω–æ —è–∫ –æ–¥–Ω–∞ –Ω–µ–ø–æ–¥—ñ–ª—å–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è.

### Memory Ordering ‚Äî —Å–∫–ª–∞–¥–Ω–∞ —Ç–µ–º–∞

–ü–∞—Ä–∞–º–µ—Ç—Ä `Ordering` –≤–∏–∑–Ω–∞—á–∞—î –≥–∞—Ä–∞–Ω—Ç—ñ—ó –≤–∏–¥–∏–º–æ—Å—Ç—ñ –∑–º—ñ–Ω –º—ñ–∂ –ø–æ—Ç–æ–∫–∞–º–∏:

- **Relaxed**: –º—ñ–Ω—ñ–º–∞–ª—å–Ω—ñ –≥–∞—Ä–∞–Ω—Ç—ñ—ó, –ª–∏—à–µ –∞—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –æ–ø–µ—Ä–∞—Ü—ñ—ó
- **Acquire**: –≤—Å—ñ –Ω–∞—Å—Ç—É–ø–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –±–∞—á–∞—Ç—å –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –∑–∞–ø–∏—Å–∏
- **Release**: –≤—Å—ñ –ø–æ–ø–µ—Ä–µ–¥–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –≤–∏–¥–∏–º—ñ –ø—ñ—Å–ª—è —Ü—å–æ–≥–æ –∑–∞–ø–∏—Å—É
- **AcqRel**: Acquire + Release
- **SeqCst**: –Ω–∞–π—Å–∏–ª—å–Ω—ñ—à—ñ –≥–∞—Ä–∞–Ω—Ç—ñ—ó, –≥–ª–æ–±–∞–ª—å–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫

–î–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ –≤–∏–ø–∞–¥–∫—ñ–≤ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ `SeqCst` ‚Äî —Ü–µ –Ω–∞–π–±–µ–∑–ø–µ—á–Ω—ñ—à–µ. –°–ª–∞–±—à—ñ ordering –¥–∞—é—Ç—å –∫—Ä–∞—â—É –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å, –∞–ª–µ –ª–µ–≥–∫–æ –ø–æ–º–∏–ª–∏—Ç–∏—Å—å.

```rust
// –ë–µ–∑–ø–µ—á–Ω–∏–π –≤–∏–±—ñ—Ä –¥–ª—è –±—ñ–ª—å—à–æ—Å—Ç—ñ —Å–∏—Ç—É–∞—Ü—ñ–π
counter.fetch_add(1, Ordering::SeqCst);

// –û–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è –¥–ª—è –µ–∫—Å–ø–µ—Ä—Ç—ñ–≤ (–ª–µ–≥–∫–æ –∑–ª–∞–º–∞—Ç–∏!)
counter.fetch_add(1, Ordering::Relaxed);
```

### –ü–∞—Å—Ç–∫–∞: –∞—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –æ–¥–Ω—ñ—î—ó –æ–ø–µ—Ä–∞—Ü—ñ—ó ‚â† –∞—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ

```rust
use std::sync::atomic::{AtomicI32, Ordering};

let balance = AtomicI32::new(100);

// –¶–µ –ù–ï –∞—Ç–æ–º–∞—Ä–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è "–ø–µ—Ä–µ–≤—ñ—Ä–∏—Ç–∏ —ñ –∑–Ω—è—Ç–∏"!
if balance.load(Ordering::SeqCst) >= 50 {
    // –Ü–Ω—à–∏–π –ø–æ—Ç—ñ–∫ –º–æ–∂–µ –∑–º—ñ–Ω–∏—Ç–∏ balance —Ç—É—Ç!
    balance.fetch_sub(50, Ordering::SeqCst);
}
```

–ö–æ–∂–Ω–∞ –∞—Ç–æ–º–∞—Ä–Ω–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –æ–∫—Ä–µ–º–æ –∞—Ç–æ–º–∞—Ä–Ω–∞, –∞–ª–µ –ø–æ—Å–ª—ñ–¥–æ–≤–Ω—ñ—Å—Ç—å ‚Äî –Ω—ñ. –î–ª—è compare-and-swap –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ:

```rust
let mut current = balance.load(Ordering::SeqCst);
loop {
    if current < 50 {
        break;  // –ù–µ–¥–æ—Å—Ç–∞—Ç–Ω—å–æ –∫–æ—à—Ç—ñ–≤
    }
    match balance.compare_exchange(
        current,
        current - 50,
        Ordering::SeqCst,
        Ordering::SeqCst,
    ) {
        Ok(_) => break,  // –£—Å–ø—ñ—à–Ω–æ
        Err(actual) => current = actual,  // –•—Ç–æ—Å—å –∑–º—ñ–Ω–∏–≤, —Å–ø—Ä–æ–±—É—î–º–æ –∑–Ω–æ–≤—É
    }
}
```

---

## –¢–ï–û–†–Ü–Ø: BLOCKING –í ASYNC ‚Äî –ó–ê–ú–û–†–û–ñ–ï–ù–ò–ô RUNTIME

### –ü—Ä–æ–±–ª–µ–º–∞: async runtime –º–∞—î –æ–±–º–µ–∂–µ–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ—Ç–æ–∫—ñ–≤

Tokio —Ç–∞ —ñ–Ω—à—ñ async runtimes –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—Ç—å –ø—É–ª –ø–æ—Ç–æ–∫—ñ–≤ –¥–ª—è –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–¥–∞—á. –¢–∏–ø–æ–≤–æ —Ü–µ –∫—ñ–ª—å–∫—ñ—Å—Ç—å CPU cores. –Ø–∫—â–æ –≤—Å—ñ –ø–æ—Ç–æ–∫–∏ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω—ñ ‚Äî runtime "–∑–∞–º–µ—Ä–∑–∞—î".

```rust
use tokio::time::{sleep, Duration};

#[tokio::main]
async fn main() {
    tokio::spawn(async {
        // –ü–û–ì–ê–ù–û: –±–ª–æ–∫—É—é—á–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –≤ async –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ!
        std::thread::sleep(Duration::from_secs(10));
    });
    
    tokio::spawn(async {
        // –¶—è –∑–∞–¥–∞—á–∞ –Ω–µ –≤–∏–∫–æ–Ω–∞—î—Ç—å—Å—è, –ø–æ–∫–∏ –ø–µ—Ä—à–∞ –±–ª–æ–∫—É—î –ø–æ—Ç—ñ–∫
        println!("This may never print!");
    });
    
    sleep(Duration::from_secs(1)).await;
}
```

### –©–æ –≤–≤–∞–∂–∞—î—Ç—å—Å—è blocking

**–Ø–≤–Ω–æ blocking**:
- `std::thread::sleep()`
- `std::sync::Mutex::lock()` (–Ω–µ tokio::sync::Mutex!)
- –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∏–π I/O (`std::fs::read()`, `std::net::TcpStream`)
- CPU-—ñ–Ω—Ç–µ–Ω—Å–∏–≤–Ω—ñ –æ–±—á–∏—Å–ª–µ–Ω–Ω—è

**–ù–µ–æ—á–µ–≤–∏–¥–Ω–æ blocking**:
- `println!()` ‚Äî –∑–∞—Ö–æ–ø–ª—é—î –≥–ª–æ–±–∞–ª—å–Ω–∏–π lock –Ω–∞ stdout
- –î–µ—è–∫—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó –∑ `HashMap` –ø—Ä–∏ –≤–µ–ª–∏–∫–æ–º—É —Ä–æ–∑–º—ñ—Ä—ñ
- –ê–ª–æ–∫–∞—Ü—ñ—ó –≤–µ–ª–∏–∫–∏—Ö –æ–±'—î–º—ñ–≤ –ø–∞–º'—è—Ç—ñ

### –†—ñ—à–µ–Ω–Ω—è: spawn_blocking

–î–ª—è blocking –æ–ø–µ—Ä–∞—Ü—ñ–π –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –æ–∫—Ä–µ–º–∏–π –ø—É–ª –ø–æ—Ç–æ–∫—ñ–≤:

```rust
use tokio::task;

async fn read_file(path: String) -> std::io::Result<String> {
    task::spawn_blocking(move || {
        std::fs::read_to_string(path)
    }).await.unwrap()
}
```

`spawn_blocking` –≤–∏–∫–æ–Ω—É—î –∑–∞–¥–∞—á—É –≤ –æ–∫—Ä–µ–º–æ–º—É –ø—É–ª—ñ, –Ω–µ –±–ª–æ–∫—É—é—á–∏ async runtime.

### –†—ñ—à–µ–Ω–Ω—è: async-–≤–µ—Ä—Å—ñ—ó –ø—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤

–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ async-—Å—É–º—ñ—Å–Ω—ñ –≤–µ—Ä—Å—ñ—ó:

```rust
// –ó–∞–º—ñ—Å—Ç—å std::sync::Mutex
use tokio::sync::Mutex;

// –ó–∞–º—ñ—Å—Ç—å std::thread::sleep
use tokio::time::sleep;

// –ó–∞–º—ñ—Å—Ç—å std::fs::read_to_string
use tokio::fs::read_to_string;
```

### –ü–∞—Å—Ç–∫–∞: sync Mutex –≤ async –∫–æ–¥—ñ

```rust
use std::sync::Mutex;  // –ü–û–ì–ê–ù–û –≤ async!

async fn bad_example(data: Arc<Mutex<Vec<i32>>>) {
    let guard = data.lock().unwrap();  // –ë–ª–æ–∫—É—î –ø–æ—Ç—ñ–∫!
    some_async_operation().await;       // –Ü–Ω—à—ñ –∑–∞–¥–∞—á—ñ –Ω–µ –º–æ–∂—É—Ç—å –≤–∏–∫–æ–Ω–∞—Ç–∏—Å—å
    drop(guard);
}
```

–ü—Ä–æ–±–ª–µ–º–∞: –ø–æ–∫–∏ –º–∏ —Ç—Ä–∏–º–∞—î–º–æ guard, –ø–æ—Ç—ñ–∫ –∑–∞–±–ª–æ–∫–æ–≤–∞–Ω–∏–π. –í–∏–∫–ª–∏–∫ `.await` –Ω–µ –∑–≤—ñ–ª—å–Ω—è—î –ø–æ—Ç—ñ–∫ ‚Äî –≤—ñ–Ω –ø—Ä–æ—Å—Ç–æ —á–µ–∫–∞—î, —Ç—Ä–∏–º–∞—é—á–∏ lock.

–†—ñ—à–µ–Ω–Ω—è:

```rust
use tokio::sync::Mutex;  // Async-—Å—É–º—ñ—Å–Ω–∏–π Mutex

async fn good_example(data: Arc<Mutex<Vec<i32>>>) {
    let guard = data.lock().await;  // –ù–ï –±–ª–æ–∫—É—î –ø–æ—Ç—ñ–∫
    some_async_operation().await;
    drop(guard);
}
```

–ê–±–æ –∑–≤—ñ–ª—å–Ω—è–π—Ç–µ sync Mutex –ø–µ—Ä–µ–¥ await:

```rust
use std::sync::Mutex;

async fn also_ok(data: Arc<Mutex<Vec<i32>>>) {
    {
        let mut guard = data.lock().unwrap();
        guard.push(42);
    }  // guard –∑–≤—ñ–ª—å–Ω–µ–Ω–æ –î–û await
    some_async_operation().await;
}
```

---

## –¢–ï–û–†–Ü–Ø: –ö–ê–ù–ê–õ–ò ‚Äî –ë–ï–ó–ü–ï–ß–ù–ê –ö–û–ú–£–ù–Ü–ö–ê–¶–Ü–Ø

### –§—ñ–ª–æ—Å–æ—Ñ—ñ—è: "Don't communicate by sharing memory; share memory by communicating"

–ó–∞–º—ñ—Å—Ç—å —Å–ø—ñ–ª—å–Ω–æ–≥–æ —Å—Ç–∞–Ω—É –∑ –º'—é—Ç–µ–∫—Å–∞–º–∏, –ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª–∏:

```rust
use std::sync::mpsc;
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();
    
    thread::spawn(move || {
        tx.send("Hello from thread").unwrap();
    });
    
    let message = rx.recv().unwrap();
    println!("{}", message);
}
```

–ö–∞–Ω–∞–ª –≥–∞—Ä–∞–Ω—Ç—É—î –±–µ–∑–ø–µ–∫—É: –¥–∞–Ω—ñ –ø–µ—Ä–µ–¥–∞—é—Ç—å—Å—è –∑ –æ–¥–Ω–æ–≥–æ –ø–æ—Ç–æ–∫—É –≤ —ñ–Ω—à–∏–π, ownership –ø–µ—Ä–µ–º—ñ—â—É—î—Ç—å—Å—è.

### –¢–∏–ø–∏ –∫–∞–Ω–∞–ª—ñ–≤

**mpsc (multiple producer, single consumer)**:
```rust
use std::sync::mpsc;

let (tx, rx) = mpsc::channel();  // unbounded
let (tx, rx) = mpsc::sync_channel(100);  // bounded
```

**crossbeam-channel** ‚Äî –ø–æ—Ç—É–∂–Ω—ñ—à–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞:
```rust
use crossbeam_channel::{bounded, unbounded, select};

let (tx, rx) = bounded(100);
let (tx, rx) = unbounded();
```

**tokio::sync::mpsc** ‚Äî –¥–ª—è async:
```rust
use tokio::sync::mpsc;

let (tx, rx) = mpsc::channel(100);  // async, bounded
```

### –ü–∞—Å—Ç–∫–∞: unbounded channel –º–æ–∂–µ –≤–∏—á–µ—Ä–ø–∞—Ç–∏ –ø–∞–º'—è—Ç—å

```rust
let (tx, rx) = mpsc::channel();  // Unbounded!

// Producer —à–≤–∏–¥—à–∏–π –∑–∞ consumer
loop {
    tx.send(large_data.clone()).unwrap();
    // –ü–∞–º'—è—Ç—å –∑—Ä–æ—Å—Ç–∞—î –±–µ–∑ –æ–±–º–µ–∂–µ–Ω—å!
}
```

–†—ñ—à–µ–Ω–Ω—è: –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ bounded channels:

```rust
let (tx, rx) = mpsc::sync_channel(1000);  // –ú–∞–∫—Å–∏–º—É–º 1000 –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å

// send –∑–∞–±–ª–æ–∫—É—î—Ç—å—Å—è, —è–∫—â–æ –∫–∞–Ω–∞–ª –ø–æ–≤–Ω–∏–π
tx.send(data).unwrap();
```

### –ü–∞—Å—Ç–∫–∞: deadlock —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª–∏

```rust
// –ü–æ—Ç—ñ–∫ A
tx_to_b.send(request).unwrap();
let response = rx_from_b.recv().unwrap();  // –ß–µ–∫–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å

// –ü–æ—Ç—ñ–∫ B  
tx_to_a.send(request).unwrap();
let response = rx_from_a.recv().unwrap();  // –ß–µ–∫–∞—î –≤—ñ–¥–ø–æ–≤—ñ–¥—å

// –û–±–∏–¥–≤–∞ —á–µ–∫–∞—é—Ç—å, –Ω—ñ—Ö—Ç–æ –Ω–µ –æ–±—Ä–æ–±–ª—è—î!
```

–†—ñ—à–µ–Ω–Ω—è: –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞ –æ–±—Ä–æ–±–∫–∞ –∞–±–æ select:

```rust
use crossbeam_channel::select;

loop {
    select! {
        recv(rx_requests) -> msg => handle_request(msg),
        recv(rx_responses) -> msg => handle_response(msg),
    }
}
```

---

## –¢–ï–û–†–Ü–Ø: SEND –¢–ê SYNC ‚Äî –ú–ê–†–ö–ï–†–ù–Ü –¢–†–ï–ô–¢–ò

### –©–æ –æ–∑–Ω–∞—á–∞—é—Ç—å Send —Ç–∞ Sync

**Send**: —Ç–∏–ø –º–æ–∂–Ω–∞ –±–µ–∑–ø–µ—á–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç–∏ –≤ —ñ–Ω—à–∏–π –ø–æ—Ç—ñ–∫.
**Sync**: —Ç–∏–ø –º–æ–∂–Ω–∞ –±–µ–∑–ø–µ—á–Ω–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ –∑ –∫—ñ–ª—å–∫–æ—Ö –ø–æ—Ç–æ–∫—ñ–≤ –æ–¥–Ω–æ—á–∞—Å–Ω–æ (—á–µ—Ä–µ–∑ &T).

```rust
// Send: T –º–æ–∂–Ω–∞ –ø–µ—Ä–µ–¥–∞—Ç–∏ –≤ —ñ–Ω—à–∏–π –ø–æ—Ç—ñ–∫
fn spawn_with<T: Send + 'static>(value: T) {
    std::thread::spawn(move || {
        // value —Ç–µ–ø–µ—Ä –Ω–∞–ª–µ–∂–∏—Ç—å —Ü—å–æ–º—É –ø–æ—Ç–æ–∫—É
    });
}

// Sync: &T –º–æ–∂–Ω–∞ —Ä–æ–∑–¥—ñ–ª–∏—Ç–∏ –º—ñ–∂ –ø–æ—Ç–æ–∫–∞–º–∏
fn share<T: Sync>(value: &T) {
    // –ö—ñ–ª—å–∫–∞ –ø–æ—Ç–æ–∫—ñ–≤ –º–æ–∂—É—Ç—å –º–∞—Ç–∏ &T –æ–¥–Ω–æ—á–∞—Å–Ω–æ
}
```

### Rc –Ω–µ Send, Rc –Ω–µ Sync

```rust
use std::rc::Rc;
use std::thread;

let rc = Rc::new(42);
thread::spawn(move || {
    println!("{}", rc);  // –ü–û–ú–ò–õ–ö–ê: Rc<i32> cannot be sent between threads safely
});
```

Rc –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î non-atomic reference counting ‚Äî –Ω–µ–±–µ–∑–ø–µ—á–Ω–æ –º—ñ–∂ –ø–æ—Ç–æ–∫–∞–º–∏. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Arc:

```rust
use std::sync::Arc;

let arc = Arc::new(42);
thread::spawn(move || {
    println!("{}", arc);  // OK: Arc is Send
});
```

### RefCell –Ω–µ Sync

```rust
use std::cell::RefCell;
use std::sync::Arc;
use std::thread;

let shared = Arc::new(RefCell::new(42));
let s = Arc::clone(&shared);
thread::spawn(move || {
    *s.borrow_mut() += 1;  // –ü–û–ú–ò–õ–ö–ê: RefCell cannot be shared between threads
});
```

RefCell –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î non-atomic borrow counting. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Mutex –∞–±–æ RwLock:

```rust
use std::sync::{Arc, Mutex};

let shared = Arc::new(Mutex::new(42));
let s = Arc::clone(&shared);
thread::spawn(move || {
    *s.lock().unwrap() += 1;  // OK
});
```

### –ü—Ä–∞–≤–∏–ª–æ: Arc<Mutex<T>> –¥–ª—è —Å–ø—ñ–ª—å–Ω–æ–≥–æ –º—É—Ç–∞–±–µ–ª—å–Ω–æ–≥–æ —Å—Ç–∞–Ω—É

```rust
use std::sync::{Arc, Mutex};

struct SharedState {
    counter: Arc<Mutex<u64>>,
    data: Arc<Mutex<Vec<String>>>,
}

impl Clone for SharedState {
    fn clone(&self) -> Self {
        Self {
            counter: Arc::clone(&self.counter),
            data: Arc::clone(&self.data),
        }
    }
}
```

---

## –ü–†–ê–ö–¢–ò–ß–ù–Ü –†–ï–ö–û–ú–ï–ù–î–ê–¶–Ü–á

### –ü—Ä–∞–≤–∏–ª–æ 1: –ú—ñ–Ω—ñ–º—ñ–∑—É–π—Ç–µ —Å–ø—ñ–ª—å–Ω–∏–π —Å—Ç–∞–Ω

```rust
// –ü–æ–≥–∞–Ω–æ: –±–∞–≥–∞—Ç–æ —Å–ø—ñ–ª—å–Ω–æ–≥–æ —Å—Ç–∞–Ω—É
struct SharedEverything {
    data: Arc<Mutex<Data>>,
    config: Arc<Mutex<Config>>,
    cache: Arc<Mutex<Cache>>,
}

// –ö—Ä–∞—â–µ: –∫–æ–∂–µ–Ω –ø–æ—Ç—ñ–∫ –º–∞—î –≤–ª–∞—Å–Ω—ñ –¥–∞–Ω—ñ, —Å–ø—ñ–ª–∫—É—é—Ç—å—Å—è —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª–∏
struct Worker {
    id: usize,
    local_cache: HashMap<Key, Value>,
    command_rx: Receiver<Command>,
    result_tx: Sender<Result>,
}
```

### –ü—Ä–∞–≤–∏–ª–æ 2: –Ñ–¥–∏–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è –º'—é—Ç–µ–∫—Å—ñ–≤

```rust
// –í–∏–∑–Ω–∞—á—Ç–µ –≥–ª–æ–±–∞–ª—å–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ —ñ –∑–∞–≤–∂–¥–∏ –¥–æ—Ç—Ä–∏–º—É–π—Ç–µ—Å—å
// –ù–∞–ø—Ä–∏–∫–ª–∞–¥: config < state < cache

fn update_all(
    config: &Mutex<Config>,
    state: &Mutex<State>,
    cache: &Mutex<Cache>,
) {
    let _c = config.lock().unwrap();  // –ó–∞–≤–∂–¥–∏ —Å–ø–æ—á–∞—Ç–∫—É config
    let _s = state.lock().unwrap();   // –ü–æ—Ç—ñ–º state
    let _cache = cache.lock().unwrap(); // –ü–æ—Ç—ñ–º cache
}
```

### –ü—Ä–∞–≤–∏–ª–æ 3: –¢—Ä–∏–º–∞–π—Ç–µ lock –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–π —á–∞—Å

```rust
// –ü–æ–≥–∞–Ω–æ: —Ç—Ä–∏–≤–∞–ª–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è –ø—ñ–¥ lock
let guard = mutex.lock().unwrap();
let result = expensive_computation(&*guard);  // Lock —Ç—Ä–∏–º–∞—î—Ç—å—Å—è –¥–æ–≤–≥–æ
drop(guard);

// –ö—Ä–∞—â–µ: –∫–æ–ø—ñ—é—î–º–æ –¥–∞–Ω—ñ —ñ –ø—Ä–∞—Ü—é—î–º–æ –±–µ–∑ lock
let data = {
    let guard = mutex.lock().unwrap();
    guard.clone()  // –®–≤–∏–¥–∫–µ –∫–æ–ø—ñ—é–≤–∞–Ω–Ω—è
};  // Lock –∑–≤—ñ–ª—å–Ω–µ–Ω–æ
let result = expensive_computation(&data);  // –ü—Ä–∞—Ü—é—î–º–æ –∑ –∫–æ–ø—ñ—î—é
```

### –ü—Ä–∞–≤–∏–ª–æ 4: –ù–µ —Ç—Ä–∏–º–∞–π—Ç–µ lock —á–µ—Ä–µ–∑ .await

```rust
// –ü–æ–≥–∞–Ω–æ
let guard = mutex.lock().await;
async_operation().await;  // Lock —Ç—Ä–∏–º–∞—î—Ç—å—Å—è —á–µ—Ä–µ–∑ await!
drop(guard);

// –ö—Ä–∞—â–µ
{
    let mut guard = mutex.lock().await;
    guard.prepare();
}  // Lock –∑–≤—ñ–ª—å–Ω–µ–Ω–æ
async_operation().await;
{
    let mut guard = mutex.lock().await;
    guard.finalize();
}
```

### –ü—Ä–∞–≤–∏–ª–æ 5: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ spawn_blocking –¥–ª—è blocking –æ–ø–µ—Ä–∞—Ü—ñ–π

```rust
// –ü–æ–≥–∞–Ω–æ: blocking –≤ async
async fn bad() {
    let data = std::fs::read_to_string("file.txt").unwrap();
}

// –î–æ–±—Ä–µ
async fn good() {
    let data = tokio::task::spawn_blocking(|| {
        std::fs::read_to_string("file.txt")
    }).await.unwrap().unwrap();
}

// –©–µ –∫—Ä–∞—â–µ: async I/O
async fn best() {
    let data = tokio::fs::read_to_string("file.txt").await.unwrap();
}
```

### –ü—Ä–∞–≤–∏–ª–æ 6: Bounded channels –¥–ª—è backpressure

```rust
// –ü–æ–≥–∞–Ω–æ: unbounded –º–æ–∂–µ –≤–∏—á–µ—Ä–ø–∞—Ç–∏ –ø–∞–º'—è—Ç—å
let (tx, rx) = mpsc::channel();

// –î–æ–±—Ä–µ: bounded —Å—Ç–≤–æ—Ä—é—î backpressure
let (tx, rx) = mpsc::sync_channel(1000);
// –∞–±–æ
let (tx, rx) = tokio::sync::mpsc::channel(1000);
```

---

## –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –¥–æ —Ä–æ—é –ë–ü–õ–ê

### –ê—Ä—Ö—ñ—Ç–µ–∫—Ç—É—Ä–∞ –∑ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–º —Å–ø—ñ–ª—å–Ω–∏–º —Å—Ç–∞–Ω–æ–º

```rust
use tokio::sync::mpsc;

struct DroneController {
    id: DroneId,
    // –õ–æ–∫–∞–ª—å–Ω–∏–π —Å—Ç–∞–Ω ‚Äî –Ω–µ –ø–æ—Ç—Ä–µ–±—É—î —Å–∏–Ω—Ö—Ä–æ–Ω—ñ–∑–∞—Ü—ñ—ó
    position: Position,
    battery: f32,
    
    // –ö–æ–º—É–Ω—ñ–∫–∞—Ü—ñ—è —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª–∏
    command_rx: mpsc::Receiver<Command>,
    telemetry_tx: mpsc::Sender<Telemetry>,
    swarm_tx: mpsc::Sender<SwarmMessage>,
}

impl DroneController {
    async fn run(mut self) {
        loop {
            tokio::select! {
                Some(cmd) = self.command_rx.recv() => {
                    self.handle_command(cmd).await;
                }
                _ = tokio::time::sleep(Duration::from_millis(100)) => {
                    self.send_telemetry().await;
                }
            }
        }
    }
    
    async fn handle_command(&mut self, cmd: Command) {
        match cmd {
            Command::MoveTo(pos) => {
                self.position = pos;
            }
            Command::SetAltitude(alt) => {
                self.position.altitude = alt;
            }
        }
    }
    
    async fn send_telemetry(&self) {
        let telemetry = Telemetry {
            drone_id: self.id,
            position: self.position,
            battery: self.battery,
            timestamp: Instant::now(),
        };
        let _ = self.telemetry_tx.send(telemetry).await;
    }
}
```

### –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç–æ—Ä —Ä–æ—é –∑ –±–µ–∑–ø–µ—á–Ω–∏–º —Å–ø—ñ–ª—å–Ω–∏–º —Å—Ç–∞–Ω–æ–º

```rust
use std::collections::HashMap;
use tokio::sync::RwLock;
use std::sync::Arc;

struct SwarmCoordinator {
    // RwLock: –±–∞–≥–∞—Ç–æ —á–∏—Ç–∞—á—ñ–≤ (–ø–µ—Ä–µ–≥–ª—è–¥ –ø–æ–∑–∏—Ü—ñ–π), —Ä—ñ–¥–∫—ñ—Å–Ω—ñ –∑–∞–ø–∏—Å–∏ (–æ–Ω–æ–≤–ª–µ–Ω–Ω—è)
    drone_positions: Arc<RwLock<HashMap<DroneId, Position>>>,
    
    // –ö–∞–Ω–∞–ª–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥ –∫–æ–∂–Ω–æ–º—É –¥—Ä–æ–Ω—É
    command_txs: HashMap<DroneId, mpsc::Sender<Command>>,
    
    // –û—Ç—Ä–∏–º–∞–Ω–Ω—è —Ç–µ–ª–µ–º–µ—Ç—Ä—ñ—ó
    telemetry_rx: mpsc::Receiver<Telemetry>,
}

impl SwarmCoordinator {
    async fn run(mut self) {
        while let Some(telemetry) = self.telemetry_rx.recv().await {
            // –û–Ω–æ–≤–ª—é—î–º–æ –ø–æ–∑–∏—Ü—ñ—é (write lock)
            {
                let mut positions = self.drone_positions.write().await;
                positions.insert(telemetry.drone_id, telemetry.position);
            }  // Write lock –∑–≤—ñ–ª—å–Ω–µ–Ω–æ —à–≤–∏–¥–∫–æ
            
            // –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–ª—ñ–∑—ñ—ó (read lock)
            self.check_collisions().await;
        }
    }
    
    async fn check_collisions(&self) {
        let positions = self.drone_positions.read().await;
        
        for (id1, pos1) in positions.iter() {
            for (id2, pos2) in positions.iter() {
                if id1 < id2 && pos1.distance_to(pos2) < SAFE_DISTANCE {
                    log::warn!("Potential collision: {} and {}", id1, id2);
                    // –í—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –∫–æ–º–∞–Ω–¥–∏ —É–Ω–∏–∫–Ω–µ–Ω–Ω—è
                }
            }
        }
    }
}
```

### –ë–µ–∑–ø–µ—á–Ω–µ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ä–æ–±–æ—Ç–∏ (graceful shutdown)

```rust
use tokio::sync::watch;
use tokio_util::sync::CancellationToken;

struct SwarmSystem {
    cancel_token: CancellationToken,
    shutdown_complete_tx: mpsc::Sender<()>,
}

impl SwarmSystem {
    async fn run_drone(
        &self,
        mut controller: DroneController,
        mut shutdown_complete: mpsc::Sender<()>,
    ) {
        loop {
            tokio::select! {
                // –ù–æ—Ä–º–∞–ª—å–Ω–∞ —Ä–æ–±–æ—Ç–∞
                Some(cmd) = controller.command_rx.recv() => {
                    controller.handle_command(cmd).await;
                }
                
                // –°–∏–≥–Ω–∞–ª –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
                _ = self.cancel_token.cancelled() => {
                    log::info!("Drone {} shutting down", controller.id);
                    controller.land_safely().await;
                    break;
                }
            }
        }
        
        // –°–∏–≥–Ω–∞–ª—ñ–∑—É—î–º–æ –ø—Ä–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è
        let _ = shutdown_complete.send(()).await;
    }
    
    async fn shutdown(&self, drone_count: usize) {
        log::info!("Initiating swarm shutdown");
        
        // –°–∏–≥–Ω–∞–ª –≤—Å—ñ–º –¥—Ä–æ–Ω–∞–º
        self.cancel_token.cancel();
        
        // –ß–µ–∫–∞—î–º–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—ñ—Ö
        let mut completed = 0;
        let mut rx = self.shutdown_complete_tx.subscribe();
        
        while completed < drone_count {
            tokio::select! {
                _ = rx.recv() => {
                    completed += 1;
                    log::info!("Drone landed: {}/{}", completed, drone_count);
                }
                _ = tokio::time::sleep(Duration::from_secs(30)) => {
                    log::error!("Shutdown timeout, {} drones not responding", 
                               drone_count - completed);
                    break;
                }
            }
        }
    }
}
```

---

## –†–µ–∑—é–º–µ

–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ —Ä–æ–∑–≥–ª—è–Ω—É–ª–∏ –ø—ñ–¥—Å—Ç—É–ø–Ω—ñ –∞—Å–ø–µ–∫—Ç–∏ –ø–∞—Ä–∞–ª–µ–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è.

**Data race vs race condition**: Rust –≥–∞—Ä–∞–Ω—Ç—É—î –≤—ñ–¥—Å—É—Ç–Ω—ñ—Å—Ç—å data races (–∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä –Ω–µ –¥–æ–∑–≤–æ–ª–∏—Ç—å), –∞–ª–µ –Ω–µ –∑–∞—Ö–∏—â–∞—î –≤—ñ–¥ –ª–æ–≥—ñ—á–Ω–∏—Ö race conditions. –ê—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –æ–∫—Ä–µ–º–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π –Ω–µ –æ–∑–Ω–∞—á–∞—î –∞—Ç–æ–º–∞—Ä–Ω—ñ—Å—Ç—å –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ.

**Deadlock**: –≤–∏–Ω–∏–∫–∞—î –ø—Ä–∏ —Ü–∏–∫–ª—ñ—á–Ω–æ–º—É –æ—á—ñ–∫—É–≤–∞–Ω–Ω—ñ —Ä–µ—Å—É—Ä—Å—ñ–≤. –ó–∞–ø–æ–±—ñ–≥–∞–Ω–Ω—è: —î–¥–∏–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞—Ö–æ–ø–ª–µ–Ω–Ω—è, try_lock –∑ —Ç–∞–π–º–∞—É—Ç–∞–º–∏, –º—ñ–Ω—ñ–º—ñ–∑–∞—Ü—ñ—è –≤–∫–ª–∞–¥–µ–Ω–∏—Ö –±–ª–æ–∫—É–≤–∞–Ω—å.

**Mutex poisoning**: –º'—é—Ç–µ–∫—Å —Å—Ç–∞—î "–æ—Ç—Ä—É—î–Ω–∏–º" –ø—ñ—Å–ª—è –ø–∞–Ω—ñ–∫–∏ –ø–æ—Ç–æ–∫—É. –í–∏—Ä—ñ—à—É–π—Ç–µ: propagate (unwrap) –∞–±–æ recover (into_inner).

**RwLock**: –µ—Ñ–µ–∫—Ç–∏–≤–Ω—ñ—à–∏–π –ø—Ä–∏ —á–∞—Å—Ç–æ–º—É —á–∏—Ç–∞–Ω–Ω—ñ, –∞–ª–µ –º–∞—î –ø–∞—Å—Ç–∫–∏ ‚Äî writer starvation, –Ω–µ–º–æ–∂–ª–∏–≤—ñ—Å—Ç—å upgrade.

**–ê—Ç–æ–º–∞—Ä–Ω—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó**: —à–≤–∏–¥—à—ñ –∑–∞ Mutex –¥–ª—è –ø—Ä–æ—Å—Ç–∏—Ö —Ç–∏–ø—ñ–≤, –∞–ª–µ memory ordering ‚Äî —Å–∫–ª–∞–¥–Ω–∞ —Ç–µ–º–∞. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ SeqCst –¥–ª—è –±–µ–∑–ø–µ–∫–∏.

**Blocking –≤ async**: –±–ª–æ–∫—É—é—á—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó "–∑–∞–º–æ—Ä–æ–∂—É—é—Ç—å" async runtime. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ spawn_blocking –∞–±–æ async-–≤–µ—Ä—Å—ñ—ó –ø—Ä–∏–º—ñ—Ç–∏–≤—ñ–≤.

**–ö–∞–Ω–∞–ª–∏**: –±–µ–∑–ø–µ—á–Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ —Å–ø—ñ–ª—å–Ω–æ–º—É —Å—Ç–∞–Ω—É. Bounded channels –¥–ª—è backpressure.

**Send —Ç–∞ Sync**: Rc –Ω–µ Send, RefCell –Ω–µ Sync. –î–ª—è –±–∞–≥–∞—Ç–æ–ø–æ—Ç–æ–∫–æ–≤–æ—Å—Ç—ñ ‚Äî Arc<Mutex<T>>.

---

## üîó –ó–≤'—è–∑–æ–∫ –∑ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –º–∞—Ç–µ—Ä—ñ–∞–ª–æ–º

–û–ø–∞–Ω—É–≤–∞–≤—à–∏ –ø—ñ–¥—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ –ø–∞—Ä–∞–ª–µ–ª—ñ–∑–º—É, –≤–∏ –º–∞—î—Ç–µ –ø–æ–≤–Ω–∏–π –Ω–∞–±—ñ—Ä –∑–Ω–∞–Ω—å –ø—Ä–æ —Ç–∏–ø–æ–≤—ñ –ø–∞—Å—Ç–∫–∏ –≤ Rust. –¶—ñ –∑–Ω–∞–Ω–Ω—è ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è –Ω–∞–¥—ñ–π–Ω–∏—Ö —Å–∏—Å—Ç–µ–º —Ä–µ–∞–ª—å–Ω–æ–≥–æ —á–∞—Å—É, –¥–µ –∫–æ–∂–Ω–∞ –ø–æ–º–∏–ª–∫–∞ –º–æ–∂–µ –º–∞—Ç–∏ –∫—Ä–∏—Ç–∏—á–Ω—ñ –Ω–∞—Å–ª—ñ–¥–∫–∏.
