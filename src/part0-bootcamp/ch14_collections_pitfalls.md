# –ü—ñ–¥—Å—Ç—É–ø–Ω—ñ –∑–∞–¥–∞—á—ñ –∑ –∫–æ–ª–µ–∫—Ü—ñ—è–º–∏

---

## üìã –ê–Ω–æ—Ç–∞—Ü—ñ—è

–¶–µ–π —Ä–æ–∑–¥—ñ–ª —Ä–æ–∑–∫—Ä–∏–≤–∞—î –Ω–µ–æ—á–µ–≤–∏–¥–Ω—ñ –∞—Å–ø–µ–∫—Ç–∏ —Ä–æ–±–æ—Ç–∏ –∑ –∫–æ–ª–µ–∫—Ü—ñ—è–º–∏, —è–∫—ñ –º–æ–∂—É—Ç—å –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–æ—ó –ø–æ–≤–µ–¥—ñ–Ω–∫–∏, –ø–∞–Ω—ñ–∫–∏ –∞–±–æ —Ç–æ–Ω–∫–∏—Ö –ª–æ–≥—ñ—á–Ω–∏—Ö –ø–æ–º–∏–ª–æ–∫. –í–∏ –¥—ñ–∑–Ω–∞—î—Ç–µ—Å—å, —á–æ–º—É –ø–æ—Ä—è–¥–æ–∫ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É HashMap –º–æ–∂–µ –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—å –º—ñ–∂ –∑–∞–ø—É—Å–∫–∞–º–∏ –ø—Ä–æ–≥—Ä–∞–º–∏, —á–æ–º—É —á–∏—Å–ª–∞ –∑ –ø–ª–∞–≤–∞—é—á–æ—é —Ç–æ—á–∫–æ—é –Ω–µ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —è–∫ –∫–ª—é—á—ñ, —Ç–∞ —è–∫ –ø—Ä–æ—Å—Ç–∞ —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—è –º–æ–∂–µ –º–∏—Ç—Ç—î–≤–æ –∑–∞–≤–µ—Ä—à–∏—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º—É. –£ –∫–æ–Ω—Ç–µ–∫—Å—Ç—ñ —Ä–æ—é –ë–ü–õ–ê —Ü—ñ –∑–Ω–∞–Ω–Ω—è –∫—Ä–∏—Ç–∏—á–Ω—ñ: —Ä–µ—î—Å—Ç—Ä –∞–≥–µ–Ω—Ç—ñ–≤, –∫–∞—Ä—Ç–∞ –ø–µ—Ä–µ—à–∫–æ–¥, —á–µ—Ä–≥–∞ –∫–æ–º–∞–Ω–¥ ‚Äî —É—Å–µ —Ü–µ –∫–æ–ª–µ–∫—Ü—ñ—ó, —ñ –ø–æ–º–∏–ª–∫–∞ –≤ —ó—Ö –æ–±—Ä–æ–±—Ü—ñ –º–æ–∂–µ –¥–µ–∑–æ—Ä–≥–∞–Ω—ñ–∑—É–≤–∞—Ç–∏ –≤–µ—Å—å —Ä—ñ–π.

---

## üéØ –¶—ñ–ª—ñ –Ω–∞–≤—á–∞–Ω–Ω—è

–ü—ñ—Å–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è —Ü—å–æ–≥–æ —Ä–æ–∑–¥—ñ–ª—É –≤–∏ –∑–º–æ–∂–µ—Ç–µ:

1. **–ü–æ—è—Å–Ω–∏—Ç–∏** —á–æ–º—É –ø–æ—Ä—è–¥–æ–∫ —É HashMap –Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–π
2. **–£–Ω–∏–∫–∞—Ç–∏** –ø–∞–Ω—ñ–∫–∏ –ø—Ä–∏ —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó —Ç–∞ –¥–æ—Å—Ç—É–ø—ñ –¥–æ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤
3. **–†–æ–∑—É–º—ñ—Ç–∏** –≤–∏–º–æ–≥–∏ –¥–æ –∫–ª—é—á—ñ–≤ HashMap —Ç–∞ BTreeMap
4. **–ü—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±–∏—Ä–∞—Ç–∏** –º—ñ–∂ Vec, HashMap, BTreeMap, HashSet
5. **–í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏** Entry API –¥–ª—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ –∑ HashMap
6. **–†–æ–∑—Ä—ñ–∑–Ω—è—Ç–∏** iter(), iter_mut() —Ç–∞ into_iter()
7. **–ö–µ—Ä—É–≤–∞—Ç–∏** capacity –¥–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ

---

## üìö –ö–ª—é—á–æ–≤—ñ —Ç–µ—Ä–º—ñ–Ω–∏

| –¢–µ—Ä–º—ñ–Ω | –í–∏–∑–Ω–∞—á–µ–Ω–Ω—è |
|--------|------------|
| **Vec** | –î–∏–Ω–∞–º—ñ—á–Ω–∏–π –º–∞—Å–∏–≤, –µ–ª–µ–º–µ–Ω—Ç–∏ –∑–±–µ—Ä—ñ–≥–∞—é—Ç—å—Å—è –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ –≤ –ø–∞–º'—è—Ç—ñ |
| **HashMap** | –ê—Å–æ—Ü—ñ–∞—Ç–∏–≤–Ω–∏–π –º–∞—Å–∏–≤ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ñ, O(1) –¥–æ—Å—Ç—É–ø –∑–∞ –∫–ª—é—á–µ–º |
| **BTreeMap** | –ê—Å–æ—Ü—ñ–∞—Ç–∏–≤–Ω–∏–π –º–∞—Å–∏–≤ –Ω–∞ –æ—Å–Ω–æ–≤—ñ B-–¥–µ—Ä–µ–≤–∞, –∫–ª—é—á—ñ –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω—ñ |
| **HashSet** | –ú–Ω–æ–∂–∏–Ω–∞ —É–Ω—ñ–∫–∞–ª—å–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ñ |
| **capacity** | –ö—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤, –¥–ª—è —è–∫–∏—Ö –≤–∏–¥—ñ–ª–µ–Ω–æ –ø–∞–º'—è—Ç—å |
| **length (len)** | –§–∞–∫—Ç–∏—á–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ —É –∫–æ–ª–µ–∫—Ü—ñ—ó |
| **Entry API** | –ú–µ—Ö–∞–Ω—ñ–∑–º –¥–ª—è –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—ó —Ä–æ–±–æ—Ç–∏ –∑ –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏ HashMap |

---

## üí° –ú–æ—Ç–∏–≤–∞—Ü—ñ–π–Ω–∏–π –∫–µ–π—Å: –¢–µ—Å—Ç–∏, —â–æ –ø—Ä–æ—Ö–æ–¥—è—Ç—å "—ñ–Ω–æ–¥—ñ"

–ö–æ–º–∞–Ω–¥–∞ —Ä–æ–∑—Ä–æ–±–ª—è–ª–∞ —Å–∏—Å—Ç–µ–º—É —Ä–æ–∑–ø–æ–¥—ñ–ª—É –∑–∞–≤–¥–∞–Ω—å –º—ñ–∂ –¥—Ä–æ–Ω–∞–º–∏. –ö–æ–∂–µ–Ω –¥—Ä–æ–Ω —Ä–µ—î—Å—Ç—Ä—É–≤–∞–≤—Å—è –≤ HashMap, —ñ —Å–∏—Å—Ç–µ–º–∞ –ø—Ä–∏–∑–Ω–∞—á–∞–ª–∞ –∑–∞–≤–¥–∞–Ω–Ω—è "–ø–æ —á–µ—Ä–∑—ñ", —ñ—Ç–µ—Ä—É—é—á–∏ –ø–æ –≤—Å—ñ—Ö –¥—Ä–æ–Ω–∞—Ö:

```rust
fn assign_tasks(drones: &HashMap<DroneId, Drone>, tasks: &[Task]) {
    let drone_ids: Vec<_> = drones.keys().collect();
    
    for (i, task) in tasks.iter().enumerate() {
        let drone_id = drone_ids[i % drone_ids.len()];
        assign_task_to_drone(drone_id, task);
    }
}
```

–¢–µ—Å—Ç–∏ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏ —Å—Ç–∞–±—ñ–ª—å–Ω–æ –Ω–∞ –º–∞—à–∏–Ω–∞—Ö —Ä–æ–∑—Ä–æ–±–Ω–∏–∫—ñ–≤. –ê–ª–µ –Ω–∞ CI-—Å–µ—Ä–≤–µ—Ä—ñ —Ç–µ—Å—Ç–∏ –ø–æ—á–∞–ª–∏ "–º–∏–≥–∞—Ç–∏" ‚Äî —ñ–Ω–æ–¥—ñ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏, —ñ–Ω–æ–¥—ñ –ø–∞–¥–∞–ª–∏. –î–æ—Å–ª—ñ–¥–∂–µ–Ω–Ω—è –ø–æ–∫–∞–∑–∞–ª–æ: —Ç–µ—Å—Ç–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–ª–∏, —â–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –¥—Ä–æ–Ω –æ—Ç—Ä–∏–º—É—î –∫–æ–Ω–∫—Ä–µ—Ç–Ω–µ –∑–∞–≤–¥–∞–Ω–Ω—è.

–ü—Ä–æ–±–ª–µ–º–∞: –ø–æ—Ä—è–¥–æ–∫ –∫–ª—é—á—ñ–≤ —É HashMap –Ω–µ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–∏–π —ñ –º–æ–∂–µ –≤—ñ–¥—Ä—ñ–∑–Ω—è—Ç–∏—Å—è –º—ñ–∂ –∑–∞–ø—É—Å–∫–∞–º–∏! –ù–∞ –º–∞—à–∏–Ω—ñ —Ä–æ–∑—Ä–æ–±–Ω–∏–∫–∞ –≤–∏–ø–∞–¥–∫–æ–≤–æ –±—É–≤ –æ–¥–∏–Ω –ø–æ—Ä—è–¥–æ–∫, –Ω–∞ CI ‚Äî —ñ–Ω—à–∏–π. –¢–µ—Å—Ç–∏, —â–æ –ø–æ–∫–ª–∞–¥–∞–ª–∏—Å—å –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫, –±—É–ª–∏ –ø—Ä–∏—Ä–µ—á–µ–Ω—ñ –Ω–∞ –Ω–µ—Å—Ç–∞–±—ñ–ª—å–Ω—ñ—Å—Ç—å.

–©–µ –≥—ñ—Ä—à–µ: –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—ñ –ø–æ—Ä—è–¥–æ–∫ –º—ñ–≥ –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—å –ø—ñ—Å–ª—è –æ–Ω–æ–≤–ª–µ–Ω–Ω—è Rust, –ø—ñ—Å–ª—è –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫—É —Å–µ—Ä–≤—ñ—Å—É, –Ω–∞–≤—ñ—Ç—å –ø—ñ—Å–ª—è –∑–º—ñ–Ω–∏ –∫—ñ–ª—å–∫–æ—Å—Ç—ñ –¥—Ä–æ–Ω—ñ–≤. –°–∏—Å—Ç–µ–º–∞ "–≤–∏–ø–∞–¥–∫–æ–≤–æ" –ø—Ä–∏–∑–Ω–∞—á–∞–ª–∞ –∑–∞–≤–¥–∞–Ω–Ω—è, —ñ –Ω—ñ—Ö—Ç–æ –Ω–µ –º—ñ–≥ –ø–µ—Ä–µ–¥–±–∞—á–∏—Ç–∏, —è–∫–∏–π –¥—Ä–æ–Ω –æ—Ç—Ä–∏–º–∞—î —è–∫–µ –∑–∞–≤–¥–∞–Ω–Ω—è.

–†—ñ—à–µ–Ω–Ω—è –≤–∏–º–∞–≥–∞–ª–æ –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è BTreeMap (–¥–µ –∫–ª—é—á—ñ –≤–ø–æ—Ä—è–¥–∫–æ–≤–∞–Ω—ñ), –∞–±–æ —è–≤–Ω–æ–≥–æ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è –∫–ª—é—á—ñ–≤ –ø–µ—Ä–µ–¥ —ñ—Ç–µ—Ä–∞—Ü—ñ—î—é.

---

## –¢–ï–û–†–Ü–Ø: HASHMAP –Ü –ù–ï–î–ï–¢–ï–†–ú–Ü–ù–û–í–ê–ù–ò–ô –ü–û–†–Ø–î–û–ö

### –Ø–∫ –ø—Ä–∞—Ü—é—î HashMap

HashMap –∑–±–µ—Ä—ñ–≥–∞—î –ø–∞—Ä–∏ –∫–ª—é—á-–∑–Ω–∞—á–µ–Ω–Ω—è —É —Ö–µ—à-—Ç–∞–±–ª–∏—Ü—ñ. –ü—Ä–∏ –¥–æ–¥–∞–≤–∞–Ω–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∞ –æ–±—á–∏—Å–ª—é—î—Ç—å—Å—è —Ö–µ—à –∫–ª—é—á–∞, —ñ –µ–ª–µ–º–µ–Ω—Ç —Ä–æ–∑–º—ñ—â—É—î—Ç—å—Å—è —É "–≤—ñ–¥—Ä—ñ" (bucket), —â–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞—î —Ü—å–æ–º—É —Ö–µ—à—É.

–ü–µ—Ä–µ–≤–∞–≥–∏: –ø–æ—à—É–∫, –≤—Å—Ç–∞–≤–∫–∞ —Ç–∞ –≤–∏–¥–∞–ª–µ–Ω–Ω—è –º–∞—é—Ç—å –≤ —Å–µ—Ä–µ–¥–Ω—å–æ–º—É —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å O(1). –î–ª—è –≤–µ–ª–∏–∫–∏—Ö –∫–æ–ª–µ–∫—Ü—ñ–π —Ü–µ –∑–Ω–∞—á–Ω–æ —à–≤–∏–¥—à–µ –∑–∞ –ª—ñ–Ω—ñ–π–Ω–∏–π –ø–æ—à—É–∫.

–ê–ª–µ –ø–æ—Ä—è–¥–æ–∫ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è —Ö–µ—à-—Ñ—É–Ω–∫—Ü—ñ—î—é —Ç–∞ –≤–Ω—É—Ç—Ä—ñ—à–Ω—å–æ—é —Å—Ç—Ä—É–∫—Ç—É—Ä–æ—é —Ç–∞–±–ª–∏—Ü—ñ, –∞ –Ω–µ –ø–æ—Ä—è–¥–∫–æ–º –≤—Å—Ç–∞–≤–∫–∏. –ë—ñ–ª—å—à–µ —Ç–æ–≥–æ, Rust –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î —Ä–∞–Ω–¥–æ–º—ñ–∑–æ–≤–∞–Ω–∏–π —Ö–µ—à–µ—Ä (RandomState) –¥–ª—è –∑–∞—Ö–∏—Å—Ç—É –≤—ñ–¥ HashDoS-–∞—Ç–∞–∫. –¶–µ –æ–∑–Ω–∞—á–∞—î, —â–æ —Ö–µ—à-—Ñ—É–Ω–∫—Ü—ñ—è –º–æ–∂–µ –≤—ñ–¥—Ä—ñ–∑–Ω—è—Ç–∏—Å—è –º—ñ–∂ –∑–∞–ø—É—Å–∫–∞–º–∏ –ø—Ä–æ–≥—Ä–∞–º–∏.

### –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü—ñ—è –Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ—Å—Ç—ñ

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert("alpha", 1);
    map.insert("beta", 2);
    map.insert("gamma", 3);
    map.insert("delta", 4);
    
    // –ü–æ—Ä—è–¥–æ–∫ –º–æ–∂–µ –±—É—Ç–∏ –±—É–¥—å-—è–∫–∏–º!
    for (key, value) in &map {
        println!("{}: {}", key, value);
    }
}
```

–ó–∞–ø—É—Å—Ç—ñ—Ç—å —Ü—é –ø—Ä–æ–≥—Ä–∞–º—É –∫—ñ–ª—å–∫–∞ —Ä–∞–∑—ñ–≤. –ü–æ—Ä—è–¥–æ–∫ –≤–∏–≤–æ–¥—É –º–æ–∂–µ –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—å. –ù–∞ –æ–¥–Ω—ñ–π –º–∞—à–∏–Ω—ñ –≤–∏ –º–æ–∂–µ—Ç–µ –±–∞—á–∏—Ç–∏ "alpha, beta, gamma, delta", –Ω–∞ —ñ–Ω—à—ñ–π ‚Äî "gamma, alpha, delta, beta".

–í–∞–∂–ª–∏–≤–æ: —Ü–µ –Ω–µ –±–∞–≥, –∞ –Ω–∞–≤–º–∏—Å–Ω–∞ –ø–æ–≤–µ–¥—ñ–Ω–∫–∞. HashMap –æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–æ—Å—Ç—É–ø—É, –∞ –Ω–µ –¥–ª—è –∑–±–µ—Ä–µ–∂–µ–Ω–Ω—è –ø–æ—Ä—è–¥–∫—É.

### –ö–æ–ª–∏ —Ü–µ —Å—Ç–∞—î –ø—Ä–æ–±–ª–µ–º–æ—é

–ü—Ä–æ–±–ª–µ–º–∏ –≤–∏–Ω–∏–∫–∞—é—Ç—å, –∫–æ–ª–∏ –∫–æ–¥ –Ω–µ—è–≤–Ω–æ –ø–æ–∫–ª–∞–¥–∞—î—Ç—å—Å—è –Ω–∞ –ø–æ—Ä—è–¥–æ–∫:

**–¢–µ—Å—Ç–∏**: –ø–µ—Ä–µ–≤—ñ—Ä–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ—ó –ø–æ—Å–ª—ñ–¥–æ–≤–Ω–æ—Å—Ç—ñ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –±—É–¥–µ –Ω–µ—Å—Ç–∞–±—ñ–ª—å–Ω–æ—é.

**–°–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è**: JSON-–≤–∏–≤—ñ–¥ HashMap –º–∞—Ç–∏–º–µ —Ä—ñ–∑–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫ –ø–æ–ª—ñ–≤, —â–æ —É—Å–∫–ª–∞–¥–Ω—é—î –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è —Ñ–∞–π–ª—ñ–≤.

**–î–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω—ñ –∞–ª–≥–æ—Ä–∏—Ç–º–∏**: —è–∫—â–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø–æ—Ä—è–¥–∫—É –æ–±—Ä–æ–±–∫–∏, –≤—ñ–Ω –±—É–¥–µ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–∏–º.

**–î–µ–±–∞–≥**: –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º—É –∑–∞–ø—É—Å–∫—É –ø—Ä–æ–±–ª–µ–º–∞ –º–æ–∂–µ "–∑–Ω–∏–∫–Ω—É—Ç–∏", –±–æ –ø–æ—Ä—è–¥–æ–∫ –∑–º—ñ–Ω–∏–≤—Å—è.

### –†—ñ—à–µ–Ω–Ω—è: –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–µ–Ω –ø–æ—Ä—è–¥–æ–∫

**BTreeMap** –∑–±–µ—Ä—ñ–≥–∞—î –∫–ª—é—á—ñ —É –≤—ñ–¥—Å–æ—Ä—Ç–æ–≤–∞–Ω–æ–º—É –ø–æ—Ä—è–¥–∫—É:

```rust
use std::collections::BTreeMap;

let mut map = BTreeMap::new();
map.insert("alpha", 1);
map.insert("beta", 2);
map.insert("gamma", 3);

// –ó–∞–≤–∂–¥–∏: alpha, beta, gamma (–∞–ª—Ñ–∞–≤—ñ—Ç–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫)
for (key, value) in &map {
    println!("{}: {}", key, value);
}
```

–ö–æ–º–ø—Ä–æ–º—ñ—Å: BTreeMap –º–∞—î —Å–∫–ª–∞–¥–Ω—ñ—Å—Ç—å O(log n) –∑–∞–º—ñ—Å—Ç—å O(1).

**IndexMap** (–∫—Ä–µ–π—Ç `indexmap`) –∑–±–µ—Ä—ñ–≥–∞—î –ø–æ—Ä—è–¥–æ–∫ –≤—Å—Ç–∞–≤–∫–∏:

```rust
use indexmap::IndexMap;

let mut map = IndexMap::new();
map.insert("gamma", 3);
map.insert("alpha", 1);
map.insert("beta", 2);

// –ó–∞–≤–∂–¥–∏: gamma, alpha, beta (–ø–æ—Ä—è–¥–æ–∫ –≤—Å—Ç–∞–≤–∫–∏)
for (key, value) in &map {
    println!("{}: {}", key, value);
}
```

**–Ø–≤–Ω–µ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è** –ø–µ—Ä–µ–¥ —ñ—Ç–µ—Ä–∞—Ü—ñ—î—é:

```rust
let mut keys: Vec<_> = map.keys().collect();
keys.sort();
for key in keys {
    println!("{}: {}", key, map[key]);
}
```

---

## –¢–ï–û–†–Ü–Ø: –ü–ê–ù–Ü–ö–ê –ü–†–ò –Ü–ù–î–ï–ö–°–ê–¶–Ü–á

### Vec —Ç–∞ –º–µ–∂—ñ

–Ü–Ω–¥–µ–∫—Å–∞—Ü—ñ—è –≤–µ–∫—Ç–æ—Ä–∞ —á–µ—Ä–µ–∑ `[]` –ø–µ—Ä–µ–≤—ñ—Ä—è—î –º–µ–∂—ñ —ñ –ø–∞–Ω—ñ–∫—É—î –ø—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑–∞ –Ω–∏—Ö:

```rust
let vec = vec![1, 2, 3];
let x = vec[5];  // panic: index out of bounds: the len is 3 but the index is 5
```

–¶–µ runtime-–ø–µ—Ä–µ–≤—ñ—Ä–∫–∞, –Ω–µ compile-time. –ö–æ–º–ø—ñ–ª—è—Ç–æ—Ä –Ω–µ –∑–∞–≤–∂–¥–∏ –º–æ–∂–µ –∑–Ω–∞—Ç–∏, —á–∏ —ñ–Ω–¥–µ–∫—Å –≤–∞–ª—ñ–¥–Ω–∏–π.

### –ß–æ–º—É Rust –ø–∞–Ω—ñ–∫—É—î –∑–∞–º—ñ—Å—Ç—å undefined behavior

–£ C/C++ –¥–æ—Å—Ç—É–ø –∑–∞ –º–µ–∂–∞–º–∏ –º–∞—Å–∏–≤—É ‚Äî —Ü–µ undefined behavior. –ü—Ä–æ–≥—Ä–∞–º–∞ –º–æ–∂–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ —Å–º—ñ—Ç—Ç—è, –ø–æ—à–∫–æ–¥–∏—Ç–∏ –ø–∞–º'—è—Ç—å, –∞–±–æ –∑–¥–∞–≤–∞—Ç–∏—Å—å –ø—Ä–∞—Ü—é—é—á–æ—é, –ø–æ–∫–∏ –Ω–µ –≤–ø–∞–¥–µ —á–µ—Ä–µ–∑ –≥–æ–¥–∏–Ω—É –≤ –∑–æ–≤—Å—ñ–º —ñ–Ω—à–æ–º—É –º—ñ—Å—Ü—ñ.

Rust –æ–±—Ä–∞–≤ –ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω—É –ø–æ–≤–µ–¥—ñ–Ω–∫—É: —è–∫—â–æ —ñ–Ω–¥–µ–∫—Å –Ω–µ–≤–∞–ª—ñ–¥–Ω–∏–π, –ø—Ä–æ–≥—Ä–∞–º–∞ –æ–¥—Ä–∞–∑—É –∑–∞–≤–µ—Ä—à—É—î—Ç—å—Å—è –∑ —á—ñ—Ç–∫–∏–º –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º –ø—Ä–æ –ø–æ–º–∏–ª–∫—É. –¶–µ –±–µ–∑–ø–µ—á–Ω—ñ—à–µ, –±–æ –ø—Ä–æ–±–ª–µ–º–∞ –Ω–µ –º–∞—Å–∫—É—î—Ç—å—Å—è.

### –ë–µ–∑–ø–µ—á–Ω—ñ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∏

**–ú–µ—Ç–æ–¥ get()** –ø–æ–≤–µ—Ä—Ç–∞—î Option:

```rust
let vec = vec![1, 2, 3];

match vec.get(5) {
    Some(x) => println!("–ï–ª–µ–º–µ–Ω—Ç: {}", x),
    None => println!("–Ü–Ω–¥–µ–∫—Å –ø–æ–∑–∞ –º–µ–∂–∞–º–∏"),
}

// –ê–±–æ –∑ unwrap_or
let x = vec.get(5).unwrap_or(&0);  // –ü–æ–≤–µ—Ä—Ç–∞—î 0 —è–∫—â–æ —ñ–Ω–¥–µ–∫—Å –Ω–µ–≤–∞–ª—ñ–¥–Ω–∏–π
```

**–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –ø–µ—Ä–µ–¥ –¥–æ—Å—Ç—É–ø–æ–º**:

```rust
let index = 5;
if index < vec.len() {
    let x = vec[index];
}
```

**–Ü—Ç–µ—Ä–∞—Ü—ñ—è –∑–∞–º—ñ—Å—Ç—å —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó**:

```rust
// –ó–∞–º—ñ—Å—Ç—å
for i in 0..vec.len() {
    process(vec[i]);
}

// –ö—Ä–∞—â–µ
for item in &vec {
    process(item);
}
```

–Ü—Ç–µ—Ä–∞—Ü—ñ—è —á–µ—Ä–µ–∑ `for item in &vec` –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –Ω–µ –≤–∏–π–¥–µ –∑–∞ –º–µ–∂—ñ.

### HashMap —Ç–∞ –≤—ñ–¥—Å—É—Ç–Ω—ñ –∫–ª—é—á—ñ

–ê–Ω–∞–ª–æ–≥—ñ—á–Ω–æ, —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—è HashMap –ø–∞–Ω—ñ–∫—É—î –ø—Ä–∏ –≤—ñ–¥—Å—É—Ç–Ω—å–æ–º—É –∫–ª—é—á—ñ:

```rust
let mut map = HashMap::new();
map.insert("a", 1);

let x = map["b"];  // panic: no entry found for key
```

–ë–µ–∑–ø–µ—á–Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ ‚Äî –º–µ—Ç–æ–¥ get():

```rust
let x = map.get("b");  // None
let x = map.get("a");  // Some(&1)
```

---

## –¢–ï–û–†–Ü–Ø: –ü–£–°–¢–Ü –ö–û–õ–ï–ö–¶–Ü–á ‚Äî –î–ñ–ï–†–ï–õ–û –ü–ê–ù–Ü–ö–ò

### –¢–∏–ø–æ–≤—ñ –æ–ø–µ—Ä–∞—Ü—ñ—ó, —â–æ –ø–∞–Ω—ñ–∫—É—é—Ç—å –Ω–∞ –ø—É—Å—Ç–∏—Ö –∫–æ–ª–µ–∫—Ü—ñ—è—Ö

```rust
let empty: Vec<i32> = vec![];

empty[0];           // panic: index out of bounds
empty.first().unwrap();  // panic: called unwrap on None
empty.last().unwrap();   // panic: called unwrap on None

let mut empty_mut: Vec<i32> = vec![];
empty_mut.pop().unwrap();  // panic: called unwrap on None
empty_mut.remove(0);       // panic: removal index is out of bounds
```

### –ß–æ–º—É —Ü–µ —á–∞—Å—Ç–æ —Ç—Ä–∞–ø–ª—è—î—Ç—å—Å—è

–ü—É—Å—Ç—ñ –∫–æ–ª–µ–∫—Ü—ñ—ó –≤–∏–Ω–∏–∫–∞—é—Ç—å —É –Ω–µ–æ—á—ñ–∫—É–≤–∞–Ω–∏—Ö –º—ñ—Å—Ü—è—Ö:

**–§—ñ–ª—å—Ç—Ä–∞—Ü—ñ—è**: –ø—ñ—Å–ª—è `filter()` –º–æ–∂–µ –Ω–µ –∑–∞–ª–∏—à–∏—Ç–∏—Å—å –∂–æ–¥–Ω–æ–≥–æ –µ–ª–µ–º–µ–Ω—Ç–∞.

```rust
let numbers = vec![1, 2, 3, 4, 5];
let big: Vec<_> = numbers.into_iter().filter(|&x| x > 100).collect();
let first = big[0];  // panic! –ñ–æ–¥–µ–Ω –µ–ª–µ–º–µ–Ω—Ç –Ω–µ –±—ñ–ª—å—à–∏–π –∑–∞ 100
```

**–†–æ–∑–¥—ñ–ª–µ–Ω–Ω—è**: `split()` –º–æ–∂–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–∏ –ø—É—Å—Ç—ñ —á–∞—Å—Ç–∏–Ω–∏.

```rust
let text = "a,,b";
let parts: Vec<_> = text.split(',').collect();
// parts = ["a", "", "b"] ‚Äî —Å–µ—Ä–µ–¥–Ω—è —á–∞—Å—Ç–∏–Ω–∞ –ø—É—Å—Ç–∞!
```

**–ó–æ–≤–Ω—ñ—à–Ω—ñ –¥–∞–Ω—ñ**: —Ñ–∞–π–ª –º–æ–∂–µ –±—É—Ç–∏ –ø—É—Å—Ç–∏–º, –≤—ñ–¥–ø–æ–≤—ñ–¥—å —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî –±–µ–∑ –µ–ª–µ–º–µ–Ω—Ç—ñ–≤.

### –ó–∞—Ö–∏—Å–Ω—ñ –ø–∞—Ç–µ—Ä–Ω–∏

**–ü–µ—Ä–µ–≤—ñ—Ä–∫–∞ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É**:

```rust
if !vec.is_empty() {
    let first = vec[0];
}
```

**–í–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è Option-–º–µ—Ç–æ–¥—ñ–≤**:

```rust
// first() —Ç–∞ last() –ø–æ–≤–µ—Ä—Ç–∞—é—Ç—å Option
if let Some(first) = vec.first() {
    process(first);
}

// get() –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ—ó —ñ–Ω–¥–µ–∫—Å–∞—Ü—ñ—ó
if let Some(item) = vec.get(index) {
    process(item);
}
```

**–ó–Ω–∞—á–µ–Ω–Ω—è –∑–∞ –∑–∞–º–æ–≤—á—É–≤–∞–Ω–Ω—è–º**:

```rust
let first = vec.first().unwrap_or(&default_value);
let first = vec.first().copied().unwrap_or(0);  // –î–ª—è Copy-—Ç–∏–ø—ñ–≤
```

**–û–±—Ä–æ–±–∫–∞ —è–∫ –ø–æ–º–∏–ª–∫–∏**:

```rust
fn get_first(items: &[Item]) -> Result<&Item, Error> {
    items.first().ok_or(Error::EmptyCollection)
}
```

---

## –¢–ï–û–†–Ü–Ø: F64 –ù–ï –ú–û–ñ–ï –ë–£–¢–ò –ö–õ–Æ–ß–ï–ú HASHMAP

### –ü—Ä–æ–±–ª–µ–º–∞: –ø–æ—Ä—É—à–µ–Ω–Ω—è –∫–æ–Ω—Ç—Ä–∞–∫—Ç—É Hash —Ç–∞ Eq

HashMap –≤–∏–º–∞–≥–∞—î, —â–æ–± –∫–ª—é—á—ñ —Ä–µ–∞–ª—ñ–∑–æ–≤—É–≤–∞–ª–∏ —Ç—Ä–µ–π—Ç–∏ `Hash` —Ç–∞ `Eq`. –¶—ñ —Ç—Ä–µ–π—Ç–∏ –º–∞—é—Ç—å –≤–∞–∂–ª–∏–≤–∏–π –∫–æ–Ω—Ç—Ä–∞–∫—Ç: —è–∫—â–æ `a == b`, —Ç–æ `hash(a) == hash(b)`.

–ß–∏—Å–ª–∞ –∑ –ø–ª–∞–≤–∞—é—á–æ—é —Ç–æ—á–∫–æ—é (`f32`, `f64`) –Ω–µ —Ä–µ–∞–ª—ñ–∑—É—é—Ç—å `Eq` —á–µ—Ä–µ–∑ –æ—Å–æ–±–ª–∏–≤—ñ—Å—Ç—å NaN (Not a Number):

```rust
let nan = f64::NAN;
println!("{}", nan == nan);  // false! NaN –Ω–µ –¥–æ—Ä—ñ–≤–Ω—é—î —Å–∞–º–æ–º—É —Å–æ–±—ñ
```

–Ø–∫–±–∏ f64 —Ä–µ–∞–ª—ñ–∑–æ–≤—É–≤–∞–≤ Eq —ñ Hash, –≤–∏–Ω–∏–∫–ª–∞ –± –ø—Ä–æ–±–ª–µ–º–∞: –¥–≤–∞ NaN –º–∞–ª–∏ –± –æ–¥–Ω–∞–∫–æ–≤–∏–π —Ö–µ—à (–±–æ –±—ñ—Ç–æ–≤–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–Ω—è –æ–¥–Ω–∞–∫–æ–≤–µ), –∞–ª–µ –ø–æ—Ä—ñ–≤–Ω—é–≤–∞–ª–∏—Å—å —è–∫ –Ω–µ—Ä—ñ–≤–Ω—ñ. –¶–µ –ø–æ—Ä—É—à–∏–ª–æ –± —ñ–Ω–≤–∞—Ä—ñ–∞–Ω—Ç–∏ HashMap —ñ –ø—Ä–∏–∑–≤–µ–ª–æ –¥–æ –Ω–µ–ø–µ—Ä–µ–¥–±–∞—á—É–≤–∞–Ω–æ—ó –ø–æ–≤–µ–¥—ñ–Ω–∫–∏.

### –°–ø—Ä–æ–±–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ f64 —è–∫ –∫–ª—é—á

```rust
use std::collections::HashMap;

let mut map: HashMap<f64, String> = HashMap::new();  // –ü–û–ú–ò–õ–ö–ê –ö–û–ú–ü–Ü–õ–Ø–¶–Ü–á!
// error: the trait bound `f64: Eq` is not satisfied
// error: the trait bound `f64: Hash` is not satisfied
```

Rust –Ω–µ –¥–æ–∑–≤–æ–ª—è—î —Ü–µ –Ω–∞ —Ä—ñ–≤–Ω—ñ –∫–æ–º–ø—ñ–ª—è—Ç–æ—Ä–∞ ‚Äî –≤–∏ –ø—Ä–æ—Å—Ç–æ –Ω–µ –∑–º–æ–∂–µ—Ç–µ —Å—Ç–≤–æ—Ä–∏—Ç–∏ —Ç–∞–∫–∏–π HashMap.

### –†—ñ—à–µ–Ω–Ω—è 1: –û–±–≥–æ—Ä—Ç–∫–∞ –∑ –≥–∞—Ä–∞–Ω—Ç—ñ—è–º–∏

–ö—Ä–µ–π—Ç `ordered-float` –Ω–∞–¥–∞—î —Ç–∏–ø–∏ `OrderedFloat` —Ç–∞ `NotNan`:

```rust
use ordered_float::NotNan;
use std::collections::HashMap;

let mut map: HashMap<NotNan<f64>, String> = HashMap::new();

// NotNan –≥–∞—Ä–∞–Ω—Ç—É—î, —â–æ –∑–Ω–∞—á–µ–Ω–Ω—è –Ω–µ NaN
let key = NotNan::new(3.14).unwrap();  // –ü–∞–Ω—ñ–∫–∞ —è–∫—â–æ NaN
map.insert(key, "pi".to_string());
```

`NotNan` —Ä–µ–∞–ª—ñ–∑—É—î Eq —Ç–∞ Hash, –±–æ –≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–æ –Ω–µ –º—ñ—Å—Ç–∏—Ç—å NaN.

### –†—ñ—à–µ–Ω–Ω—è 2: –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—è –≤ —Ü—ñ–ª–µ —á–∏—Å–ª–æ

–Ø–∫—â–æ —Ç–æ—á–Ω—ñ—Å—Ç—å –æ–±–º–µ–∂–µ–Ω–∞, –º–æ–∂–Ω–∞ –∫–æ–Ω–≤–µ—Ä—Ç—É–≤–∞—Ç–∏:

```rust
fn float_to_key(f: f64) -> i64 {
    (f * 1000.0).round() as i64  // –¢—Ä–∏ –∑–Ω–∞–∫–∏ –ø—ñ—Å–ª—è –∫–æ–º–∏
}

let mut map: HashMap<i64, String> = HashMap::new();
map.insert(float_to_key(3.14159), "pi".to_string());
```

### –†—ñ—à–µ–Ω–Ω—è 3: BTreeMap –∑ PartialOrd (–Ω–µ —Ä–µ–∫–æ–º–µ–Ω–¥—É—î—Ç—å—Å—è)

BTreeMap –≤–∏–º–∞–≥–∞—î `Ord`, —è–∫–∏–π f64 —Ç–µ–∂ –Ω–µ —Ä–µ–∞–ª—ñ–∑—É—î. –ê–ª–µ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ –æ–±–≥–æ—Ä—Ç–∫—É –∑ `ordered-float`:

```rust
use ordered_float::OrderedFloat;
use std::collections::BTreeMap;

let mut map: BTreeMap<OrderedFloat<f64>, String> = BTreeMap::new();
map.insert(OrderedFloat(3.14), "pi".to_string());
```

### –ö–æ–ª–∏ —Ü–µ —Å—Ç–∞—î –ø—Ä–æ–±–ª–µ–º–æ—é –¥–ª—è –ë–ü–õ–ê

–£—è–≤—ñ–º–æ –∫–∞—Ä—Ç—É, –¥–µ –∫–ª—é—á ‚Äî –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏:

```rust
// –ù–ï –ü–†–ê–¶–Æ–Ñ!
struct Position { x: f64, y: f64 }
let mut map: HashMap<Position, DroneId> = HashMap::new();
```

–†—ñ—à–µ–Ω–Ω—è ‚Äî –∫–≤–∞–Ω—Ç—É–≤–∞—Ç–∏ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∏ –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ —Å–ø–µ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω—ñ –ø—Ä–æ—Å—Ç–æ—Ä–æ–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏ –¥–∞–Ω–∏—Ö (R-tree, –∫–≤–∞–¥—Ä–æ–¥–µ—Ä–µ–≤–∞).

---

## –¢–ï–û–†–Ü–Ø: CAPACITY VS LENGTH

### –©–æ —Ç–∞–∫–µ capacity

Vec —Ç–∞ HashMap –≤–∏–¥—ñ–ª—è—é—Ç—å –±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ, –Ω—ñ–∂ –ø–æ—Ç—Ä—ñ–±–Ω–æ –¥–ª—è –ø–æ—Ç–æ—á–Ω–∏—Ö –µ–ª–µ–º–µ–Ω—Ç—ñ–≤. –¶–µ –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—è: –∫–æ–ª–∏ –¥–æ–¥–∞—î—Ç—å—Å—è –Ω–æ–≤–∏–π –µ–ª–µ–º–µ–Ω—Ç, –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–æ —â–æ—Ä–∞–∑—É –ø–µ—Ä–µ–≤–∏–¥—ñ–ª—è—Ç–∏ –ø–∞–º'—è—Ç—å.

```rust
let mut vec = Vec::new();
println!("len: {}, capacity: {}", vec.len(), vec.capacity());
// len: 0, capacity: 0

vec.push(1);
println!("len: {}, capacity: {}", vec.len(), vec.capacity());
// len: 1, capacity: 4 (—Ç–∏–ø–æ–≤–æ, –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –∞–ª–æ–∫–∞—Ç–æ—Ä–∞)

vec.push(2);
vec.push(3);
vec.push(4);
println!("len: {}, capacity: {}", vec.len(), vec.capacity());
// len: 4, capacity: 4

vec.push(5);
println!("len: {}, capacity: {}", vec.len(), vec.capacity());
// len: 5, capacity: 8 (–ø–æ–¥–≤–æ—ó–ª–∞—Å—å!)
```

–ö–æ–ª–∏ length –¥–æ—Å—è–≥–∞—î capacity, –≤–µ–∫—Ç–æ—Ä –ø–µ—Ä–µ–≤–∏–¥—ñ–ª—è—î –ø–∞–º'—è—Ç—å (–∑–∞–∑–≤–∏—á–∞–π –ø–æ–¥–≤–æ—é—é—á–∏ capacity) —ñ –∫–æ–ø—ñ—é—î –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏.

### –ß–æ–º—É —Ü–µ –≤–∞–∂–ª–∏–≤–æ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ

–ü–µ—Ä–µ–≤–∏–¥—ñ–ª–µ–Ω–Ω—è ‚Äî –¥–æ—Ä–æ–≥–∞ –æ–ø–µ—Ä–∞—Ü—ñ—è. –Ø–∫—â–æ –≤–∏ –∑–Ω–∞—î—Ç–µ –ø—Ä–∏–±–ª–∏–∑–Ω—É –∫—ñ–ª—å–∫—ñ—Å—Ç—å –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å, —Å—Ç–≤–æ—Ä—ñ—Ç—å –∫–æ–ª–µ–∫—Ü—ñ—é –∑ –¥–æ—Å—Ç–∞—Ç–Ω—å–æ—é capacity:

```rust
// –ü–æ–≥–∞–Ω–æ: –±–∞–≥–∞—Ç–æ—Ä–∞–∑–æ–≤—ñ –ø–µ—Ä–µ–≤–∏–¥—ñ–ª–µ–Ω–Ω—è
let mut vec = Vec::new();
for i in 0..10000 {
    vec.push(i);  // ~14 –ø–µ—Ä–µ–≤–∏–¥—ñ–ª–µ–Ω—å
}

// –î–æ–±—Ä–µ: –æ–¥–Ω–µ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
let mut vec = Vec::with_capacity(10000);
for i in 0..10000 {
    vec.push(i);  // –ñ–æ–¥–Ω–∏—Ö –ø–µ—Ä–µ–≤–∏–¥—ñ–ª–µ–Ω—å
}
```

–î–ª—è HashMap –∞–Ω–∞–ª–æ–≥—ñ—á–Ω–æ:

```rust
let mut map = HashMap::with_capacity(1000);
```

### –ü–∞—Å—Ç–∫–∞: capacity –Ω–µ –∑–º–µ–Ω—à—É—î—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ

–ü—ñ—Å–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç—ñ–≤ capacity –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤–µ–ª–∏–∫–æ—é:

```rust
let mut vec = vec![0; 10000];
println!("–ü–µ—Ä–µ–¥: len={}, capacity={}", vec.len(), vec.capacity());
// len=10000, capacity=10000

vec.clear();
println!("–ü—ñ—Å–ª—è clear: len={}, capacity={}", vec.len(), vec.capacity());
// len=0, capacity=10000 ‚Äî –ø–∞–º'—è—Ç—å –≤—Å–µ —â–µ –≤–∏–¥—ñ–ª–µ–Ω–∞!
```

–Ø–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–≤—ñ–ª—å–Ω–∏—Ç–∏ –∑–∞–π–≤—É –ø–∞–º'—è—Ç—å:

```rust
vec.shrink_to_fit();  // –ó–º–µ–Ω—à—É—î capacity –¥–æ len
// –∞–±–æ
vec.shrink_to(100);   // –ó–º–µ–Ω—à—É—î capacity –¥–æ –º–∞–∫—Å–∏–º—É–º 100
```

### –ö–æ–ª–∏ —Ü–µ –∫—Ä–∏—Ç–∏—á–Ω–æ

–î–ª—è –ë–ü–õ–ê –∑ –æ–±–º–µ–∂–µ–Ω–æ—é –ø–∞–º'—è—Ç—Ç—é (–º—ñ–∫—Ä–æ–∫–æ–Ω—Ç—Ä–æ–ª–µ—Ä–∏) –∑–∞–π–≤–∞ capacity ‚Äî —Ü–µ –≤–∏—Ç—Ä–∞—Ç–∞ –¥–æ—Ä–æ–≥–æ—Ü—ñ–Ω–Ω–∏—Ö —Ä–µ—Å—É—Ä—Å—ñ–≤. –Ø–∫—â–æ –∫–æ–ª–µ–∫—Ü—ñ—è –ø–µ—Ä—ñ–æ–¥–∏—á–Ω–æ –∑—Ä–æ—Å—Ç–∞—î —ñ –∑–º–µ–Ω—à—É—î—Ç—å—Å—è, –ø–∞–º'—è—Ç—å –º–æ–∂–µ "–≤–∏—Ç—ñ–∫–∞—Ç–∏" —á–µ—Ä–µ–∑ –Ω–∞–∫–æ–ø–∏—á–µ–Ω–Ω—è –∑–∞–π–≤–æ—ó capacity.

---

## –¢–ï–û–†–Ü–Ø: ENTRY API –î–õ–Ø HASHMAP

### –ü—Ä–æ–±–ª–µ–º–∞: –ø–æ–¥–≤—ñ–π–Ω–∏–π –ø–æ—à—É–∫

–¢–∏–ø–æ–≤–∏–π –ø–∞—Ç–µ—Ä–Ω —Ä–æ–±–æ—Ç–∏ –∑ HashMap:

```rust
// –ü–æ–≥–∞–Ω–æ: –¥–≤–∞ –ø–æ—à—É–∫–∏ –ø–æ —Ö–µ—à—É
if !map.contains_key(&key) {
    map.insert(key, compute_value());
}
```

–¢—É—Ç –≤—ñ–¥–±—É–≤–∞—î—Ç—å—Å—è –¥–≤–∞ –ø–æ—à—É–∫–∏: `contains_key` —à—É–∫–∞—î –∫–ª—é—á, –ø–æ—Ç—ñ–º `insert` –∑–Ω–æ–≤—É —à—É–∫–∞—î –º—ñ—Å—Ü–µ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏. –¶–µ –Ω–µ–µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ.

### Entry API: –æ–¥–∏–Ω –ø–æ—à—É–∫

```rust
// –î–æ–±—Ä–µ: –æ–¥–∏–Ω –ø–æ—à—É–∫
map.entry(key).or_insert_with(|| compute_value());
```

Entry API –ø–æ–≤–µ—Ä—Ç–∞—î "—Ç–æ—á–∫—É –≤—Ö–æ–¥—É" ‚Äî –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –º—ñ—Å—Ü–µ, –¥–µ –∫–ª—é—á —î –∞–±–æ –º–∞—î –±—É—Ç–∏.

### –í–∞—Ä—ñ–∞–Ω—Ç–∏ Entry API

**or_insert**: –≤—Å—Ç–∞–≤–ª—è—î –∑–Ω–∞—á–µ–Ω–Ω—è, —è–∫—â–æ –∫–ª—é—á–∞ –Ω–µ–º–∞:

```rust
let count = map.entry("word").or_insert(0);
*count += 1;
```

**or_insert_with**: –≤–∏–∫–ª–∏–∫–∞—î —Ñ—É–Ω–∫—Ü—ñ—é –ª–∏—à–µ —è–∫—â–æ –ø–æ—Ç—Ä—ñ–±–Ω–∞ –≤—Å—Ç–∞–≤–∫–∞:

```rust
// compute_value() –≤–∏–∫–ª–∏–∫–∞—î—Ç—å—Å—è –ª–∏—à–µ —è–∫—â–æ –∫–ª—é—á–∞ –Ω–µ–º–∞
map.entry(key).or_insert_with(|| compute_value());
```

**or_default**: –≤—Å—Ç–∞–≤–ª—è—î Default::default():

```rust
let vec = map.entry(key).or_default();  // –ü—É—Å—Ç–∏–π Vec —è–∫—â–æ –∫–ª—é—á–∞ –Ω–µ–º–∞
vec.push(item);
```

**and_modify**: –º–æ–¥–∏—Ñ—ñ–∫—É—î —ñ—Å–Ω—É—é—á–µ –∑–Ω–∞—á–µ–Ω–Ω—è:

```rust
map.entry(key)
    .and_modify(|v| *v += 1)  // –Ø–∫—â–æ —î ‚Äî –∑–±—ñ–ª—å—à–∏—Ç–∏
    .or_insert(1);            // –Ø–∫—â–æ –Ω–µ–º–∞ ‚Äî –≤—Å—Ç–∞–≤–∏—Ç–∏ 1
```

### –ü—Ä–∏–∫–ª–∞–¥: –ø—ñ–¥—Ä–∞—Ö—É–Ω–æ–∫ —Å–ª—ñ–≤

```rust
use std::collections::HashMap;

fn count_words(text: &str) -> HashMap<&str, u32> {
    let mut counts = HashMap::new();
    
    for word in text.split_whitespace() {
        *counts.entry(word).or_insert(0) += 1;
    }
    
    counts
}
```

–ö–æ–∂–Ω–µ —Å–ª–æ–≤–æ —à—É–∫–∞—î—Ç—å—Å—è –ª–∏—à–µ –æ–¥–∏–Ω —Ä–∞–∑. Entry –∞–±–æ –ø–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —ñ—Å–Ω—É—é—á–∏–π –ª—ñ—á–∏–ª—å–Ω–∏–∫, –∞–±–æ –≤—Å—Ç–∞–≤–ª—è—î 0 —ñ –ø–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –Ω—å–æ–≥–æ.

---

## –¢–ï–û–†–Ü–Ø: ITER(), ITER_MUT(), INTO_ITER()

### –¢—Ä–∏ —Å–ø–æ—Å–æ–±–∏ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó

Rust –º–∞—î —Ç—Ä–∏ –º–µ—Ç–æ–¥–∏ –¥–ª—è —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è —ñ—Ç–µ—Ä–∞—Ç–æ—Ä—ñ–≤ –∑ –∫–æ–ª–µ–∫—Ü—ñ–π, —ñ –≤–æ–Ω–∏ –ø—Ä–∏–Ω—Ü–∏–ø–æ–≤–æ —Ä—ñ–∑–Ω—ñ:

**iter()** ‚Äî –ø–æ–∑–∏—á–∞—î –∫–æ–ª–µ–∫—Ü—ñ—é —ñ–º–º—É—Ç–∞–±–µ–ª—å–Ω–æ, –ø–æ–≤–µ—Ä—Ç–∞—î –ø–æ—Å–∏–ª–∞–Ω–Ω—è:

```rust
let vec = vec![1, 2, 3];
for item in vec.iter() {  // item: &i32
    println!("{}", item);
}
// vec –≤—Å–µ —â–µ –¥–æ—Å—Ç—É–ø–Ω–∏–π
println!("{:?}", vec);
```

**iter_mut()** ‚Äî –ø–æ–∑–∏—á–∞—î –∫–æ–ª–µ–∫—Ü—ñ—é –º—É—Ç–∞–±–µ–ª—å–Ω–æ, –¥–æ–∑–≤–æ–ª—è—î –∑–º—ñ–Ω—é–≤–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–∏:

```rust
let mut vec = vec![1, 2, 3];
for item in vec.iter_mut() {  // item: &mut i32
    *item *= 2;
}
// vec = [2, 4, 6]
```

**into_iter()** ‚Äî —Å–ø–æ–∂–∏–≤–∞—î –∫–æ–ª–µ–∫—Ü—ñ—é, –ø–µ—Ä–µ–º—ñ—â—É—î –µ–ª–µ–º–µ–Ω—Ç–∏:

```rust
let vec = vec![1, 2, 3];
for item in vec.into_iter() {  // item: i32 (–≤–æ–ª–æ–¥—ñ–Ω–Ω—è!)
    println!("{}", item);
}
// vec –±—ñ–ª—å—à–µ –Ω–µ —ñ—Å–Ω—É—î!
```

### –°–∫–æ—Ä–æ—á–µ–Ω–∏–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —É for

–¶–∏–∫–ª `for` –∞–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –≤–∏–∫–ª–∏–∫–∞—î IntoIterator:

```rust
for item in &vec { }      // –ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ vec.iter()
for item in &mut vec { }  // –ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ vec.iter_mut()
for item in vec { }       // –ï–∫–≤—ñ–≤–∞–ª–µ–Ω—Ç–Ω–æ vec.into_iter()
```

### –ü–∞—Å—Ç–∫–∞: –≤–∏–ø–∞–¥–∫–æ–≤–µ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –∫–æ–ª–µ–∫—Ü—ñ—ó

```rust
let vec = vec![1, 2, 3];

// –•–æ—Ç—ñ–ª–∏ –ø—Ä–æ—Å—Ç–æ –Ω–∞–¥—Ä—É–∫—É–≤–∞—Ç–∏, –∞ —Å–ø–æ–∂–∏–≤–ª–∏!
for item in vec {
    println!("{}", item);
}

// println!("{:?}", vec);  // –ü–û–ú–ò–õ–ö–ê: vec –ø–µ—Ä–µ–º—ñ—â–µ–Ω–æ
```

–†—ñ—à–µ–Ω–Ω—è ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –ø–æ—Å–∏–ª–∞–Ω–Ω—è:

```rust
for item in &vec {  // –ü–æ–∑–∏—á–∞—î–º–æ, –Ω–µ —Å–ø–æ–∂–∏–≤–∞—î–º–æ
    println!("{}", item);
}
println!("{:?}", vec);  // OK
```

### –ö–æ–ª–∏ —â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏

**iter()**: –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –ª–∏—à–µ –ø—Ä–æ—á–∏—Ç–∞—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–∏, –∞ –∫–æ–ª–µ–∫—Ü—ñ—è —â–µ –∑–Ω–∞–¥–æ–±–∏—Ç—å—Å—è.

**iter_mut()**: –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –∑–º—ñ–Ω–∏—Ç–∏ –µ–ª–µ–º–µ–Ω—Ç–∏ –Ω–∞ –º—ñ—Å—Ü—ñ.

**into_iter()**: –∫–æ–ª–∏ –∫–æ–ª–µ–∫—Ü—ñ—è –±—ñ–ª—å—à–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–∞, –∞–±–æ –∫–æ–ª–∏ –ø–æ—Ç—Ä—ñ–±–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç–∏ –≤–æ–ª–æ–¥—ñ–Ω–Ω—è –µ–ª–µ–º–µ–Ω—Ç–∞–º–∏.

---

## –¢–ï–û–†–Ü–Ø: DRAIN ‚Äî –ß–ê–°–¢–ö–û–í–ï –°–ü–û–ñ–ò–í–ê–ù–ù–Ø

### –†—ñ–∑–Ω–∏—Ü—è –º—ñ–∂ clear(), drain(), into_iter()

**clear()** ‚Äî –≤–∏–¥–∞–ª—è—î –≤—Å—ñ –µ–ª–µ–º–µ–Ω—Ç–∏, –∞–ª–µ –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î —ó—Ö:

```rust
let mut vec = vec![1, 2, 3];
vec.clear();
// –ï–ª–µ–º–µ–Ω—Ç–∏ –∑–Ω–∏—â–µ–Ω—ñ, vec –ø—É—Å—Ç–∏–π
```

**into_iter()** ‚Äî —Å–ø–æ–∂–∏–≤–∞—î –∫–æ–ª–µ–∫—Ü—ñ—é, –ø–æ–≤–µ—Ä—Ç–∞—î –µ–ª–µ–º–µ–Ω—Ç–∏:

```rust
let vec = vec![1, 2, 3];
let elements: Vec<_> = vec.into_iter().collect();
// vec –±—ñ–ª—å—à–µ –Ω–µ —ñ—Å–Ω—É—î
```

**drain()** ‚Äî –≤–∏–¥–∞–ª—è—î –µ–ª–µ–º–µ–Ω—Ç–∏, –ø–æ–≤–µ—Ä—Ç–∞—î —ó—Ö, –∫–æ–ª–µ–∫—Ü—ñ—è –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è (–ø—É—Å—Ç–∞):

```rust
let mut vec = vec![1, 2, 3, 4, 5];
let removed: Vec<_> = vec.drain(1..4).collect();
// removed = [2, 3, 4]
// vec = [1, 5] ‚Äî –∑–∞–ª–∏—à–∏–≤—Å—è!
```

### –ü–µ—Ä–µ–≤–∞–≥–∏ drain()

–ú–æ–∂–Ω–∞ –≤–∏–¥–∞–ª–∏—Ç–∏ –ª–∏—à–µ —á–∞—Å—Ç–∏–Ω—É –µ–ª–µ–º–µ–Ω—Ç—ñ–≤:

```rust
let mut vec = vec![1, 2, 3, 4, 5];

// –í–∏–¥–∞–ª–∏—Ç–∏ –ø–µ—Ä—à—ñ –¥–≤–∞
let first_two: Vec<_> = vec.drain(..2).collect();
// first_two = [1, 2], vec = [3, 4, 5]
```

–ö–æ–ª–µ–∫—Ü—ñ—è –∑–∞–ª–∏—à–∞—î—Ç—å—Å—è –≤–∞–ª—ñ–¥–Ω–æ—é –¥–ª—è –ø–æ–¥–∞–ª—å—à–æ–≥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è:

```rust
let mut vec = vec![1, 2, 3];
for item in vec.drain(..) {
    process(item);
}
// vec –ø—É—Å—Ç–∏–π, –∞–ª–µ —ñ—Å–Ω—É—î
vec.push(4);  // –ú–æ–∂–Ω–∞ –ø—Ä–æ–¥–æ–≤–∂—É–≤–∞—Ç–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏
```

### drain_filter (nightly) / retain

–î–ª—è –≤–∏–¥–∞–ª–µ–Ω–Ω—è –∑–∞ —É–º–æ–≤–æ—é:

```rust
let mut vec = vec![1, 2, 3, 4, 5, 6];
vec.retain(|&x| x % 2 == 0);
// vec = [2, 4, 6] ‚Äî –∑–∞–ª–∏—à–∏–ª–∏—Å—å –ª–∏—à–µ –ø–∞—Ä–Ω—ñ
```

`retain` –Ω–µ –ø–æ–≤–µ—Ä—Ç–∞—î –≤–∏–¥–∞–ª–µ–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏. –î–ª—è —Ü—å–æ–≥–æ –≤ nightly —î `drain_filter`, –∞–±–æ –º–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞—Ç–∏ partition:

```rust
let vec = vec![1, 2, 3, 4, 5, 6];
let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&x| x % 2 == 0);
// even = [2, 4, 6], odd = [1, 3, 5]
```

---

## –¢–ï–û–†–Ü–Ø: HASHSET –¢–ê –û–ü–ï–†–ê–¶–Ü–á –ù–ê–î –ú–ù–û–ñ–ò–ù–ê–ú–ò

### –ö–æ–ª–∏ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ HashSet

HashSet ‚Äî —Ü–µ HashMap –±–µ–∑ –∑–Ω–∞—á–µ–Ω—å, –ª–∏—à–µ –∫–ª—é—á—ñ. –ö–æ—Ä–∏—Å–Ω–∏–π –¥–ª—è:

- –ü–µ—Ä–µ–≤—ñ—Ä–∫–∏ –Ω–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ: O(1) –∑–∞–º—ñ—Å—Ç—å O(n) –¥–ª—è Vec
- –í–∏–¥–∞–ª–µ–Ω–Ω—è –¥—É–±–ª—ñ–∫–∞—Ç—ñ–≤
- –¢–µ–æ—Ä–µ—Ç–∏–∫–æ-–º–Ω–æ–∂–∏–Ω–Ω–∏—Ö –æ–ø–µ—Ä–∞—Ü—ñ–π (–æ–±'—î–¥–Ω–∞–Ω–Ω—è, –ø–µ—Ä–µ—Ç–∏–Ω)

```rust
use std::collections::HashSet;

let mut visited = HashSet::new();
visited.insert("node_a");
visited.insert("node_b");

if visited.contains(&"node_c") {
    println!("–í–∂–µ –≤—ñ–¥–≤—ñ–¥—É–≤–∞–ª–∏");
} else {
    println!("–ù–æ–≤–∏–π –≤—É–∑–æ–ª");
}
```

### –û–ø–µ—Ä–∞—Ü—ñ—ó –Ω–∞–¥ –º–Ω–æ–∂–∏–Ω–∞–º–∏

```rust
let a: HashSet<_> = [1, 2, 3].iter().cloned().collect();
let b: HashSet<_> = [2, 3, 4].iter().cloned().collect();

// –û–±'—î–¥–Ω–∞–Ω–Ω—è: –µ–ª–µ–º–µ–Ω—Ç–∏, —â–æ —î —Ö–æ—á–∞ –± –≤ –æ–¥–Ω—ñ–π –º–Ω–æ–∂–∏–Ω—ñ
let union: HashSet<_> = a.union(&b).cloned().collect();
// {1, 2, 3, 4}

// –ü–µ—Ä–µ—Ç–∏–Ω: –µ–ª–µ–º–µ–Ω—Ç–∏, —â–æ —î –≤ –æ–±–æ—Ö –º–Ω–æ–∂–∏–Ω–∞—Ö
let intersection: HashSet<_> = a.intersection(&b).cloned().collect();
// {2, 3}

// –†—ñ–∑–Ω–∏—Ü—è: –µ–ª–µ–º–µ–Ω—Ç–∏ a, —è–∫–∏—Ö –Ω–µ–º–∞ –≤ b
let difference: HashSet<_> = a.difference(&b).cloned().collect();
// {1}

// –°–∏–º–µ—Ç—Ä–∏—á–Ω–∞ —Ä—ñ–∑–Ω–∏—Ü—è: –µ–ª–µ–º–µ–Ω—Ç–∏, —â–æ —î –ª–∏—à–µ –≤ –æ–¥–Ω—ñ–π –º–Ω–æ–∂–∏–Ω—ñ
let symmetric: HashSet<_> = a.symmetric_difference(&b).cloned().collect();
// {1, 4}
```

### –ü–∞—Å—Ç–∫–∞: –ø–æ—Ä—è–¥–æ–∫ —É HashSet —Ç–µ–∂ –Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–π

–Ø–∫ —ñ HashMap, HashSet –Ω–µ –≥–∞—Ä–∞–Ω—Ç—É—î –ø–æ—Ä—è–¥–æ–∫ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó. –Ø–∫—â–æ –ø–æ—Ç—Ä—ñ–±–µ–Ω –ø–æ—Ä—è–¥–æ–∫ ‚Äî –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ BTreeSet.

---

## –ü–†–ê–ö–¢–ò–ß–ù–Ü –†–ï–ö–û–ú–ï–ù–î–ê–¶–Ü–á

### –ü—Ä–∞–≤–∏–ª–æ 1: –ù–µ –ø–æ–∫–ª–∞–¥–∞–π—Ç–µ—Å—å –Ω–∞ –ø–æ—Ä—è–¥–æ–∫ HashMap/HashSet

```rust
// –ü–æ–≥–∞–Ω–æ: —Ç–µ—Å—Ç –∑–∞–ª–µ–∂–∏—Ç—å –≤—ñ–¥ –ø–æ—Ä—è–¥–∫—É
let keys: Vec<_> = map.keys().collect();
assert_eq!(keys, vec!["a", "b", "c"]);

// –î–æ–±—Ä–µ: –ø–æ—Ä—ñ–≤–Ω—é–π—Ç–µ –º–Ω–æ–∂–∏–Ω–∏ –∞–±–æ —Å–æ—Ä—Ç—É–π—Ç–µ
let keys: HashSet<_> = map.keys().collect();
assert_eq!(keys, ["a", "b", "c"].iter().collect());
```

### –ü—Ä–∞–≤–∏–ª–æ 2: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ get() –∑–∞–º—ñ—Å—Ç—å []

```rust
// –ü–æ–≥–∞–Ω–æ: –º–æ–∂–µ –ø–∞–Ω—ñ–∫—É–≤–∞—Ç–∏
let value = vec[index];
let value = map[&key];

// –î–æ–±—Ä–µ: –±–µ–∑–ø–µ—á–Ω–∏–π –¥–æ—Å—Ç—É–ø
if let Some(value) = vec.get(index) { ... }
if let Some(value) = map.get(&key) { ... }
```

### –ü—Ä–∞–≤–∏–ª–æ 3: –ü–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ –Ω–∞ –ø—É—Å—Ç–æ—Ç—É

```rust
// –ü–æ–≥–∞–Ω–æ: –ø–∞–Ω—ñ–∫–∞ –Ω–∞ –ø—É—Å—Ç—ñ–π –∫–æ–ª–µ–∫—Ü—ñ—ó
let first = items.first().unwrap();

// –î–æ–±—Ä–µ: –æ–±—Ä–æ–±–∫–∞ –ø—É—Å—Ç–æ—ó –∫–æ–ª–µ–∫—Ü—ñ—ó
let first = items.first().ok_or(Error::EmptyCollection)?;
```

### –ü—Ä–∞–≤–∏–ª–æ 4: –í–∏–¥—ñ–ª—è–π—Ç–µ capacity –∑–∞–∑–¥–∞–ª–µ–≥—ñ–¥—å

```rust
// –ü–æ–≥–∞–Ω–æ: –±–∞–≥–∞—Ç–æ—Ä–∞–∑–æ–≤—ñ –ø–µ—Ä–µ–≤–∏–¥—ñ–ª–µ–Ω–Ω—è
let mut results = Vec::new();
for item in large_collection {
    results.push(process(item));
}

// –î–æ–±—Ä–µ: –æ–¥–Ω–µ –≤–∏–¥—ñ–ª–µ–Ω–Ω—è
let mut results = Vec::with_capacity(large_collection.len());
for item in large_collection {
    results.push(process(item));
}
```

### –ü—Ä–∞–≤–∏–ª–æ 5: –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Entry API –¥–ª—è HashMap

```rust
// –ü–æ–≥–∞–Ω–æ: –ø–æ–¥–≤—ñ–π–Ω–∏–π –ø–æ—à—É–∫
if !map.contains_key(&key) {
    map.insert(key, value);
}

// –î–æ–±—Ä–µ: –æ–¥–∏–Ω –ø–æ—à—É–∫
map.entry(key).or_insert(value);
```

### –ü—Ä–∞–≤–∏–ª–æ 6: –†–æ–∑—Ä—ñ–∑–Ω—è–π—Ç–µ iter(), iter_mut(), into_iter()

```rust
// –ß–∏—Ç–∞–Ω–Ω—è –±–µ–∑ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è
for item in &vec { ... }

// –ú–æ–¥–∏—Ñ—ñ–∫–∞—Ü—ñ—è –Ω–∞ –º—ñ—Å—Ü—ñ
for item in &mut vec { *item += 1; }

// –°–ø–æ–∂–∏–≤–∞–Ω–Ω—è (–∫–æ–ª–µ–∫—Ü—ñ—è –±—ñ–ª—å—à–µ –Ω–µ –ø–æ—Ç—Ä—ñ–±–Ω–∞)
for item in vec { consume(item); }
```

---

## –ó–∞—Å—Ç–æ—Å—É–≤–∞–Ω–Ω—è –¥–æ —Ä–æ—é –ë–ü–õ–ê

### –†–µ—î—Å—Ç—Ä –∞–≥–µ–Ω—Ç—ñ–≤ –∑ –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–º –ø–æ—Ä—è–¥–∫–æ–º

```rust
use std::collections::BTreeMap;

struct DroneRegistry {
    // BTreeMap –≥–∞—Ä–∞–Ω—Ç—É—î –ø–æ—Ä—è–¥–æ–∫ –∑–∞ DroneId
    drones: BTreeMap<DroneId, DroneInfo>,
}

impl DroneRegistry {
    fn assign_tasks_round_robin(&self, tasks: &[Task]) -> Vec<(DroneId, Task)> {
        let drone_ids: Vec<_> = self.drones.keys().cloned().collect();
        
        if drone_ids.is_empty() {
            return vec![];
        }
        
        tasks.iter()
            .enumerate()
            .map(|(i, task)| {
                let drone_id = drone_ids[i % drone_ids.len()].clone();
                (drone_id, task.clone())
            })
            .collect()
    }
}
```

### –ö–∞—Ä—Ç–∞ –ø–µ—Ä–µ—à–∫–æ–¥ –∑ –±–µ–∑–ø–µ—á–Ω–∏–º –¥–æ—Å—Ç—É–ø–æ–º

```rust
use std::collections::HashMap;

struct ObstacleMap {
    grid: HashMap<(i32, i32), Obstacle>,
}

impl ObstacleMap {
    fn is_blocked(&self, x: i32, y: i32) -> bool {
        // –ë–µ–∑–ø–µ—á–Ω–∏–π –¥–æ—Å—Ç—É–ø —á–µ—Ä–µ–∑ get()
        self.grid.get(&(x, y)).is_some()
    }
    
    fn get_obstacle(&self, x: i32, y: i32) -> Option<&Obstacle> {
        self.grid.get(&(x, y))
    }
    
    fn add_obstacle(&mut self, x: i32, y: i32, obstacle: Obstacle) {
        // Entry API –¥–ª—è —É–Ω–∏–∫–Ω–µ–Ω–Ω—è –ø–µ—Ä–µ–∑–∞–ø–∏—Å—É
        self.grid.entry((x, y)).or_insert(obstacle);
    }
    
    fn remove_obstacle(&mut self, x: i32, y: i32) -> Option<Obstacle> {
        self.grid.remove(&(x, y))
    }
}
```

### –ß–µ—Ä–≥–∞ –∫–æ–º–∞–Ω–¥ –∑ –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–æ–º

```rust
use std::collections::BinaryHeap;

#[derive(Eq, PartialEq, Ord, PartialOrd)]
struct PrioritizedCommand {
    priority: u8,  // –í–∏—â–∏–π = –≤–∞–∂–ª–∏–≤—ñ—à–∏–π
    timestamp: u64,
    command: Command,
}

struct CommandQueue {
    heap: BinaryHeap<PrioritizedCommand>,
    capacity: usize,
}

impl CommandQueue {
    fn new(capacity: usize) -> Self {
        Self {
            heap: BinaryHeap::with_capacity(capacity),
            capacity,
        }
    }
    
    fn push(&mut self, cmd: PrioritizedCommand) -> Result<(), QueueError> {
        if self.heap.len() >= self.capacity {
            // –ß–µ—Ä–≥–∞ –ø–æ–≤–Ω–∞ ‚Äî –≤–∏–¥–∞–ª—è—î–º–æ –Ω–∞–π–º–µ–Ω—à –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–Ω–∏–π
            // (BinaryHeap ‚Äî max-heap, —Ç–æ–º—É —Ü–µ —Å–∫–ª–∞–¥–Ω—ñ—à–µ)
            return Err(QueueError::Full);
        }
        self.heap.push(cmd);
        Ok(())
    }
    
    fn pop(&mut self) -> Option<PrioritizedCommand> {
        self.heap.pop()  // –ü–æ–≤–µ—Ä—Ç–∞—î –Ω–∞–π–ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç–Ω—ñ—à–∏–π
    }
}
```

### –í—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –≤—ñ–¥–≤—ñ–¥–∞–Ω–∏—Ö –ø–æ–∑–∏—Ü—ñ–π

```rust
use std::collections::HashSet;

struct PathTracker {
    visited: HashSet<(i32, i32)>,
}

impl PathTracker {
    fn new() -> Self {
        Self { visited: HashSet::new() }
    }
    
    fn visit(&mut self, x: i32, y: i32) -> bool {
        // insert –ø–æ–≤–µ—Ä—Ç–∞—î true —è–∫—â–æ –µ–ª–µ–º–µ–Ω—Ç –±—É–≤ –Ω–æ–≤–∏–º
        self.visited.insert((x, y))
    }
    
    fn has_visited(&self, x: i32, y: i32) -> bool {
        self.visited.contains(&(x, y))
    }
    
    fn visited_count(&self) -> usize {
        self.visited.len()
    }
    
    fn clear(&mut self) {
        self.visited.clear();
    }
}
```

---

## –†–µ–∑—é–º–µ

–£ —Ü—å–æ–º—É —Ä–æ–∑–¥—ñ–ª—ñ –º–∏ —Ä–æ–∑–≥–ª—è–Ω—É–ª–∏ –ø—ñ–¥—Å—Ç—É–ø–Ω—ñ –∞—Å–ø–µ–∫—Ç–∏ —Ä–æ–±–æ—Ç–∏ –∑ –∫–æ–ª–µ–∫—Ü—ñ—è–º–∏.

**–ü–æ—Ä—è–¥–æ–∫ —É HashMap/HashSet –Ω–µ–¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–∏–π** ‚Äî –≤—ñ–Ω –º–æ–∂–µ –∑–º—ñ–Ω—é–≤–∞—Ç–∏—Å—å –º—ñ–∂ –∑–∞–ø—É—Å–∫–∞–º–∏. –î–ª—è –¥–µ—Ç–µ—Ä–º—ñ–Ω–æ–≤–∞–Ω–æ—Å—Ç—ñ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ BTreeMap/BTreeSet –∞–±–æ —è–≤–Ω–µ —Å–æ—Ä—Ç—É–≤–∞–Ω–Ω—è.

**–Ü–Ω–¥–µ–∫—Å–∞—Ü—ñ—è [] –ø–∞–Ω—ñ–∫—É—î** –ø—Ä–∏ –≤–∏—Ö–æ–¥—ñ –∑–∞ –º–µ–∂—ñ –∞–±–æ –≤—ñ–¥—Å—É—Ç–Ω—å–æ–º—É –∫–ª—é—á—ñ. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ get() –¥–ª—è –±–µ–∑–ø–µ—á–Ω–æ–≥–æ –¥–æ—Å—Ç—É–ø—É.

**–ü—É—Å—Ç—ñ –∫–æ–ª–µ–∫—Ü—ñ—ó** ‚Äî —á–∞—Å—Ç–µ –¥–∂–µ—Ä–µ–ª–æ –ø–∞–Ω—ñ–∫–∏. –ó–∞–≤–∂–¥–∏ –ø–µ—Ä–µ–≤—ñ—Ä—è–π—Ç–µ is_empty() –∞–±–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ Option-–º–µ—Ç–æ–¥–∏ (first(), get()).

**f64 –Ω–µ –º–æ–∂–µ –±—É—Ç–∏ –∫–ª—é—á–µ–º HashMap** —á–µ—Ä–µ–∑ NaN. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ –æ–±–≥–æ—Ä—Ç–∫–∏ (ordered-float) –∞–±–æ –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü—ñ—é –≤ —Ü—ñ–ª—ñ —á–∏—Å–ª–∞.

**Capacity vs length**: –∫–æ–ª–µ–∫—Ü—ñ—ó –≤–∏–¥—ñ–ª—è—é—Ç—å –±—ñ–ª—å—à–µ –ø–∞–º'—è—Ç—ñ, –Ω—ñ–∂ –ø–æ—Ç—Ä—ñ–±–Ω–æ. –î–ª—è –æ–ø—Ç–∏–º—ñ–∑–∞—Ü—ñ—ó –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–π—Ç–µ with_capacity(), –¥–ª—è –∑–≤—ñ–ª—å–Ω–µ–Ω–Ω—è ‚Äî shrink_to_fit().

**Entry API** –¥–æ–∑–≤–æ–ª—è—î –µ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø—Ä–∞—Ü—é–≤–∞—Ç–∏ –∑ HashMap, —É–Ω–∏–∫–∞—é—á–∏ –ø–æ–¥–≤—ñ–π–Ω–æ–≥–æ –ø–æ—à—É–∫—É.

**iter(), iter_mut(), into_iter()** ‚Äî —Ç—Ä–∏ —Ä—ñ–∑–Ω–∏—Ö —Å–ø–æ—Å–æ–±–∏ —ñ—Ç–µ—Ä–∞—Ü—ñ—ó –∑ —Ä—ñ–∑–Ω–æ—é —Å–µ–º–∞–Ω—Ç–∏–∫–æ—é –≤–æ–ª–æ–¥—ñ–Ω–Ω—è. –ü–æ–º–∏–ª–∫–∞ —É –≤–∏–±–æ—Ä—ñ –º–æ–∂–µ –ø—Ä–∏–∑–≤–µ—Å—Ç–∏ –¥–æ –Ω–µ—Å–ø–æ–¥—ñ–≤–∞–Ω–æ–≥–æ —Å–ø–æ–∂–∏–≤–∞–Ω–Ω—è –∫–æ–ª–µ–∫—Ü—ñ—ó.

---

## üîó –ó–≤'—è–∑–æ–∫ –∑ –Ω–∞—Å—Ç—É–ø–Ω–∏–º –º–∞—Ç–µ—Ä—ñ–∞–ª–æ–º

–û–ø–∞–Ω—É–≤–∞–≤—à–∏ –ø—ñ–¥—Å—Ç—É–ø–Ω–æ—Å—Ç—ñ –∫–æ–ª–µ–∫—Ü—ñ–π, –≤–∏ –≥–æ—Ç–æ–≤—ñ –¥–æ –≤–∏–≤—á–µ–Ω–Ω—è –ø—Ä–æ–±–ª–µ–º –∑ —á–∞—Å–æ–º —Ç–∞ –¥–∞—Ç–∞–º–∏. –¢–∞–º –≤–∞—Å —á–µ–∫–∞—é—Ç—å —á–∞—Å–æ–≤—ñ –∑–æ–Ω–∏, –ª—ñ—Ç–Ω—ñ–π —á–∞—Å, —â–æ "–∑'—ó–¥–∞—î" –≥–æ–¥–∏–Ω—É, —Ç–∞ –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–∞ –¥–∞—Ç, –¥–µ "31 —Å—ñ—á–Ω—è + 1 –º—ñ—Å—è—Ü—å" –Ω–µ –º–∞—î –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—ó –≤—ñ–¥–ø–æ–≤—ñ–¥—ñ.
