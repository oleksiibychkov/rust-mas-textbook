# Розділ 6: Практикум — Агент-патрульний на сітці

---

## 📋 Анотація

Ласкаво просимо до фінального розділу Частини 0! Ви пройшли довгий шлях: від першого "Hello, Agent!" через змінні, функції, керування потоком до масивів та кортежів. Тепер час об'єднати всі ці знання в єдиний працюючий проєкт.

У цьому розділі ви створите текстову симуляцію агента, що патрулює прямокутну сітку. Це не просто вправа — це ваш перший справжній автономний агент. Ми будемо будувати його покроково, пояснюючи кожне рішення.

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Інтегрувати** всі концепції з Розділів 1-5 у єдиний проєкт
2. **Моделювати** простір як 2D сітку з координатами
3. **Реалізувати** цикл Sense-Decide-Act для патрулювання
4. **Керувати** станом агента через змінні та функції

---

## 📚 Що ви використаєте з попередніх розділів

| Розділ | Концепція | Як використовуємо |
|--------|-----------|-------------------|
| 1 | cargo, println! | Структура проєкту, вивід стану |
| 2 | Змінні, типи, mut | Координати, енергія агента |
| 3 | Функції | Модульний код, обчислення |
| 4 | if/else, match, цикли | Логіка рішень, головний цикл |
| 5 | Масиви, кортежі | Маршрут, позиції |

---

## 6.1 КОНЦЕПЦІЯ СИМУЛЯЦІЇ

### 6.1.1 Світ агента

Перш ніж писати код, потрібно визначити, в якому світі існуватиме наш агент.

Ми використовуємо **2D сітку** — це прямокутна область, поділена на клітинки. Кожна клітинка має координати (X, Y). Уявіть шахову дошку, але довільного розміру — наприклад, 20 клітинок в ширину і 15 у висоту.

**Візуалізація сітки 20×15:**

```text
     0   1   2   3   4   5   6   7   8   9  ... 19
   ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┐
 0 │ B │   │   │   │   │   │   │   │   │   │   │   │  B = База (старт)
   ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤
 1 │   │   │   │   │   │   │   │   │   │   │   │   │
   ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤
 2 │   │   │   │ * │   │   │   │   │   │   │   │   │  * = Точка інтересу
   ├───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┼───┤
 3 │   │   │   │   │   │   │ A │   │   │   │   │   │  A = Агент
   └───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┴───┘
```

**Система координат:**
- **X** (горизонталь): 0 — лівий край, збільшується вправо
- **Y** (вертикаль): 0 — верхній край, збільшується вниз

**Чому Y росте вниз, а не вгору?** Це стандарт для комп'ютерної графіки та терміналів. Текст виводиться зверху вниз, тому перший рядок має Y=0, другий — Y=1, і так далі.

### 6.1.2 Місія агента

Наш агент-патрульний виконує охоронну місію:

1. **Стартує на базі** — точка (0, 0) у лівому верхньому куті
2. **Патрулює периметр** — обходить межу сітки за годинниковою стрілкою
3. **Сканує територію** — на кожному кроці шукає підозрілі об'єкти (POI — Points of Interest)
4. **Слідкує за енергією** — рух і сканування витрачають батарею
5. **Повертається заряджатись** — коли енергія падає до критичного рівня
6. **Продовжує патруль** — після зарядки повертається туди, де зупинився

### 6.1.3 Патерн Sense-Decide-Act

Кожен цикл роботи агента складається з трьох фаз. Цей патерн використовується у всіх автономних системах — від роботів-пилососів до безпілотників.

```text
┌─────────────────────────────────────────────────────────────┐
│                    ОДИН ЦИКЛ АГЕНТА                         │
│                                                             │
│   ┌─────────────┐    ┌─────────────┐    ┌─────────────┐    │
│   │   SENSE     │───▶│   DECIDE    │───▶│    ACT      │    │
│   │ (Сприйняття)│    │  (Рішення)  │    │   (Дія)     │    │
│   │             │    │             │    │             │    │
│   │ • Де я?     │    │ • Мало      │    │ • Рухаюсь   │    │
│   │ • Скільки   │    │   енергії?  │    │ • Сканую    │    │
│   │   енергії?  │    │ • На базі?  │    │ • Заряджаюсь│    │
│   │ • Що навколо│    │ • Куди далі?│    │             │    │
│   └─────────────┘    └─────────────┘    └─────────────┘    │
│         ▲                                      │            │
│         └──────────────────────────────────────┘            │
│              (цикл повторюється нескінченно)                │
└─────────────────────────────────────────────────────────────┘
```

**SENSE (Сприйняття):** Агент збирає інформацію про навколишній світ і свій стан. Де я знаходжусь? Скільки залишилось енергії? Чи є щось цікаве поруч?

**DECIDE (Рішення):** На основі зібраної інформації агент вирішує, що робити. Якщо енергії мало — повертатись. Якщо досяг точки маршруту — обрати наступну. Якщо все нормально — продовжувати рух.

**ACT (Дія):** Агент виконує обране рішення. Рухається, сканує, або заряджається.

---

## 6.2 КОНСТАНТИ СВІТУ

### 6.2.1 Постановка задачі: конфігурація симуляції

У нашій симуляції є багато числових параметрів: розмір сітки, координати бази, витрата енергії на крок, критичний рівень батареї. Ці значення використовуються в різних місцях коду.

**Проблема:** Якщо записати ці числа безпосередньо в код (наприклад, `if energy < 20`), то:
- Незрозуміло, що означає 20 — це критичний рівень? максимум? щось інше?
- Якщо захочемо змінити поріг на 25, доведеться шукати всі місця, де написано 20
- Легко помилитись і в одному місці написати 20, в іншому — 15

**Рішення:** Винести всі параметри в іменовані константи на початку програми. Тоді `ENERGY_CRITICAL` зрозуміліше ніж `20`, і змінювати потрібно лише в одному місці.

### 6.2.2 Реалізація констант

Нижче наведено всі константи нашої симуляції. Кожна має осмислене ім'я, яке пояснює її призначення.

```rust
// ═══════════════════════════════════════════════════════════════
// КОНСТАНТИ СВІТУ
// Всі налаштування симуляції зібрані в одному місці.
// Щоб змінити поведінку — редагуйте тільки цей блок.
// ═══════════════════════════════════════════════════════════════

// --- Розміри сітки патрулювання ---
// Визначають, наскільки велика територія для патрулювання.
// Агент буде рухатись в прямокутнику від (0,0) до (GRID_WIDTH-1, GRID_HEIGHT-1).
const GRID_WIDTH: i32 = 20;   // Ширина: 20 клітинок (X від 0 до 19)
const GRID_HEIGHT: i32 = 15;  // Висота: 15 клітинок (Y від 0 до 14)

// --- Координати бази ---
// База — це точка старту і місце зарядки.
// Агент завжди починає тут і повертається сюди при низькій енергії.
const BASE_X: i32 = 0;
const BASE_Y: i32 = 0;

// --- Параметри енергії ---
// Ці константи визначають "економіку" енергії агента.
const MAX_ENERGY: u8 = 100;        // Повний заряд батареї (100%)
const ENERGY_PER_MOVE: u8 = 2;     // Скільки енергії коштує один крок
const ENERGY_PER_SCAN: u8 = 1;     // Скільки енергії коштує сканування
const ENERGY_CRITICAL: u8 = 20;    // При цьому рівні агент кидає все і їде на базу
const ENERGY_CHARGE_RATE: u8 = 10; // Скільки енергії відновлюється за один цикл на базі

// --- Ліміт симуляції ---
// Захист від нескінченного циклу під час тестування.
// Якщо щось піде не так, симуляція зупиниться після цієї кількості циклів.
const MAX_CYCLES: u32 = 200;
```

**Що означає кожна константа і як вона впливає на поведінку:**

| Константа | Значення | Вплив на симуляцію |
|-----------|----------|-------------------|
| `GRID_WIDTH` | 20 | Більше значення = довший маршрут патрулювання |
| `GRID_HEIGHT` | 15 | Більше значення = довший маршрут патрулювання |
| `MAX_ENERGY` | 100 | Визначає "ємність батареї" |
| `ENERGY_PER_MOVE` | 2 | Більше значення = частіше потрібно заряджатись |
| `ENERGY_PER_SCAN` | 1 | Впливає на загальну витрату енергії |
| `ENERGY_CRITICAL` | 20 | Більше значення = раніше повертається на базу |
| `ENERGY_CHARGE_RATE` | 10 | Більше значення = швидше заряджається |

**Синтаксис констант у Rust:**

```rust
const ІМ'Я: тип = значення;
```

Правила:
- Ім'я пишеться `ВЕЛИКИМИ_ЛІТЕРАМИ_З_ПІДКРЕСЛЕННЯМИ`
- Тип **обов'язковий** (на відміну від `let`, де тип можна опустити)
- Значення має бути відомим при компіляції (не можна присвоїти результат функції)
- Константу неможливо змінити — спроба призведе до помилки компіляції

---

## 6.3 СТАН АГЕНТА

### 6.3.1 Постановка задачі: що агент повинен "пам'ятати"

Агент працює в циклі: сприйняття → рішення → дія → сприйняття → ... Але щоб приймати рішення, йому потрібна інформація не тільки про поточний момент, а й про те, що було раніше.

**Що агент повинен знати між циклами:**

1. **Де я зараз?** — координати X і Y на сітці
2. **Куди я дивлюсь?** — напрямок руху (для відображення)
3. **Скільки в мене енергії?** — щоб вирішити, чи потрібно заряджатись
4. **Куди я прямую?** — поточна ціль маршруту
5. **Чи я зараз повертаюсь на базу?** — режим "аварійного" повернення
6. **Чи я зараз заряджаюсь?** — режим зарядки
7. **Звідки я прийшов?** — щоб продовжити патруль після зарядки

**Також корисно збирати статистику:**
- Скільки клітинок пройдено
- Скільки POI знайдено
- Скільки разів заряджався

Всі ці дані зберігатимуться у змінних. Оскільки вони змінюються під час роботи, всі мають бути `mut`.

### 6.3.2 Реалізація стану агента

Нижче наведено ініціалізацію всіх змінних стану. Код розбитий на логічні групи з поясненнями.

```rust
fn main() {
    // Виводимо заголовок симуляції
    println!("╔══════════════════════════════════════════════════════════════╗");
    println!("║          СИМУЛЯЦІЯ АГЕНТА-ПАТРУЛЬНОГО v1.0                   ║");
    println!("╚══════════════════════════════════════════════════════════════╝");
    println!();

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 1: Позиція та напрямок
    // Де знаходиться агент і куди він рухається
    // ═══════════════════════════════════════════════════════════════
    
    // Координати агента на сітці.
    // Агент стартує на базі, тому початкові координати = координати бази.
    let mut pos_x: i32 = BASE_X;  // Горизонтальна позиція (0 = лівий край)
    let mut pos_y: i32 = BASE_Y;  // Вертикальна позиція (0 = верхній край)
    
    // Напрямок руху агента.
    // Кодуємо числами: 0=Північ(вгору), 1=Схід(вправо), 2=Південь(вниз), 3=Захід(вліво).
    // Чому числа, а не текст? Бо з числами легко робити математику:
    // - Поворот вправо: (direction + 1) % 4
    // - Поворот вліво: (direction + 3) % 4
    // - Розворот: (direction + 2) % 4
    let mut direction: u8 = 1;  // Починаємо рухом на схід (вправо)

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 2: Ресурси
    // Що є в агента і скільки
    // ═══════════════════════════════════════════════════════════════
    
    // Поточний рівень енергії (від 0 до MAX_ENERGY).
    // Починаємо з повним зарядом.
    let mut energy: u8 = MAX_ENERGY;

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 3: Статистика місії
    // Лічильники для фінального звіту
    // ═══════════════════════════════════════════════════════════════
    
    // Скільки клітинок агент пройшов за всю місію
    let mut total_distance: u32 = 0;
    
    // Скільки точок інтересу (POI) виявлено
    let mut pois_found: u8 = 0;
    
    // Скільки разів агент заряджався
    let mut charges_count: u8 = 0;

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 4: Режими роботи (прапорці)
    // Визначають поточний "режим" агента
    // ═══════════════════════════════════════════════════════════════
    
    // Чи агент зараз повертається на базу через низьку енергію?
    // Коли true — агент ігнорує маршрут і йде прямо на базу.
    let mut is_returning: bool = false;
    
    // Чи агент зараз заряджається?
    // Коли true — агент стоїть на базі і не рухається.
    let mut is_charging: bool = false;

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 5: Маршрут патрулювання
    // Куди агент повинен рухатись
    // ═══════════════════════════════════════════════════════════════
    
    // Waypoints — ключові точки маршруту (кути периметра).
    // Агент рухається від точки до точки по порядку, потім повторює.
    // 
    // Маршрут: База(0,0) → (19,0) → (19,14) → (0,14) → (0,0) → ...
    //
    //   (0,0)──────────────(19,0)
    //     │                   │
    //     │    ПЕРИМЕТР       │
    //     │                   │
    //   (0,14)─────────────(19,14)
    //
    let patrol_waypoints: [(i32, i32); 4] = [
        (GRID_WIDTH - 1, 0),               // Точка 0: верхній правий кут (19, 0)
        (GRID_WIDTH - 1, GRID_HEIGHT - 1), // Точка 1: нижній правий кут (19, 14)
        (0, GRID_HEIGHT - 1),              // Точка 2: нижній лівий кут (0, 14)
        (BASE_X, BASE_Y),                  // Точка 3: база / верхній лівий (0, 0)
    ];
    
    // Індекс поточної цілі в масиві waypoints.
    // 0 означає, що агент прямує до patrol_waypoints[0], тобто до (19, 0).
    let mut current_waypoint: usize = 0;
    
    // Збережена позиція — запам'ятовуємо, де був агент перед поверненням на базу.
    // Після зарядки агент "телепортується" назад і продовжує патруль.
    let mut saved_pos: (i32, i32) = (0, 0);
    let mut saved_waypoint: usize = 0;

    // ═══════════════════════════════════════════════════════════════
    // ГРУПА 6: Час симуляції
    // ═══════════════════════════════════════════════════════════════
    
    // Номер поточного циклу (такт симуляції).
    // Використовується для логування та обмеження тривалості.
    let mut cycle: u32 = 0;

    // Виводимо початковий стан агента
    println!("📍 Агент ініціалізовано на позиції ({}, {})", pos_x, pos_y);
    println!("🧭 Напрямок: {}", direction_name(direction));
    println!("🔋 Енергія: {}%", energy);
    println!("🎯 Перша ціль: {:?}", patrol_waypoints[0]);
    
    // ... далі буде головний цикл ...
}
```

**Чому ми використовуємо окремі змінні, а не структуру?**

У наступних розділах ви дізнаєтесь про `struct` — спосіб групувати пов'язані дані. Тоді замість `pos_x`, `pos_y`, `energy`, `direction` ми матимемо один `Agent`. Але поки що ми ще не вивчили структури, тому використовуємо окремі змінні. Це одне з обмежень, які ми знімемо в Частині I.

---

## 6.4 ДОПОМІЖНІ ФУНКЦІЇ

### 6.4.1 Постановка задачі: перетворення коду напрямку на текст

Напрямок руху ми зберігаємо як число 0-3. Це зручно для обчислень (наприклад, поворот вправо = додати 1), але незручно для виводу користувачу. Користувач не зрозуміє "Напрямок: 2" — йому потрібно "Напрямок: Південь ↓".

Потрібна функція, яка приймає код напрямку (0, 1, 2, або 3) і повертає зрозумілий текст з назвою та стрілкою.

```rust
/// Перетворює числовий код напрямку на текстову назву зі стрілкою.
///
/// Кодування напрямків:
/// - 0 = Північ (рух вгору, Y зменшується)
/// - 1 = Схід (рух вправо, X збільшується)
/// - 2 = Південь (рух вниз, Y збільшується)
/// - 3 = Захід (рух вліво, X зменшується)
fn direction_name(dir: u8) -> &'static str {
    match dir {
        0 => "Північ ↑",
        1 => "Схід →",
        2 => "Південь ↓",
        3 => "Захід ←",
        _ => "???",      // Захист від невалідних значень
    }
}
```

**Як працює ця функція:**

Функція використовує `match` для вибору відповідного тексту. Параметр `dir` порівнюється з кожним варіантом (0, 1, 2, 3), і повертається відповідний рядок.

Шаблон `_` (wildcard) ловить будь-яке інше значення — це захист від багів. Якщо через помилку в коді `direction` стане 5 або 255, програма не впаде, а виведе "???".

**Тип повернення `&'static str`:**

Це посилання на рядок, який існує весь час роботи програми. Рядки на кшталт `"Північ ↑"` вбудовані в бінарний файл програми і ніколи не звільняються, тому їх можна безпечно повертати з функції.

**Приклад використання:**

```rust
let dir = 2;
println!("Агент дивиться на {}", direction_name(dir));
// Виведе: Агент дивиться на Південь ↓
```

### 6.4.2 Постановка задачі: обчислення відстані між точками

Агент повинен знати, як далеко до цілі. Це потрібно для:
- Визначення, чи досяг він waypoint
- Планування маршруту
- Оцінки, чи вистачить енергії

На сітці агент рухається тільки по горизонталі та вертикалі (не по діагоналі). Тому використовуємо **Манхеттенську відстань** — суму модулів різниць координат. Ця назва походить від Манхеттена, де вулиці утворюють сітку, і пішоходи не можуть ходити "навпростець" через будівлі.

```rust
/// Обчислює Манхеттенську відстань між двома точками на сітці.
///
/// Манхеттенська відстань — це кількість кроків по сітці від однієї
/// точки до іншої, якщо можна рухатись тільки горизонтально або вертикально.
///
/// Формула: |x2 - x1| + |y2 - y1|
///
/// Приклад: від (1, 1) до (4, 3)
/// - По горизонталі: |4 - 1| = 3 кроки
/// - По вертикалі: |3 - 1| = 2 кроки
/// - Всього: 3 + 2 = 5 кроків
fn distance(x1: i32, y1: i32, x2: i32, y2: i32) -> i32 {
    let horizontal = (x2 - x1).abs();  // Кроки по горизонталі
    let vertical = (y2 - y1).abs();    // Кроки по вертикалі
    horizontal + vertical               // Сума = загальна відстань
}
```

**Візуалізація на прикладі:**

```text
Від точки A(1,1) до точки B(4,3):

    0   1   2   3   4   5
  ┌───┬───┬───┬───┬───┬───┐
0 │   │   │   │   │   │   │
  ├───┼───┼───┼───┼───┼───┤
1 │   │ A │ → │ → │ → │   │   ← 3 кроки вправо (горизонталь)
  ├───┼───┼───┼───┼───┼───┤
2 │   │   │   │   │ ↓ │   │   ← 1 крок вниз
  ├───┼───┼───┼───┼───┼───┤
3 │   │   │   │   │ B │   │   ← 1 крок вниз (всього 2 по вертикалі)
  └───┴───┴───┴───┴───┴───┘

Відстань = |4-1| + |3-1| = 3 + 2 = 5 кроків
```

**Чому не Евклідова відстань?**

Евклідова відстань — це "напряму" (по діагоналі), вона обчислюється за теоремою Піфагора: √((x2-x1)² + (y2-y1)²). Для прикладу вище вона була б √(9+4) ≈ 3.6.

Але наш агент не може рухатись по діагоналі! Він робить кроки вгору-вниз-вліво-вправо. Тому Манхеттенська відстань точніше показує, скільки кроків йому знадобиться.

### 6.4.3 Постановка задачі: визначення напрямку до цілі

Агент знає, де він (pos_x, pos_y) і куди йому потрібно (target_x, target_y). Тепер йому потрібно визначити, куди зробити наступний крок.

Функція повинна повернути "зміщення" — на скільки змінити X і Y для одного кроку в напрямку цілі. Можливі варіанти:
- (1, 0) — крок вправо
- (-1, 0) — крок вліво
- (0, 1) — крок вниз
- (0, -1) — крок вгору
- (0, 0) — вже на місці

```rust
/// Визначає напрямок одного кроку від поточної позиції до цілі.
///
/// Логіка:
/// 1. Обчислюємо різницю координат (скільки залишилось по кожній осі)
/// 2. Беремо знак (signum): -1 якщо від'ємне, 0 якщо нуль, +1 якщо додатне
/// 3. Вибираємо одну вісь (пріоритет: спочатку X, потім Y)
///
/// Повертає кортеж (dx, dy) — зміщення для одного кроку.
fn direction_to(from_x: i32, from_y: i32, to_x: i32, to_y: i32) -> (i32, i32) {
    // Визначаємо, в яку сторону по кожній осі
    // signum() повертає:
    //   -1 якщо число від'ємне (ціль лівіше/вище)
    //    0 якщо число = 0 (вже на потрібній координаті)
    //   +1 якщо число додатне (ціль правіше/нижче)
    let dx = (to_x - from_x).signum();
    let dy = (to_y - from_y).signum();
    
    // Рухаємось по одній осі за раз (не по діагоналі).
    // Пріоритет: спочатку горизонталь (X), потім вертикаль (Y).
    if dx != 0 {
        (dx, 0)   // Ще не дійшли по X — рухаємось по X
    } else {
        (0, dy)   // X вже співпадає — рухаємось по Y
    }
}
```

**Приклади роботи функції:**

| Звідки | Куди | to_x - from_x | to_y - from_y | dx | dy | Результат |
|--------|------|---------------|---------------|----|----|-----------|
| (0, 0) | (3, 2) | 3 | 2 | 1 | 1 | **(1, 0)** — вправо |
| (3, 0) | (3, 2) | 0 | 2 | 0 | 1 | **(0, 1)** — вниз |
| (5, 5) | (2, 5) | -3 | 0 | -1 | 0 | **(-1, 0)** — вліво |
| (3, 3) | (3, 3) | 0 | 0 | 0 | 0 | **(0, 0)** — на місці |

**Чому пріоритет по X?**

Вибір довільний — можна було б спочатку рухатись по Y. Головне — бути послідовним. Завдяки цьому агент рухається передбачувано: спочатку горизонтально, потім вертикально.

### 6.4.4 Постановка задачі: перевірка валідності позиції

Перед тим як зробити крок, агент повинен переконатись, що нова позиція знаходиться в межах сітки. Інакше він може "вийти" за край світу, що призведе до некоректної поведінки.

Позиція валідна, якщо:
- X >= 0 (не вийшли за лівий край)
- X < GRID_WIDTH (не вийшли за правий край)
- Y >= 0 (не вийшли за верхній край)
- Y < GRID_HEIGHT (не вийшли за нижній край)

```rust
/// Перевіряє, чи координати (x, y) знаходяться в межах сітки.
///
/// Сітка має розміри GRID_WIDTH × GRID_HEIGHT.
/// Валідні координати: X від 0 до GRID_WIDTH-1, Y від 0 до GRID_HEIGHT-1.
fn is_valid_position(x: i32, y: i32) -> bool {
    x >= 0 && x < GRID_WIDTH && y >= 0 && y < GRID_HEIGHT
}
```

**Приклади для сітки 20×15:**

| Позиція | x >= 0 | x < 20 | y >= 0 | y < 15 | Результат |
|---------|--------|--------|--------|--------|-----------|
| (5, 7) | ✓ | ✓ | ✓ | ✓ | **true** |
| (0, 0) | ✓ | ✓ | ✓ | ✓ | **true** |
| (19, 14) | ✓ | ✓ | ✓ | ✓ | **true** |
| (-1, 5) | ✗ | — | — | — | **false** |
| (20, 5) | ✓ | ✗ | — | — | **false** |
| (5, 15) | ✓ | ✓ | ✓ | ✗ | **false** |

### 6.4.5 Постановка задачі: симуляція сканування

Під час патрулювання агент сканує територію навколо себе, шукаючи "точки інтересу" (POI) — підозрілі об'єкти, аномалії, або що завгодно за сценарієм місії.

У реальній системі сканування аналізувало б дані з камер чи сенсорів. У нашій симуляції ми "підкидаємо монетку" — з невеликою ймовірністю (5%) оголошуємо, що знайшли POI.

Щоб результати були відтворюваними (однаковими при кожному запуску), замість справжнього генератора випадкових чисел використовуємо просту хеш-функцію від координат і номера циклу.

```rust
/// Симулює сканування території на наявність POI.
///
/// Це спрощена симуляція: POI "з'являються" випадково з ймовірністю ~5%.
/// Використовуємо хеш-функцію замість random для відтворюваності результатів.
///
/// У реальній системі тут був би аналіз даних з камери або радара.
fn scan_area(x: i32, y: i32, cycle: u32) -> bool {
    // Обчислюємо "псевдовипадкове" число на основі координат і циклу.
    // Множники 31, 17, 13 — прості числа, що дають хороше "перемішування".
    let hash = ((x * 31 + y * 17 + cycle as i32 * 13) % 100).abs();
    
    // Якщо hash < 5, вважаємо що знайшли POI.
    // Оскільки hash рівномірно розподілений від 0 до 99,
    // ймовірність hash < 5 становить приблизно 5%.
    hash < 5
}
```

**Як працює "псевдовипадковість":**

Формула `x * 31 + y * 17 + cycle * 13` дає різні числа для різних комбінацій координат і циклів. Операція `% 100` залишає тільки останні дві цифри (0-99). Результат виглядає "випадковим", але насправді повністю визначається вхідними даними.

**Приклад:**
- (5, 3, цикл 10): 5*31 + 3*17 + 10*13 = 155 + 51 + 130 = 336. 336 % 100 = 36. 36 < 5? Ні. POI не знайдено.
- (2, 7, цикл 23): 2*31 + 7*17 + 23*13 = 62 + 119 + 299 = 480. 480 % 100 = 80. 80 < 5? Ні.
- (1, 1, цикл 3): 1*31 + 1*17 + 3*13 = 31 + 17 + 39 = 87. 87 % 100 = 87. 87 < 5? Ні.
- (0, 4, цикл 1): 0*31 + 4*17 + 1*13 = 0 + 68 + 13 = 81. 81 % 100 = 81. Ні.

POI знаходяться рідко — приблизно в 5% випадків.

---

## 6.5 ФУНКЦІЇ ВІЗУАЛІЗАЦІЇ

### 6.5.1 Постановка задачі: візуальний індикатор енергії

Виводити "Енергія: 73%" — це добре, але візуальний індикатор сприймається швидше. Людині легше побачити "███████░░░", ніж читати число і думати "це багато чи мало?".

Потрібна функція, яка перетворює число (0-100) на рядок з 10 символів, де заповнені символи показують поточний рівень.

```rust
/// Створює візуальний індикатор рівня енергії.
///
/// Індикатор складається з 10 сегментів:
/// - "█" (заповнений) — є енергія
/// - "░" (порожній) — немає енергії
///
/// Приклади:
/// - 100% → "██████████" (10 заповнених)
/// - 70%  → "███████░░░" (7 заповнених, 3 порожніх)
/// - 25%  → "██░░░░░░░░" (2 заповнених, 8 порожніх)
/// - 0%   → "░░░░░░░░░░" (10 порожніх)
fn create_energy_bar(energy: u8) -> String {
    // Обчислюємо кількість заповнених сегментів.
    // energy / 10 дає: 100→10, 73→7, 25→2, 5→0.
    let filled = (energy as usize) / 10;
    
    // Решта — порожні сегменти.
    let empty = 10 - filled;
    
    // Створюємо рядок: repeat повторює символ N разів.
    // "█".repeat(7) дає "███████"
    // "░".repeat(3) дає "░░░"
    format!("{}{}", "█".repeat(filled), "░".repeat(empty))
}
```

**Таблиця відповідності:**

| Енергія | filled (energy/10) | empty (10-filled) | Результат |
|---------|-------------------|-------------------|-----------|
| 100 | 10 | 0 | `██████████` |
| 85 | 8 | 2 | `████████░░` |
| 73 | 7 | 3 | `███████░░░` |
| 50 | 5 | 5 | `█████░░░░░` |
| 20 | 2 | 8 | `██░░░░░░░░` |
| 5 | 0 | 10 | `░░░░░░░░░░` |

### 6.5.2 Постановка задачі: компактний вивід статусу

Під час симуляції потрібно виводити поточний стан агента. Вивід має бути:
- **Компактним** — один рядок на цикл
- **Інформативним** — позиція, енергія, дія
- **Читабельним** — з вирівнюванням і емодзі

Формат: `[цикл] 📍(X,Y) ↑ 🔋[████████░░] 80% | Статус`

```rust
/// Виводить однорядковий статус агента.
///
/// Формат виводу:
/// [  25] 📍(15, 7) → 🔋[███████░░░]  68% | 🚶 Патрулювання
///   │       │      │      │           │         │
///   │       │      │      │           │         └── Поточна дія
///   │       │      │      │           └── Числове значення енергії
///   │       │      │      └── Візуальний індикатор
///   │       │      └── Напрямок руху
///   │       └── Координати
///   └── Номер циклу
fn print_status(
    cycle: u32,
    x: i32, 
    y: i32, 
    energy: u8, 
    direction: u8,
    state: &str
) {
    // Створюємо візуальний індикатор енергії
    let energy_bar = create_energy_bar(energy);
    
    // Вибираємо стрілку для напрямку
    let dir_arrow = match direction {
        0 => "↑",  // Північ
        1 => "→",  // Схід
        2 => "↓",  // Південь
        3 => "←",  // Захід
        _ => "?",
    };
    
    // Виводимо форматований рядок.
    // {:>4} означає: вирівняти вправо, мінімум 4 символи.
    // {:>2} означає: вирівняти вправо, мінімум 2 символи.
    // Це забезпечує рівні колонки навіть для різних чисел.
    println!(
        "[{:>4}] 📍({:>2},{:>2}) {} 🔋[{}] {:>3}% | {}",
        cycle, x, y, dir_arrow, energy_bar, energy, state
    );
}
```

**Приклади виводу:**

```rust
[   1] 📍( 0, 0) → 🔋[██████████] 100% | 🚶 Патрулювання
[  25] 📍(15, 7) → 🔋[███████░░░]  68% | 🚶 Патрулювання
[ 100] 📍( 0, 0) ↑ 🔋[██░░░░░░░░]  20% | 🔌 Зарядка...
```

Зверніть увагу на вирівнювання: числа вирівняні вправо, тому колонки залишаються рівними.

---

## 6.6 ГОЛОВНИЙ ЦИКЛ СИМУЛЯЦІЇ

### 6.6.1 Постановка задачі: організація головного циклу

Тепер потрібно об'єднати все разом: стан агента, функції прийняття рішень, візуалізацію. Головний цикл буде виконуватись, поки агент не завершить місію або не досягне ліміту циклів.

Структура кожної ітерації:
1. Збільшити лічильник циклів
2. Перевірити ліміт (захист від зависання)
3. **SENSE:** зібрати інформацію
4. **DECIDE:** прийняти рішення
5. **ACT:** виконати дію
6. Вивести статус
7. Перевірити умову завершення

```rust
fn main() {
    // ... ініціалізація (з попередніх секцій) ...
    
    println!("\n════════════════════════════════════════════════════════════════");
    println!("  🚀 ЗАПУСК ПАТРУЛЮВАННЯ");
    println!("════════════════════════════════════════════════════════════════\n");
    
    // Головний цикл симуляції.
    // 'simulation: — це МІТКА циклу, дозволяє вийти з `break 'simulation`.
    'simulation: loop {
        // Збільшуємо лічильник
        cycle += 1;
        
        // Захист від нескінченного циклу
        if cycle > MAX_CYCLES {
            println!("\n⏱️  Досягнуто ліміт циклів ({})", MAX_CYCLES);
            break 'simulation;
        }
        
        // ═══ SENSE: збір інформації (див. наступну секцію) ═══
        
        // ═══ DECIDE: прийняття рішення (див. наступну секцію) ═══
        
        // ═══ ACT: виконання дії (див. наступну секцію) ═══
        
        // ═══ Вивід статусу ═══
        
        // ═══ Перевірка завершення ═══
    }
    
    // Виводимо підсумок місії
    print_mission_summary(cycle, total_distance, pois_found, charges_count, energy);
}
```

**Що таке мітка `'simulation:`?**

Це ім'я для циклу. Зазвичай `break` виходить з найближчого циклу. Але якщо цикли вкладені, може знадобитись вийти з зовнішнього. `break 'simulation` явно вказує, з якого циклу виходити.

### 6.6.2 Фаза SENSE: збір інформації

На цій фазі агент "дивиться навколо" і збирає всю потрібну інформацію для прийняття рішення.

```rust
        // ─────────────────────────────────────────────────────────
        // ФАЗА SENSE: Сприйняття навколишнього світу
        // Агент збирає інформацію про свій стан і оточення.
        // ─────────────────────────────────────────────────────────
        
        // --- Перевірка позиції ---
        
        // Чи агент зараз на базі?
        // Це важливо для зарядки — заряджатись можна тільки на базі.
        let at_base = pos_x == BASE_X && pos_y == BASE_Y;
        
        // Чи агент досяг поточного waypoint?
        // Якщо так — час обрати наступну ціль.
        let at_waypoint = pos_x == patrol_waypoints[current_waypoint].0 
                       && pos_y == patrol_waypoints[current_waypoint].1;
        
        // --- Перевірка енергії ---
        
        // Чи енергія критично низька? (потрібно повертатись)
        let energy_low = energy <= ENERGY_CRITICAL;
        
        // Чи енергія повна? (можна завершити зарядку)
        let energy_full = energy >= MAX_ENERGY;
        
        // --- Сканування території ---
        
        // Скануємо тільки якщо:
        // - не на базі (на базі нічого шукати)
        // - не заряджаємось (під час зарядки не скануємо)
        let poi_detected = if !at_base && !is_charging {
            // Сканування коштує енергію
            // saturating_sub не дасть енергії стати від'ємною
            energy = energy.saturating_sub(ENERGY_PER_SCAN);
            
            // Виконуємо сканування і перевіряємо, чи знайшли POI
            scan_area(pos_x, pos_y, cycle)
        } else {
            false  // Не скануємо — POI не знайдено
        };
        
        // Якщо знайшли POI — логуємо подію
        if poi_detected {
            pois_found += 1;
            println!("    🔍 POI ВИЯВЛЕНО на ({}, {})!", pos_x, pos_y);
        }
```

**Що робить цей код:**

1. **`at_base`** — булева змінна, true якщо координати агента співпадають з координатами бази.

2. **`at_waypoint`** — true якщо агент досяг поточної цілі маршруту.

3. **`energy_low`** і **`energy_full`** — перевірки рівня енергії для прийняття рішень.

4. **Сканування** — виконується тільки при певних умовах. `if !at_base && !is_charging` — це "guard" (захист), який запобігає непотрібному скануванню.

5. **`saturating_sub`** — безпечне віднімання. Якщо `energy = 0` і ми віднімаємо 1, звичайне віднімання для `u8` спричинить переповнення (0-1 = 255!). `saturating_sub` зупиняється на 0.

### 6.6.3 Фаза DECIDE: прийняття рішення

На основі зібраної інформації агент вирішує, що робити. Це найскладніша частина — дерево рішень з багатьма гілками.

```rust
        // ─────────────────────────────────────────────────────────
        // ФАЗА DECIDE: Прийняття рішення
        // На основі зібраної інформації агент обирає дію.
        // ─────────────────────────────────────────────────────────
        
        // Змінні для результату рішення
        let action: &str;           // Текстовий опис дії (для логування)
        let target: (i32, i32);     // Координати цілі (куди рухатись)
        
        // Дерево рішень.
        // ВАЖЛИВО: порядок перевірок має значення!
        // Вищі пріоритети перевіряються першими.
        
        if is_charging {
            // ╔═══════════════════════════════════════════════════════╗
            // ║ ПРІОРИТЕТ 1: Агент зараз заряджається                 ║
            // ║ Це найвищий пріоритет — зарядка не переривається.    ║
            // ╚═══════════════════════════════════════════════════════╝
            
            if energy_full {
                // Зарядка завершена!
                // Скидаємо прапорці і відновлюємо збережену позицію.
                is_charging = false;
                is_returning = false;
                
                // "Телепортуємось" назад туди, де були перед поверненням
                pos_x = saved_pos.0;
                pos_y = saved_pos.1;
                current_waypoint = saved_waypoint;
                
                action = "⚡ Зарядка завершена, продовження патрулювання";
                target = (pos_x, pos_y);  // Вже на місці
            } else {
                // Продовжуємо заряджатись
                action = "🔌 Зарядка...";
                target = (BASE_X, BASE_Y);
            }
            
        } else if energy_low && !at_base {
            // ╔═══════════════════════════════════════════════════════╗
            // ║ ПРІОРИТЕТ 2: Низька енергія, потрібно на базу        ║
            // ║ Агент кидає все і повертається заряджатись.          ║
            // ╚═══════════════════════════════════════════════════════╝
            
            if !is_returning {
                // Тільки почали повернення — зберігаємо позицію
                saved_pos = (pos_x, pos_y);
                saved_waypoint = current_waypoint;
                is_returning = true;
                action = "⚠️  Низька енергія! Повернення на базу";
            } else {
                // Вже повертаємось
                action = "🔙 Повертаємось на базу";
            }
            target = (BASE_X, BASE_Y);
            
        } else if is_returning && at_base {
            // ╔═══════════════════════════════════════════════════════╗
            // ║ ПРІОРИТЕТ 3: Прибули на базу для зарядки             ║
            // ╚═══════════════════════════════════════════════════════╝
            
            is_charging = true;
            charges_count += 1;
            action = "🏠 На базі, початок зарядки";
            target = (BASE_X, BASE_Y);
            
        } else if at_waypoint {
            // ╔═══════════════════════════════════════════════════════╗
            // ║ ПРІОРИТЕТ 4: Досягли waypoint — обираємо наступний   ║
            // ╚═══════════════════════════════════════════════════════╝
            
            // Переходимо до наступного waypoint.
            // % patrol_waypoints.len() забезпечує циклічність:
            // після останнього (індекс 3) повертаємось до першого (індекс 0).
            current_waypoint = (current_waypoint + 1) % patrol_waypoints.len();
            action = "🎯 Waypoint досягнуто, наступна ціль";
            target = patrol_waypoints[current_waypoint];
            
        } else {
            // ╔═══════════════════════════════════════════════════════╗
            // ║ ЗА ЗАМОВЧУВАННЯМ: Звичайне патрулювання              ║
            // ╚═══════════════════════════════════════════════════════╝
            
            action = "🚶 Патрулювання";
            target = patrol_waypoints[current_waypoint];
        }
```

**Діаграма дерева рішень:**

```text
┌─ is_charging? (зараз заряджаємось?)
│   ├─ YES → energy_full? (батарея повна?)
│   │         ├─ YES → Завершити зарядку, повернутись до патруля
│   │         └─ NO  → Продовжувати заряджатись
│   │
│   └─ NO → energy_low && !at_base? (мало енергії і не на базі?)
│            ├─ YES → Повертатись на базу
│            │
│            └─ NO → is_returning && at_base? (повертались і прибули?)
│                     ├─ YES → Почати зарядку
│                     │
│                     └─ NO → at_waypoint? (досягли точки маршруту?)
│                              ├─ YES → Обрати наступну точку
│                              └─ NO  → Рухатись до поточної точки
```

**Чому порядок важливий?**

Якби ми спочатку перевіряли `energy_low`, а потім `is_charging`, то агент з низькою енергією постійно переривав би зарядку (бо енергія все ще низька, поки не зарядиться повністю).

### 6.6.4 Фаза ACT: виконання дії

Тепер агент виконує обране рішення: заряджається, або рухається до цілі.

```rust
        // ─────────────────────────────────────────────────────────
        // ФАЗА ACT: Виконання дії
        // Агент робить те, що вирішив на попередній фазі.
        // ─────────────────────────────────────────────────────────
        
        if is_charging {
            // ═══ ДІЯ: Зарядка ═══
            // Додаємо енергію, але не більше максимуму.
            // .min(MAX_ENERGY) обмежує значення зверху.
            energy = (energy + ENERGY_CHARGE_RATE).min(MAX_ENERGY);
            
        } else if (pos_x, pos_y) != target {
            // ═══ ДІЯ: Рух до цілі ═══
            // Виконується тільки якщо ще не на цілі.
            
            // Визначаємо напрямок одного кроку
            let (dx, dy) = direction_to(pos_x, pos_y, target.0, target.1);
            
            // Обчислюємо нову позицію
            let new_x = pos_x + dx;
            let new_y = pos_y + dy;
            
            // Перевіряємо, чи можемо зробити крок:
            // 1. Нова позиція в межах сітки
            // 2. Є достатньо енергії
            if is_valid_position(new_x, new_y) && energy >= ENERGY_PER_MOVE {
                // Оновлюємо позицію
                pos_x = new_x;
                pos_y = new_y;
                
                // Оновлюємо напрямок (для відображення)
                direction = match (dx, dy) {
                    (0, -1) => 0,  // Рух вгору = Північ
                    (1, 0) => 1,   // Рух вправо = Схід
                    (0, 1) => 2,   // Рух вниз = Південь
                    (-1, 0) => 3,  // Рух вліво = Захід
                    _ => direction, // Не змінюємо
                };
                
                // Витрачаємо енергію на рух
                energy = energy.saturating_sub(ENERGY_PER_MOVE);
                
                // Оновлюємо статистику
                total_distance += 1;
            }
            // Якщо не можемо зробити крок — просто чекаємо
        }
        // Якщо вже на цілі — нічого не робимо (чекаємо наступного рішення)
```

**Що робить цей код:**

1. **Зарядка:** Якщо `is_charging == true`, додаємо `ENERGY_CHARGE_RATE` (10%) до енергії. Метод `.min(MAX_ENERGY)` гарантує, що не перевищимо 100%.

2. **Рух:** Якщо агент не на цілі:
   - Обчислюємо напрямок `(dx, dy)` за допомогою `direction_to`
   - Обчислюємо нові координати
   - Перевіряємо валідність нової позиції і наявність енергії
   - Якщо все OK — оновлюємо позицію, напрямок, витрачаємо енергію

3. **На місці:** Якщо вже на цілі, нічого не робимо — наступна ітерація циклу прийме нове рішення.

### 6.6.5 Вивід статусу та перевірка завершення

Наостанок виводимо поточний стан і перевіряємо, чи час завершувати симуляцію.

```rust
        // ─────────────────────────────────────────────────────────
        // ВИВІД СТАТУСУ
        // Виводимо не кожен цикл, щоб не засмічувати консоль.
        // ─────────────────────────────────────────────────────────
        
        // Визначаємо, чи це "важлива" подія
        let is_important = poi_detected              // Знайшли POI
            || is_charging                           // Заряджаємось
            || at_waypoint                           // Досягли waypoint
            || (is_returning && !is_charging)        // Повертаємось
            || cycle == 1;                           // Перший цикл
        
        // Виводимо кожні 5 циклів або при важливих подіях
        if cycle % 5 == 0 || is_important {
            print_status(cycle, pos_x, pos_y, energy, direction, action);
        }
        
        // ─────────────────────────────────────────────────────────
        // ПЕРЕВІРКА ЗАВЕРШЕННЯ
        // Місія завершується після 2 повних обходів периметра.
        // ─────────────────────────────────────────────────────────
        
        if current_waypoint == 0        // Прямуємо до першого waypoint (база)
           && at_waypoint               // І вже там
           && total_distance > 0        // І пройшли якусь відстань
           && !is_returning             // І це не повернення для зарядки
        {
            // Периметр = (ширина + висота) * 2 - 4 (кути рахуються двічі)
            let perimeter = ((GRID_WIDTH + GRID_HEIGHT) * 2 - 4) as u32;
            
            // Перевіряємо, чи пройшли 2 повних обходи
            if total_distance >= perimeter * 2 {
                println!("\n✅ Два повних обходи периметра завершено!");
                break 'simulation;
            }
        }
    }  // Кінець головного циклу
```

---

## 6.7 ЗАПУСК ТА РЕЗУЛЬТАТИ

### 6.7.1 Як запустити симуляцію

1. Створіть новий проєкт:
```bash
cargo new patrol_agent
cd patrol_agent
```

2. Скопіюйте весь код у файл `src/main.rs`

3. Запустіть:
```bash
cargo run
```

### 6.7.2 Приклад виводу

```text
╔══════════════════════════════════════════════════════════════╗
║          СИМУЛЯЦІЯ АГЕНТА-ПАТРУЛЬНОГО v1.0                   ║
╚══════════════════════════════════════════════════════════════╝

📍 Агент ініціалізовано на позиції (0, 0)
🧭 Напрямок: Схід →
🔋 Енергія: 100%

════════════════════════════════════════════════════════════════
  🚀 ЗАПУСК ПАТРУЛЮВАННЯ
════════════════════════════════════════════════════════════════

[   1] 📍( 1, 0) → 🔋[█████████░]  97% | 🚶 Патрулювання
[   5] 📍( 5, 0) → 🔋[█████████░]  89% | 🚶 Патрулювання
[  10] 📍(10, 0) → 🔋[████████░░]  79% | 🚶 Патрулювання
[  15] 📍(15, 0) → 🔋[███████░░░]  69% | 🚶 Патрулювання
[  19] 📍(19, 0) → 🔋[██████░░░░]  61% | 🎯 Waypoint досягнуто, наступна ціль
[  20] 📍(19, 1) ↓ 🔋[██████░░░░]  58% | 🚶 Патрулювання
    🔍 POI ВИЯВЛЕНО на (19, 3)!
[  22] 📍(19, 3) ↓ 🔋[█████░░░░░]  54% | 🚶 Патрулювання
...
[  45] 📍( 8, 0) ← 🔋[██░░░░░░░░]  20% | ⚠️  Низька енергія! Повернення на базу
[  50] 📍( 3, 0) ← 🔋[█░░░░░░░░░]  10% | 🔙 Повертаємось на базу
[  53] 📍( 0, 0) ← 🔋[█░░░░░░░░░]   4% | 🏠 На базі, початок зарядки
[  54] 📍( 0, 0) ← 🔋[█░░░░░░░░░]  14% | 🔌 Зарядка...
[  55] 📍( 0, 0) ← 🔋[██░░░░░░░░]  24% | 🔌 Зарядка...
...
[  63] 📍( 8, 0) → 🔋[██████████] 100% | ⚡ Зарядка завершена, продовження патрулювання
...

✅ Два повних обходи периметра завершено!

╔══════════════════════════════════════════════════════════════╗
║                    📋 ПІДСУМОК МІСІЇ                         ║
╠══════════════════════════════════════════════════════════════╣
║  Циклів виконано:         156                                ║
║  Пройдена відстань:       132 клітинок                       ║
║  Виявлено POI:              4                                ║
║  Циклів зарядки:            2                                ║
║  Залишок енергії:          45%                               ║
╚══════════════════════════════════════════════════════════════╝
```

---

## 6.8 ЛАБОРАТОРНА РОБОТА

### Завдання

Модифікуйте симуляцію одним із способів:

**Варіант A:** Додайте перешкоди на сітці, які агент обходить.

**Варіант B:** Реалізуйте "забирання" POI — агент підбирає знайдені точки.

**Варіант C:** Додайте другого агента з іншим маршрутом.

### Критерії оцінювання

| Критерій | Бали |
|----------|------|
| Коректна реалізація | 4 |
| Код компілюється | 2 |
| Логування змін | 2 |
| Коментарі | 2 |
| **Максимум** | **10** |

---

## 📝 РЕЗЮМЕ

Ви створили повноцінну симуляцію автономного агента! Це завершує Частину 0.

У **Частині I** ви дізнаєтесь про:
- **Ownership** — як Rust керує пам'яттю
- **Struct** — власні типи замість купи змінних
- **Enum** — типобезпечні стани агента

---

> **Наступний розділ:** [Розділ 7: Ownership — Концепція володіння](./07_Ownership.md)
