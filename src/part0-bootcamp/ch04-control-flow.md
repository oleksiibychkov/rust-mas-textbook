# Розділ 4: Керування потоком виконання

---

## 📋 Анотація

Логіка прийняття рішень — це серце будь-якого агента. Без неї агент — просто статичний набір даних. У цьому розділі ви опануєте всі інструменти Rust для керування потоком виконання: умовні конструкції `if/else`, потужний оператор `match` для pattern matching, та три види циклів. Особлива увага буде приділена тому, як ці конструкції працюють як **expressions** — повертаючи значення. У контексті нашого агента БПЛА ви реалізуєте повноцінний цикл **"сприйняття-рішення-дія"** (Sense-Decide-Act), що є фундаментальним патерном автономних систем.

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Використовувати if/else** для прийняття рішень
2. **Застосовувати match** для обробки багатьох варіантів
3. **Писати цикли** loop, while та for
4. **Керувати потоком** через break та continue
5. **Реалізовувати патерн Sense-Decide-Act** для агента

---

## 📚 Ключові терміни

| Термін | Визначення |
|--------|------------|
| **умовний вираз** | Конструкція, що виконує код залежно від умови |
| **pattern matching** | Порівняння значення з набором шаблонів |
| **exhaustive matching** | Вимога покрити всі можливі варіанти в match |
| **loop** | Нескінченний цикл, що виходить через break |
| **while** | Цикл, що виконується поки умова true |
| **for** | Цикл ітерації по елементах колекції |
| **range** | Діапазон значень (1..10 або 1..=10) |
| **break** | Вихід з циклу |
| **continue** | Перехід до наступної ітерації |

---

## 💡 Мотиваційний кейс: Автопілот дрона

Уявіть, що ви програмуєте автопілот. Кожну мілісекунду система має:

1. **Сприйняти** — прочитати дані сенсорів
2. **Вирішити** — обрати дію на основі стану
3. **Виконати** — надіслати команди

Це **нескінченний цикл**. Але всередині — складна логіка:

```text
ЯКЩО батарея < 10% ТО
    терміново повертатись
ІНАКШЕ ЯКЩО виявлено перешкоду ТО
    обійти перешкоду
ІНАКШЕ ЯКЩО досягнуто цілі ТО
    виконати завдання
ІНАКШЕ
    продовжувати рух
```

Без правильних інструментів цей код перетвориться на кошмар вкладених if/else. Rust надає елегантні рішення: `match` для багатьох варіантів, `loop` з `break` для головного циклу, `for` для обробки списків.

---

## 4.1 ТЕОРІЯ: УМОВНІ КОНСТРУКЦІЇ IF/ELSE

### 4.1.1 Що таке умовна конструкція

**Умовна конструкція** — це спосіб виконати різний код залежно від умови. Це як розгалуження дороги: залежно від ситуації ви їдете ліворуч або праворуч.

**Візуалізація:**

```text
                    ┌─── умова ───┐
                    │             │
                    ▼             ▼
                  TRUE         FALSE
                    │             │
                    ▼             ▼
              ┌─────────┐   ┌─────────┐
              │  код A  │   │  код B  │
              └─────────┘   └─────────┘
                    │             │
                    └──────┬──────┘
                           ▼
                    продовження
```

### 4.1.2 Базовий синтаксис if

**Найпростіша форма:**

```rust
if умова {
    // код виконується, якщо умова true
}
```

**Приклад:**

```rust
fn main() {
    let battery = 15;
    
    if battery < 20 {
        println!("⚠️ Увага: низький рівень батареї!");
    }
    
    println!("Програма продовжується...");
}
```

**Що відбувається при виконанні:**

1. Перевіряється умова `battery < 20` (15 < 20 = **true**)
2. Оскільки умова true, виконується код у фігурних дужках
3. Виводиться попередження
4. Виконання продовжується після if

**Результат:**
```text
⚠️ Увага: низький рівень батареї!
Програма продовжується...
```

**Якби battery було 50:**
```text
Програма продовжується...
```
Код у фігурних дужках просто пропускається.

### 4.1.3 if/else: два варіанти

Коли потрібно виконати один код при true і інший при false:

```rust
fn main() {
    let battery = 75;
    
    if battery > 50 {
        println!("✓ Батарея в нормі");
    } else {
        println!("⚠️ Батарея низька");
    }
}
```

**Що відбувається:**

1. Перевіряється `battery > 50` (75 > 50 = **true**)
2. Виконується гілка `if` (перший блок)
3. Гілка `else` **пропускається**

**Результат:**
```text
✓ Батарея в нормі
```

**Візуалізація потоку:**

```text
battery = 75
    │
    ▼
battery > 50?
    │
  TRUE ─────────► println!("✓ Батарея в нормі")
    │                          │
    │                          ▼
    │                    (else пропущено)
    │                          │
    └──────────────────────────┘
                │
                ▼
          кінець програми
```

### 4.1.4 Ланцюжок if/else if/else

Для кількох варіантів використовуємо ланцюжок:

```rust
fn main() {
    let battery = 35;
    
    if battery > 80 {
        println!("🔋 Відмінний заряд");
    } else if battery > 50 {
        println!("🔋 Нормальний заряд");
    } else if battery > 20 {
        println!("🪫 Низький заряд");
    } else {
        println!("⚠️ Критичний заряд!");
    }
}
```

**Як працює ланцюжок:**

| Крок | Перевірка | Результат | Дія |
|------|-----------|-----------|-----|
| 1 | `35 > 80` | false | переходимо до else if |
| 2 | `35 > 50` | false | переходимо до else if |
| 3 | `35 > 20` | **true** | виконуємо цей блок |
| 4 | — | — | решта пропускається |

**Результат:**
```text
🪫 Низький заряд
```

**Важливо:** Перевірки виконуються **по порядку**, і виконується **лише перший** блок, де умова true. Решта пропускається.

### 4.1.5 Умова має бути bool

**Критична відмінність від C/JavaScript:** У Rust умова **обов'язково** має бути типу `bool`:

```rust
fn main() {
    let x = 5;
    
    // ❌ ПОМИЛКА: x має тип i32, не bool
    // if x {
    //     println!("x is truthy");
    // }
    
    // ✓ ПРАВИЛЬНО: порівняння повертає bool
    if x != 0 {
        println!("x не дорівнює нулю");
    }
    
    if x > 0 {
        println!("x додатне");
    }
}
```

**Чому це важливо:**

У C/JavaScript поширена помилка:
```c
if (x = 5) { }  // Присвоєння! Завжди true
```
замість
```c
if (x == 5) { }  // Порівняння
```

У Rust `x = 5` повертає `()`, а не число, тому компілятор одразу видасть помилку.

### 4.1.6 if як expression (найважливіше!)

**Унікальна особливість Rust:** `if/else` — це **expression**, що повертає значення!

```rust
fn main() {
    let battery = 75;
    
    // if/else як expression — результат присвоюється змінній
    let status = if battery > 50 {
        "нормальний"    // ← значення, якщо true
    } else {
        "низький"       // ← значення, якщо false
    };
    
    println!("Статус батареї: {}", status);
}
```

**Що відбувається:**

1. Перевіряється `battery > 50` (75 > 50 = true)
2. Оскільки true, значення всього `if/else` — це `"нормальний"`
3. Це значення присвоюється змінній `status`

**Результат:**
```text
Статус батареї: нормальний
```

**Порівняння з іншими мовами:**

```python
# Python — потрібен тернарний оператор
status = "нормальний" if battery > 50 else "низький"
```

```javascript
// JavaScript — тернарний оператор
const status = battery > 50 ? "нормальний" : "низький";
```

```rust
// Rust — звичайний if/else, він і є expression
let status = if battery > 50 { "нормальний" } else { "низький" };
```

### 4.1.7 Правила if як expression

**Правило 1: Обидві гілки мають повертати однаковий тип**

```rust
// ❌ ПОМИЛКА: різні типи
let value = if condition {
    5           // i32
} else {
    "текст"     // &str — НЕ ЗБІГАЄТЬСЯ!
};

// ✓ ПРАВИЛЬНО: обидві гілки — i32
let value = if condition {
    5
} else {
    10
};
```

**Правило 2: Якщо використовуємо як expression, else обов'язковий**

```rust
// ❌ ПОМИЛКА: немає else
let value = if condition {
    5
};  // Що буде value, якщо condition = false?

// ✓ ПРАВИЛЬНО: є else
let value = if condition {
    5
} else {
    0
};
```

**Правило 3: Без крапки з комою всередині гілок**

```rust
let value = if condition {
    5       // ← БЕЗ крапки з комою — це значення
} else {
    10      // ← БЕЗ крапки з комою — це значення
};          // ← Крапка з комою ПІСЛЯ всього виразу
```

---

## 4.2 ТЕОРІЯ: MATCH — ПОТУЖНИЙ PATTERN MATCHING

### 4.2.1 Що таке match

`match` — це конструкція для порівняння значення з набором **шаблонів** (patterns). Це як розширений switch з інших мов, але набагато потужніший.

**Візуалізація:**

```text
        значення
           │
           ▼
    ┌──────────────┐
    │    match     │
    └──────┬───────┘
           │
    ┌──────┼──────┬──────┬──────┐
    ▼      ▼      ▼      ▼      ▼
шаблон1 шаблон2 шаблон3 шаблон4  _
    │      │      │      │      │
    ▼      ▼      ▼      ▼      ▼
  код1   код2   код3   код4  код_default
```

### 4.2.2 Базовий синтаксис match

```rust
fn main() {
    let agent_type = 'S';
    
    let description = match agent_type {
        'S' => "Розвідник (Scout)",
        'C' => "Бойовий (Combat)",
        'T' => "Транспорт (Transport)",
        'E' => "РЕБ (Electronic Warfare)",
        _ => "Невідомий тип",
    };
    
    println!("Тип агента: {}", description);
}
```

**Розбір синтаксису:**

```rust
match agent_type {         // ← значення для порівняння
    'S' => "Розвідник",    // ← шаблон => результат
    'C' => "Бойовий",      // ← ще один варіант
    _ => "Невідомий",      // ← _ означає "все інше"
}
```

**Що відбувається:**

1. Rust бере значення `agent_type` ('S')
2. Порівнює з першим шаблоном 'S' — **збіг!**
3. Повертає відповідне значення `"Розвідник (Scout)"`
4. Решта шаблонів не перевіряється

**Результат:**
```rust
Тип агента: Розвідник (Scout)
```

### 4.2.3 Exhaustive matching: покриття всіх варіантів

**Ключова особливість:** match **вимагає** покрити ВСІ можливі значення!

```rust
fn main() {
    let number: u8 = 5;
    
    // ❌ ПОМИЛКА: не покриті всі 256 значень u8
    // let result = match number {
    //     0 => "нуль",
    //     1 => "один",
    // };
    
    // ✓ ПРАВИЛЬНО: _ покриває все інше
    let result = match number {
        0 => "нуль",
        1 => "один",
        _ => "більше одиниці",
    };
    
    println!("{}", result);
}
```

**Чому це важливо для агента:**

```rust
// Компілятор ЗМУСИТЬ вас обробити всі варіанти!
let action = match agent_state {
    State::Idle => idle_action(),
    State::Moving => continue_moving(),
    State::Attacking => attack_target(),
    // Якщо забудете якийсь стан — ПОМИЛКА компіляції!
};
```

Це запобігає багам типу "забув обробити новий стан".

### 4.2.4 Match з кількома шаблонами

Можна об'єднати кілька шаблонів через `|`:

```rust
fn main() {
    let day = 3;
    
    let day_type = match day {
        1 | 7 => "вихідний",           // 1 АБО 7
        2 | 3 | 4 | 5 | 6 => "робочий", // 2 АБО 3 АБО 4 АБО 5 АБО 6
        _ => "невідомий день",
    };
    
    println!("День {} — {}", day, day_type);
}
```

**Результат:**
```text
День 3 — робочий
```

### 4.2.5 Match з діапазонами

Для числових типів можна використовувати діапазони:

```rust
fn main() {
    let battery: u8 = 35;
    
    let status = match battery {
        0 => "розряджено",
        1..=20 => "критичний",    // від 1 до 20 включно
        21..=50 => "низький",      // від 21 до 50 включно
        51..=80 => "нормальний",   // від 51 до 80 включно
        81..=100 => "відмінний",   // від 81 до 100 включно
        _ => "помилка датчика",    // > 100 (не повинно бути)
    };
    
    println!("Батарея {}% — статус: {}", battery, status);
}
```

**Синтаксис діапазонів:**

| Синтаксис | Значення |
|-----------|----------|
| `1..=20` | від 1 до 20 **включно** |
| `1..20` | від 1 до 19 (20 НЕ включено) — НЕ працює в match! |

**Результат:**
```text
Батарея 35% — статус: низький
```

### 4.2.6 Match guards: додаткові умови

**Guard** — це додаткова умова `if` після шаблону:

```rust
fn main() {
    let battery: u8 = 25;
    let distance_to_base: u32 = 2000;
    
    let action = match battery {
        0..=15 => "екстрена посадка",
        
        // Guard: низька батарея І далеко від бази
        16..=30 if distance_to_base > 1500 => "терміново на базу",
        
        // Guard: низька батарея І близько до бази
        16..=30 if distance_to_base <= 1500 => "спокійно на базу",
        
        31..=100 => "продовжувати місію",
        
        _ => "помилка",
    };
    
    println!("Батарея {}%, відстань {} м → {}", battery, distance_to_base, action);
}
```

**Як працюють guards:**

1. Спочатку перевіряється шаблон `16..=30` — battery = 25, **збіг**
2. Потім перевіряється guard `if distance_to_base > 1500` — 2000 > 1500, **true**
3. Виконується відповідна гілка

**Результат:**
```text
Батарея 25%, відстань 2000 м → терміново на базу
```

### 4.2.7 Match як expression

Як і `if`, `match` — це **expression**:

```rust
fn main() {
    let agent_type = 'C';
    
    // match повертає значення
    let priority: u8 = match agent_type {
        'C' => 100,  // бойові — найвищий пріоритет
        'E' => 90,   // РЕБ
        'S' => 80,   // розвідники
        'T' => 50,   // транспорт
        _ => 0,
    };
    
    println!("Пріоритет агента: {}", priority);
}
```

**Результат:**
```text
Пріоритет агента: 100
```

---

## 4.3 ТЕОРІЯ: ЦИКЛИ

### 4.3.1 Навіщо потрібні цикли

**Цикл** — це спосіб виконати код багаторазово. Для агента це критично:
- Головний цикл роботи (безкінечний)
- Обробка списку цілей (для кожної цілі)
- Очікування події (поки не станеться)

### 4.3.2 Цикл loop: нескінченний цикл

`loop` створює **нескінченний** цикл. Вийти можна тільки через `break`.

```rust
fn main() {
    let mut counter = 0;
    
    loop {
        counter += 1;
        println!("Ітерація {}", counter);
        
        if counter >= 5 {
            println!("Досягнуто ліміту!");
            break;  // ← вихід з циклу
        }
    }
    
    println!("Після циклу, counter = {}", counter);
}
```

**Що відбувається:**

| Ітерація | counter | Умова `counter >= 5` | Дія |
|----------|---------|---------------------|-----|
| 1 | 1 | false | продовжуємо |
| 2 | 2 | false | продовжуємо |
| 3 | 3 | false | продовжуємо |
| 4 | 4 | false | продовжуємо |
| 5 | 5 | **true** | **break** |

**Результат:**
```text
Ітерація 1
Ітерація 2
Ітерація 3
Ітерація 4
Ітерація 5
Досягнуто ліміту!
Після циклу, counter = 5
```

### 4.3.3 loop з поверненням значення

**Унікальна особливість Rust:** `loop` може повертати значення через `break`!

```rust
fn main() {
    let mut counter = 0;
    
    // loop повертає значення
    let result = loop {
        counter += 1;
        
        if counter * counter > 100 {
            break counter;  // ← повертаємо counter
        }
    };
    
    println!("Перше число, квадрат якого > 100: {}", result);
}
```

**Що відбувається:**

| counter | counter² | > 100? | Дія |
|---------|---------|--------|-----|
| 1 | 1 | ні | продовжуємо |
| ... | ... | ні | продовжуємо |
| 10 | 100 | ні | продовжуємо |
| 11 | 121 | **так** | `break 11` |

**Результат:**
```text
Перше число, квадрат якого > 100: 11
```

### 4.3.4 Цикл while: умовний цикл

`while` виконується **поки умова true**:

```rust
fn main() {
    let mut battery = 100;
    
    println!("Початок польоту");
    
    while battery > 0 {
        println!("Батарея: {}%", battery);
        battery -= 20;  // витрачаємо 20% за крок
    }
    
    println!("Батарея розряджена! Посадка.");
}
```

**Що відбувається:**

| Ітерація | battery на початку | battery > 0? | Дія |
|----------|-------------------|--------------|-----|
| 1 | 100 | true | виконуємо, battery = 80 |
| 2 | 80 | true | виконуємо, battery = 60 |
| 3 | 60 | true | виконуємо, battery = 40 |
| 4 | 40 | true | виконуємо, battery = 20 |
| 5 | 20 | true | виконуємо, battery = 0 |
| 6 | 0 | **false** | виходимо |

**Результат:**
```text
Початок польоту
Батарея: 100%
Батарея: 80%
Батарея: 60%
Батарея: 40%
Батарея: 20%
Батарея розряджена! Посадка.
```

### 4.3.5 while vs loop

**Коли використовувати while:**
- Умова виходу відома на початку кожної ітерації
- "Виконувати, поки X"

**Коли використовувати loop:**
- Умова виходу всередині циклу
- Потрібно повернути значення
- "Виконувати вічно, вийти коли Y"

```rust
// while — умова на початку
while battery > 20 {
    fly();
}

// loop — умова всередині
loop {
    fly();
    if detect_obstacle() {
        break;
    }
}
```

### 4.3.6 Цикл for: ітерація по колекції

`for` — найчастіше використовуваний цикл. Він ітерує по **елементах**:

**Ітерація по діапазону:**

```rust
fn main() {
    // 1..5 означає 1, 2, 3, 4 (НЕ включає 5)
    println!("Діапазон 1..5:");
    for i in 1..5 {
        println!("  i = {}", i);
    }
    
    // 1..=5 означає 1, 2, 3, 4, 5 (ВКЛЮЧАЄ 5)
    println!("Діапазон 1..=5:");
    for i in 1..=5 {
        println!("  i = {}", i);
    }
}
```

**Результат:**
```rust
Діапазон 1..5:
  i = 1
  i = 2
  i = 3
  i = 4
Діапазон 1..=5:
  i = 1
  i = 2
  i = 3
  i = 4
  i = 5
```

**Ітерація по масиву:**

```rust
fn main() {
    let agents = ["SCOUT-001", "SCOUT-002", "COMBAT-001"];
    
    // По елементах
    println!("Список агентів:");
    for agent in agents {
        println!("  - {}", agent);
    }
}
```

**Результат:**
```text
Список агентів:
  - SCOUT-001
  - SCOUT-002
  - COMBAT-001
```

### 4.3.7 Корисні методи для for

**Зворотний порядок `.rev()`:**

```rust
fn main() {
    println!("Зворотний відлік:");
    for i in (1..=5).rev() {
        println!("  {}...", i);
    }
    println!("  Старт!");
}
```

**Результат:**
```text
Зворотний відлік:
  5...
  4...
  3...
  2...
  1...
  Старт!
```

**Крок `.step_by(n)`:**

```rust
fn main() {
    println!("Парні числа до 10:");
    for i in (0..=10).step_by(2) {
        println!("  {}", i);
    }
}
```

**Результат:**
```text
Парні числа до 10:
  0
  2
  4
  6
  8
  10
```

**Індекс та значення `.enumerate()`:**

```rust
fn main() {
    let targets = ["Ціль A", "Ціль B", "Ціль C"];
    
    for (index, target) in targets.iter().enumerate() {
        println!("  [{}] {}", index, target);
    }
}
```

**Результат:**
```text
  [0] Ціль A
  [1] Ціль B
  [2] Ціль C
```

### 4.3.8 break та continue

**break — вихід з циклу:**

```rust
fn main() {
    for i in 1..100 {
        if i * i > 50 {
            println!("Перше число, квадрат якого > 50: {}", i);
            break;  // виходимо з циклу
        }
    }
}
```

**continue — перехід до наступної ітерації:**

```rust
fn main() {
    println!("Непарні числа від 1 до 10:");
    for i in 1..=10 {
        if i % 2 == 0 {
            continue;  // пропускаємо парні
        }
        println!("  {}", i);
    }
}
```

**Результат:**
```text
Непарні числа від 1 до 10:
  1
  3
  5
  7
  9
```

---

## 4.4 ПРАКТИКА: ЦИКЛ АГЕНТА

### 4.4.1 Патерн Sense-Decide-Act

Класичний патерн автономного агента:

```text
┌─────────────────────────────────────────────────────────┐
│                    ГОЛОВНИЙ ЦИКЛ                        │
│                                                         │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐           │
│   │  SENSE  │───►│ DECIDE  │───►│   ACT   │           │
│   │(сприйняття)  │(рішення)│    │ (дія)  │           │
│   └─────────┘    └─────────┘    └─────────┘           │
│        ▲                              │                │
│        └──────────────────────────────┘                │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 4.4.2 Повна реалізація

```rust
fn main() {
    println!("╔════════════════════════════════════════════════╗");
    println!("║        СИМУЛЯЦІЯ АГЕНТА БПЛА                   ║");
    println!("╚════════════════════════════════════════════════╝\n");
    
    // Стан агента
    let mut battery: u8 = 100;
    let mut position_x: i32 = 0;
    let mut position_y: i32 = 0;
    let target_x: i32 = 100;
    let target_y: i32 = 100;
    let mut step = 0;
    
    // Головний цикл агента
    loop {
        step += 1;
        println!("═══ Крок {} ═══", step);
        
        // ═══ SENSE: Збір даних ═══
        let distance = calculate_distance(position_x, position_y, target_x, target_y);
        let battery_status = get_battery_status(battery);
        
        println!("📍 Позиція: ({}, {})", position_x, position_y);
        println!("🎯 Ціль: ({}, {}), відстань: {:.1}", target_x, target_y, distance);
        println!("🔋 Батарея: {}% [{}]", battery, battery_status);
        
        // ═══ DECIDE: Прийняття рішення ═══
        let action = match (battery, distance < 10.0) {
            (0..=10, _) => "АВАРІЙНА ПОСАДКА",
            (_, true) => "ЦІЛЬ ДОСЯГНУТО",
            (11..=30, _) => "ПОВЕРНЕННЯ НА БАЗУ",
            (31..=100, _) => "РУХ ДО ЦІЛІ",
            _ => "ПОМИЛКА",
        };
        
        println!("📋 Рішення: {}", action);
        
        // ═══ ACT: Виконання дії ═══
        match action {
            "ЦІЛЬ ДОСЯГНУТО" => {
                println!("✓ Місія завершена успішно!");
                break;
            }
            "АВАРІЙНА ПОСАДКА" | "ПОВЕРНЕННЯ НА БАЗУ" => {
                println!("⚠️ Завершення місії");
                break;
            }
            "РУХ ДО ЦІЛІ" => {
                // Рухаємось до цілі
                if position_x < target_x { position_x += 10; }
                if position_y < target_y { position_y += 10; }
                
                // Витрачаємо батарею
                battery = battery.saturating_sub(5);
                
                println!("→ Рух виконано\n");
            }
            _ => {
                println!("❌ Невідома дія");
                break;
            }
        }
        
        // Захист від нескінченного циклу (для демонстрації)
        if step > 20 {
            println!("⚠️ Перевищено ліміт кроків");
            break;
        }
    }
    
    println!("\n═══ КІНЕЦЬ СИМУЛЯЦІЇ ═══");
}

fn calculate_distance(x1: i32, y1: i32, x2: i32, y2: i32) -> f64 {
    let dx = (x2 - x1) as f64;
    let dy = (y2 - y1) as f64;
    (dx * dx + dy * dy).sqrt()
}

fn get_battery_status(level: u8) -> &'static str {
    match level {
        81..=100 => "відмінний",
        51..=80 => "нормальний",
        21..=50 => "низький",
        _ => "критичний",
    }
}
```

**Результат:**
```text
╔════════════════════════════════════════════════╗
║        СИМУЛЯЦІЯ АГЕНТА БПЛА                   ║
╚════════════════════════════════════════════════╝

═══ Крок 1 ═══
📍 Позиція: (0, 0)
🎯 Ціль: (100, 100), відстань: 141.4
🔋 Батарея: 100% [відмінний]
📋 Рішення: РУХ ДО ЦІЛІ
→ Рух виконано

═══ Крок 2 ═══
📍 Позиція: (10, 10)
🎯 Ціль: (100, 100), відстань: 127.3
🔋 Батарея: 95% [відмінний]
📋 Рішення: РУХ ДО ЦІЛІ
→ Рух виконано

... (продовження)

═══ Крок 10 ═══
📍 Позиція: (90, 90)
🎯 Ціль: (100, 100), відстань: 14.1
🔋 Батарея: 55% [нормальний]
📋 Рішення: РУХ ДО ЦІЛІ
→ Рух виконано

═══ Крок 11 ═══
📍 Позиція: (100, 100)
🎯 Ціль: (100, 100), відстань: 0.0
🔋 Батарея: 50% [низький]
📋 Рішення: ЦІЛЬ ДОСЯГНУТО
✓ Місія завершена успішно!

═══ КІНЕЦЬ СИМУЛЯЦІЇ ═══
```

---

## 4.5 ЛАБОРАТОРНА РОБОТА

### Мета роботи

Реалізувати повний цикл Sense-Decide-Act для патрульного агента.

### Завдання

Агент патрулює прямокутну зону, відвідуючи точки по черзі:
- Точка A (0, 0)
- Точка B (100, 0)
- Точка C (100, 100)
- Точка D (0, 100)

Агент має повернутися на базу (0, 0), якщо батарея < 30%.

### Критерії оцінювання

| Критерій | Бали |
|----------|------|
| Правильний головний цикл | 2 |
| Реалізація Sense | 2 |
| Реалізація Decide (match) | 3 |
| Реалізація Act | 2 |
| Обробка низької батареї | 1 |
| **Максимум** | **10** |

---

## 4.6 TROUBLESHOOTING

### Помилка: "unreachable pattern"

**Причина:** Шаблон ніколи не може бути досягнутий.

```rust
match x {
    _ => println!("default"),  // покриває ВСЕ
    5 => println!("п'ять"),    // ніколи не досягнеться!
}
```

**Рішення:** Поставте специфічні шаблони перед загальними.

### Помилка: "non-exhaustive patterns"

**Причина:** Не покриті всі можливі значення.

```rust
let x: u8 = 5;
match x {
    0 => "нуль",
    1 => "один",
    // Де решта 254 значень?
}
```

**Рішення:** Додайте `_ => ...` для решти випадків.

---

## 📝 РЕЗЮМЕ

### Що ви вивчили

1. **if/else** — умовне виконання, працює як expression
2. **match** — потужний pattern matching з exhaustive checking
3. **loop** — нескінченний цикл, може повертати значення
4. **while** — цикл з умовою на початку
5. **for** — ітерація по колекціях та діапазонах
6. **break/continue** — керування потоком у циклах
7. **Sense-Decide-Act** — патерн автономного агента

---

## 🔗 ЗВ'ЯЗОК З НАСТУПНИМ РОЗДІЛОМ

Ми написали багато коду, але всі дані — окремі змінні. У **Розділі 5: Прості структури даних** ви дізнаєтесь:
- Як групувати дані в масиви та кортежі
- Як працювати зі слайсами
- Як організувати дані агента компактно

---

> **Наступний розділ:** [Розділ 5: Прості структури даних](./05_Prosti_struktury.md)
