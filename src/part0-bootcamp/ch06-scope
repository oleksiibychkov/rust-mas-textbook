

# Розділ 6: Область видимості змінних у Rust

---

##  Анотація

Цей підрозділ розкриває одну з фундаментальних концепцій Rust — область видимості змінних. Ви дізнаєтесь, як фігурні дужки визначають межі існування змінної, чому внутрішній блок бачить зовнішні змінні, але не навпаки, та як Rust використовує цю концепцію для автоматичного керування пам'яттю. Область видимості — це не просто організаційний інструмент: вона безпосередньо пов'язана з системою володіння (ownership), яка робить Rust унікальною мовою. У контексті рою БПЛА ви побачите, як правильне розуміння областей видимості допомагає структурувати код агента та уникати витоків пам'яті.

---

##  Цілі навчання

Після завершення цього підрозділу ви зможете:

1. **Визначити область видимості** змінної за структурою фігурних дужок
2. **Пояснити правила доступу** між вкладеними областями видимості
3. **Передбачити момент знищення** змінної при виході з області
4. **Розрізняти затінення** від зміни значення змінної
5. **Застосовувати штучні області** для обмеження часу життя ресурсів
6. **Читати помилки компілятора** пов'язані з областю видимості
7. **Структурувати код агента** з урахуванням життєвого циклу змінних

---

##  Ключові терміни

| Термін | Визначення |
|--------|------------|
| **область видимості (scope)** | Ділянка коду, в межах якої змінна існує та доступна |
| **блок (block)** | Код, обмежений фігурними дужками `{ }` |
| **вкладена область** | Область видимості, що міститься всередині іншої |
| **зовнішня область** | Область видимості, що містить вкладену |
| **затінення (shadowing)** | Оголошення нової змінної з іменем, що вже існує у зовнішній області |
| **час життя (lifetime)** | Період від створення змінної до її знищення |
| **drop** | Автоматичне звільнення ресурсів при виході з області видимості |

---

##  Мотиваційний кейс: Витік пам'яті у марсоході

**2004 рік, поверхня Марса.** Марсохід Spirit працює вже кілька тижнів, коли раптово перестає відповідати на команди з Землі. Діагностика показує: пам'ять заповнена на 100%.

**Що сталось?**

Програмісти NASA виявили, що код для роботи з файлами не звільняв пам'ять після завершення операцій. Кожне читання даних залишало "сміття" в пам'яті. На Землі під час тестування це не помітили — програму перезапускали часто. На Марсі марсохід працював безперервно тижнями.

**Рішення?** Інженери надіслали оновлення, яке правильно звільняло ресурси після використання. Spirit продовжив роботу.

У Rust ця проблема **неможлива за дизайном**. Коли змінна виходить з області видимості, Rust автоматично звільняє всі її ресурси. Немає "забутих" звільнень пам'яті — компілятор гарантує це на етапі компіляції.

```rust
fn обробити_дані() {
    let великий_буфер = vec![0u8; 1_000_000];  // 1 МБ пам'яті
    // ... робота з буфером ...
}   // <- Rust АВТОМАТИЧНО звільняє 1 МБ тут. Завжди. Гарантовано.
```

---

## ТЕОРІЯ: ОБЛАСТЬ ВИДИМОСТІ ЗМІННИХ

### Що таке область видимості?

**Область видимості** — це ділянка програмного коду, в межах якої змінна існує, доступна для використання та займає пам'ять. Коли виконання програми виходить за межі області видимості змінної, ця змінна автоматично знищується, а пам'ять, яку вона займала, звільняється.

В Rust область видимості має особливе значення, оскільки саме вона визначає **час життя** (lifetime) змінної та момент звільнення ресурсів. Це одна з ключових концепцій, що дозволяє Rust гарантувати безпеку пам'яті без збирача сміття.

### Визначення області видимості через фігурні дужки

У Rust область видимості визначається парою фігурних дужок `{ }`. Кожна пара дужок створює нову область видимості:

```rust
fn main() {
    // Початок області видимості функції main
    
    let повідомлення = "Привіт";
    println!("{}", повідомлення);  // Змінна доступна
    
}   // Кінець області видимості — змінна "повідомлення" знищується
```

Змінна `повідомлення` народжується в момент оголошення через `let` і живе до закриваючої фігурної дужки. Після цієї дужки змінна перестає існувати.

---

### Вкладені області видимості

Області видимості можуть бути вкладеними одна в одну. Внутрішня область видимості має доступ до змінних зовнішньої, але не навпаки:

```rust
fn main() {
    let зовнішня = 100;
    
    {   // Початок внутрішньої області видимості
        let внутрішня = 200;
        
        // Тут доступні обидві змінні
        println!("Зовнішня: {}", зовнішня);   //  OK
        println!("Внутрішня: {}", внутрішня); //  OK
        
    }   // Кінець внутрішньої області — "внутрішня" знищується
    
    println!("Зовнішня: {}", зовнішня);   //  OK — ще існує
    // println!("Внутрішня: {}", внутрішня); //  ПОМИЛКА — вже не існує
}
```

Якщо розкоментувати останній рядок, компілятор видасть помилку:

```
error[E0425]: cannot find value `внутрішня` in this scope
```

Це повідомлення прямо вказує: змінна не знайдена в цій області видимості.

---

### Візуалізація вкладених областей

Уявімо області видимості як вкладені контейнери:

```
┌───────────────────────────────────────────────────┐
│  fn main() {                                      │
│      let a = 1;                                   │
│      ┌───────────────────────────────────────┐    │
│      │  {                                    │    │
│      │      let b = 2;                       │    │
│      │      ┌───────────────────────────┐    │    │
│      │      │  {                        │    │    │
│      │      │      let c = 3;           │    │    │
│      │      │      // Видимі: a, b, c   │    │    │
│      │      │  }                        │    │    │
│      │      └───────────────────────────┘    │    │
│      │      // Видимі: a, b                  │    │
│      │  }                                    │    │
│      └───────────────────────────────────────┘    │
│      // Видима: тільки a                          │
│  }                                                │
└───────────────────────────────────────────────────┘
```

**Правило:** з будь-якої точки коду видимі змінні поточної області та всіх зовнішніх (батьківських) областей.

---

### Області видимості в конструкціях керування

Кожна конструкція з фігурними дужками створює власну область видимості.

#### Умовний оператор if

```rust
fn main() {
    let температура = 25;
    
    if температура > 20 {
        let статус = "тепло";
        println!("Зараз {}", статус);
    }   // "статус" знищується тут
    
    // println!("{}", статус);  // ✗ Помилка — статус не існує
}
```

#### Цикл for

```rust
fn main() {
    let множник = 10;  // Зовнішня область
    
    for i in 1..=3 {   // Початок області циклу
        let результат = i * множник;  // "множник" доступний із зовнішньої області
        println!("{} × {} = {}", i, множник, результат);
    }   // "i" та "результат" знищуються після кожної ітерації
    
    // println!("{}", i);  // ✗ Помилка — i не існує поза циклом
}
```

Зверніть увагу: змінна `множник` оголошена зовні циклу, тому вона доступна всередині. А змінні `i` та `результат` існують лише в межах тіла циклу.

#### Цикл while

```rust
fn main() {
    let mut лічильник = 0;
    
    while лічильник < 3 {
        let повідомлення = format!("Ітерація {}", лічильник);
        println!("{}", повідомлення);
        лічильник += 1;
    }   // "повідомлення" знищується тут
    
    println!("Фінальний лічильник: {}", лічильник);  // ✓ OK — існує
}
```

#### Цикл loop

```rust
fn main() {
    let mut спроба = 0;
    
    let результат = loop {
        спроба += 1;
        let тимчасове = спроба * 2;
        
        if тимчасове > 10 {
            break тимчасове;  // Значення передається назовні
        }
    };  // "тимчасове" не існує поза циклом
    
    println!("Результат: {}", результат);  // ✓ OK
}
```

---

### Конструкція match та області видимості

Кожна гілка `match` має власну область видимості:

```rust
fn main() {
    let число = 2;
    
    match число {
        1 => {
            let опис = "один";
            println!("{}", опис);
        }   // "опис" знищується
        2 => {
            let опис = "два";  // Це ІНША змінна з такою ж назвою
            println!("{}", опис);
        }   // ця "опис" теж знищується
        _ => {
            let опис = "інше";
            println!("{}", опис);
        }
    }
    
    // "опис" не існує тут — жодна з них
}
```

---

### Функції та області видимості

Кожна функція створює повністю ізольовану область видимості. Змінні однієї функції недоступні в іншій:

```rust
fn обчислити_площу() {
    let ширина = 10;
    let висота = 5;
    let площа = ширина * висота;
    println!("Площа: {}", площа);
}

fn main() {
    обчислити_площу();
    
    // println!("{}", ширина);  // ✗ Помилка — ширина існує в іншій функції
}
```

Для передачі даних між функціями використовуються параметри та значення, що повертаються:

```rust
fn обчислити_площу(ширина: i32, висота: i32) -> i32 {
    let площа = ширина * висота;  // Локальна змінна
    площа  // Повертаємо значення
}

fn main() {
    let ш = 10;
    let в = 5;
    let результат = обчислити_площу(ш, в);
    println!("Площа: {}", результат);
}
```

---

### Затінення змінних у вкладених областях

Коли у вкладеній області оголошується змінна з тим самим іменем, що й у зовнішній, внутрішня змінна **затінює** (shadows) зовнішню:

```rust
fn main() {
    let x = 5;
    println!("Зовнішня x = {}", x);  // 5
    
    {
        let x = 10;  // Нова змінна, затінює зовнішню
        println!("Внутрішня x = {}", x);  // 10
    }   // Внутрішня x знищується
    
    println!("Знову зовнішня x = {}", x);  // 5 — оригінальна відновлюється
}
```

Результат виконання:

```
Зовнішня x = 5
Внутрішня x = 10
Знову зовнішня x = 5
```

Зовнішня змінна не змінюється — вона просто тимчасово недоступна, поки існує внутрішня з таким самим іменем.

---

### Практичне застосування: обмеження часу життя

Іноді корисно штучно створити область видимості, щоб обмежити час життя змінної та раніше звільнити ресурси:

```rust
fn main() {
    let mut дані = String::from("початкові дані");
    
    {
        let тимчасовий_буфер = String::from("тимчасові обчислення");
        // Використовуємо буфер для якоїсь роботи
        дані.push_str(" + оброблено");
    }   // тимчасовий_буфер звільняється тут — пам'ять вивільнена
    
    // Продовжуємо роботу без зайвої пам'яті
    println!("{}", дані);
}
```

---

### Область видимості у контексті агента БПЛА

Розглянемо практичний приклад з контексту нашого проєкту рою БПЛА:

```rust
fn виконати_патрулювання() {
    let маршрут = vec![(0, 0), (10, 0), (10, 10), (0, 10)];
    let mut поточна_позиція = (0, 0);
    
    for точка in &маршрут {
        // Область видимості ітерації
        let відстань = обчислити_відстань(поточна_позиція, *точка);
        let час_польоту = відстань / 5.0;  // Локальні обчислення
        
        println!("Летимо до {:?}, відстань: {:.1}, час: {:.1}с", 
                 точка, відстань, час_польоту);
        
        поточна_позиція = *точка;
    }   // "відстань" та "час_польоту" знищуються кожну ітерацію
    
    println!("Патрулювання завершено. Позиція: {:?}", поточна_позиція);
}

fn обчислити_відстань(від: (i32, i32), до: (i32, i32)) -> f64 {
    let dx = (до.0 - від.0) as f64;
    let dy = (до.1 - від.1) as f64;
    (dx * dx + dy * dy).sqrt()
}   // dx та dy знищуються при виході з функції
```

---

### Ключові правила області видимості

| Правило | Пояснення |
|---------|-----------|
| **Від `let` до `}`** | Змінна існує від оголошення до закриваючої дужки |
| **Внутрішня бачить зовнішню** | Вкладені області мають доступ до змінних батьківських областей |
| **Зовнішня не бачить внутрішню** | Після закриття блоку його змінні зникають |
| **Затінення не змінює оригінал** | Створюється нова змінна, стара тимчасово недоступна |
| **Функції ізольовані** | Змінні різних функцій ніколи не перетинаються напряму |

---

### Чому це важливо для Rust?

Область видимості в Rust — це не просто організаційна концепція. Вона безпосередньо пов'язана з системою **володіння** (ownership):

- Коли змінна виходить з області видимості, Rust автоматично викликає **drop** — звільняє пам'ять
- Це відбувається детерміновано, в точно визначений момент
- Немає потреби в збирачі сміття
- Немає витоків пам'яті

Ця концепція стане критично важливою, коли ми перейдемо до вивчення володіння та позичання у наступних розділах.

---

##  Зв'язок з наступним матеріалом

