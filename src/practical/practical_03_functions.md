# Практичне заняття 3: Функції

## Мета заняття

Після цього заняття ви зможете:
- Оголошувати власні функції
- Передавати параметри у функції
- Повертати значення з функцій
- Розуміти різницю між виразами та інструкціями
- Декомпозувати код на логічні блоки

---

## Теоретичний вступ

### Що таке функція?

Функція — це іменований блок коду, який виконує певну задачу. Функції дозволяють:
- **Повторно використовувати код** — написати один раз, викликати багато разів
- **Структурувати програму** — розбити складну задачу на прості частини
- **Абстрагувати деталі** — приховати складну логіку за простим ім'ям

Ви вже знайомі з функцією `main()` — це точка входу в програму. Тепер навчимось створювати власні функції.

### Оголошення функції

Базовий синтаксис:

```rust
fn назва_функції() {
    // тіло функції
}
```

Приклад:

```rust
fn say_hello() {
    println!("Привіт!");
}

fn main() {
    say_hello();  // Виклик функції
    say_hello();  // Можна викликати багато разів
}
```

**Конвенція іменування:** назви функцій пишуться `snake_case` — малими літерами, слова розділяються підкресленнями: `calculate_distance`, `check_battery`, `get_status`.

### Параметри функції

Параметри дозволяють передавати дані у функцію:

```rust
fn greet(name: &str) {
    println!("Привіт, {}!", name);
}

fn main() {
    greet("Олена");
    greet("Максим");
}
```

**Важливо:** у Rust тип кожного параметра **обов'язково** вказується явно. Компілятор не виводить типи параметрів автоматично.

### Кілька параметрів

```rust
fn print_coordinates(x: i32, y: i32) {
    println!("Координати: ({}, {})", x, y);
}

fn main() {
    print_coordinates(100, 250);
    print_coordinates(-50, 75);
}
```

Параметри розділяються комами. Кожен має своє ім'я та тип.

### Повернення значень

Функція може повертати значення. Тип повернення вказується після стрілки `->`:

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b  // Останній вираз без ; — це повернене значення
}

fn main() {
    let result = add(5, 3);
    println!("5 + 3 = {}", result);
}
```

**Ключовий момент:** останній вираз у функції (без крапки з комою!) автоматично повертається.

### Явне повернення з return

Можна використовувати ключове слово `return` для явного повернення:

```rust
fn add(a: i32, b: i32) -> i32 {
    return a + b;  // Явне повернення з ;
}
```

`return` зазвичай використовують для **раннього виходу** з функції:

```rust
fn check_positive(n: i32) -> bool {
    if n <= 0 {
        return false;  // Ранній вихід
    }
    // Інша логіка...
    true  // Повернення в кінці
}
```

### Вирази vs Інструкції

Це ключова концепція Rust:

**Інструкція (statement)** — виконує дію, не повертає значення. Закінчується на `;`

```rust
let x = 5;           // Інструкція
println!("Hello");   // Інструкція
```

**Вираз (expression)** — обчислює та повертає значення. НЕ закінчується на `;`

```rust
5 + 3        // Вираз, повертає 8
x * 2        // Вираз
{            // Блок — теж вираз!
    let a = 1;
    let b = 2;
    a + b    // Останній рядок без ; — значення блоку
}
```

**Приклад різниці:**

```rust
fn returns_value() -> i32 {
    5 + 3    // Вираз — повертає 8
}

fn returns_nothing() -> i32 {
    5 + 3;   // Інструкція! Додали ;
    // Помилка: функція має повернути i32, але нічого не повертає
}
```

### Блок як вираз

У Rust блок `{ }` — це вираз, що повертає значення останнього виразу:

```rust
fn main() {
    let result = {
        let a = 10;
        let b = 20;
        a + b  // Значення блоку — 30
    };
    
    println!("Результат: {}", result);  // 30
}
```

### Функція без повернення (unit type)

Якщо функція нічого не повертає, вона повертає "порожній" тип `()` (unit):

```rust
fn print_message() {
    println!("Повідомлення");
}  // Неявно повертає ()

// Еквівалентно:
fn print_message_explicit() -> () {
    println!("Повідомлення");
}
```

Зазвичай `-> ()` не пишуть явно.

### Порядок оголошення функцій

У Rust порядок оголошення функцій **не має значення**:

```rust
fn main() {
    helper();  // Можна викликати, хоча оголошено нижче
}

fn helper() {
    println!("Я допоміжна функція");
}
```

Компілятор аналізує весь файл перед компіляцією.

### Область видимості параметрів

Параметри існують тільки всередині функції:

```rust
fn print_number(x: i32) {
    println!("x = {}", x);
}  // x перестає існувати тут

fn main() {
    print_number(42);
    // println!("{}", x);  // ПОМИЛКА! x не існує тут
}
```

### Тип &str для рядків

Поки що для текстових параметрів використовуємо `&str`:

```rust
fn greet(name: &str) {
    println!("Привіт, {}!", name);
}
```

`&str` — це "посилання на рядок". Детально про посилання поговоримо пізніше. Зараз просто запам'ятайте: для текстових параметрів — `&str`.

---

## Практичні задачі

### Задача 1: Функція привітання

**Умова:** Напишіть функцію `greet_drone`, яка приймає назву дрона та виводить привітання. Викличте її для трьох різних дронів.

**Розв'язання:**

```rust
fn greet_drone(name: &str) {
    println!("=========================");
    println!("  Дрон {} активовано!", name);
    println!("  Система готова до роботи");
    println!("=========================");
}

fn main() {
    greet_drone("Alpha");
    println!();  // Порожній рядок для розділення
    
    greet_drone("Beta");
    println!();
    
    greet_drone("Gamma");
}
```

**Пояснення:**

1. `fn greet_drone(name: &str)` — оголошуємо функцію з одним параметром типу `&str`
2. Всередині функції використовуємо `name` як звичайну змінну
3. `println!()` без аргументів виводить порожній рядок
4. Функцію викликаємо тричі з різними аргументами

**Результат:**
```
=========================
  Дрон Alpha активовано!
  Система готова до роботи
=========================

=========================
  Дрон Beta активовано!
  Система готова до роботи
=========================

=========================
  Дрон Gamma активовано!
  Система готова до роботи
=========================
```

---

### Задача 2: Обчислення площі

**Умова:** Напишіть функцію `calculate_area`, яка приймає ширину та висоту прямокутника і повертає його площу. Використайте функцію для обчислення площі зони патрулювання дрона.

**Розв'язання:**

```rust
fn calculate_area(width: f64, height: f64) -> f64 {
    width * height
}

fn main() {
    // Зона патрулювання 1
    let zone1_width = 100.0;
    let zone1_height = 50.0;
    let zone1_area = calculate_area(zone1_width, zone1_height);
    
    println!("Зона 1: {}м × {}м = {} м²", zone1_width, zone1_height, zone1_area);
    
    // Зона патрулювання 2
    let zone2_width = 75.5;
    let zone2_height = 80.0;
    let zone2_area = calculate_area(zone2_width, zone2_height);
    
    println!("Зона 2: {}м × {}м = {} м²", zone2_width, zone2_height, zone2_area);
    
    // Загальна площа
    let total = zone1_area + zone2_area;
    println!("\nЗагальна площа патрулювання: {} м²", total);
}
```

**Пояснення:**

1. Функція приймає два параметри типу `f64` (дійсні числа)
2. `-> f64` вказує, що функція повертає дійсне число
3. `width * height` — це вираз (без `;`), його значення повертається
4. Результат функції присвоюємо змінним і використовуємо далі

**Результат:**
```
Зона 1: 100м × 50м = 5000 м²
Зона 2: 75.5м × 80м = 6040 м²

Загальна площа патрулювання: 11040 м²
```

---

### Задача 3: Перевірка рівня батареї

**Умова:** Напишіть функцію `is_battery_ok`, яка приймає рівень батареї (у відсотках) та мінімальний допустимий рівень. Функція повертає `true`, якщо батарея достатня, і `false` — якщо ні. Перевірте кілька дронів.

**Розв'язання:**

```rust
fn is_battery_ok(current_level: f64, minimum_level: f64) -> bool {
    current_level >= minimum_level
}

fn main() {
    const MIN_BATTERY: f64 = 20.0;  // Мінімум для польоту
    
    // Перевірка дронів
    let drone1_battery = 85.0;
    let drone2_battery = 15.0;
    let drone3_battery = 20.0;
    let drone4_battery = 19.9;
    
    println!("Мінімальний рівень батареї: {}%\n", MIN_BATTERY);
    
    println!("Дрон 1 ({}%): готовий = {}", 
             drone1_battery, 
             is_battery_ok(drone1_battery, MIN_BATTERY));
    
    println!("Дрон 2 ({}%): готовий = {}", 
             drone2_battery, 
             is_battery_ok(drone2_battery, MIN_BATTERY));
    
    println!("Дрон 3 ({}%): готовий = {}", 
             drone3_battery, 
             is_battery_ok(drone3_battery, MIN_BATTERY));
    
    println!("Дрон 4 ({}%): готовий = {}", 
             drone4_battery, 
             is_battery_ok(drone4_battery, MIN_BATTERY));
}
```

**Пояснення:**

1. Функція повертає `bool` — результат порівняння
2. `current_level >= minimum_level` — це вираз, що обчислює `true` або `false`
3. Порівняння `>=` повертає булеве значення напряму
4. Константа `MIN_BATTERY` визначена в `main` і передається як аргумент

**Результат:**
```
Мінімальний рівень батареї: 20%

Дрон 1 (85%): готовий = true
Дрон 2 (15%): готовий = false
Дрон 3 (20%): готовий = true
Дрон 4 (19.9%): готовий = false
```

---

### Задача 4: Форматування позиції

**Умова:** Напишіть функцію `format_position`, яка приймає координати x, y, z та повертає відформатований рядок виду `"(x, y, z)"`. Використайте функцію для виведення позицій кількох дронів.

**Підказка:** Для повернення рядка використовуйте тип `String` та макрос `format!`.

**Розв'язання:**

```rust
fn format_position(x: i32, y: i32, z: i32) -> String {
    format!("({}, {}, {})", x, y, z)
}

fn main() {
    // Позиції дронів
    let pos1 = format_position(100, 200, 50);
    let pos2 = format_position(-50, 150, 75);
    let pos3 = format_position(0, 0, 100);
    
    println!("=== Позиції дронів ===");
    println!("Дрон Alpha: {}", pos1);
    println!("Дрон Beta:  {}", pos2);
    println!("Дрон Gamma: {}", pos3);
    
    // Можна використовувати функцію напряму в println!
    println!("\nБаза:       {}", format_position(0, 0, 0));
}
```

**Пояснення:**

1. `format!` — макрос, схожий на `println!`, але замість виведення **повертає String**
2. `-> String` — функція повертає володіючий рядок (не `&str`)
3. `format!("({}, {}, {})", x, y, z)` створює рядок з підставленими значеннями
4. Результат `format!` — це вираз, тому його можна одразу повернути

**Результат:**
```
=== Позиції дронів ===
Дрон Alpha: (100, 200, 50)
Дрон Beta:  (-50, 150, 75)
Дрон Gamma: (0, 0, 100)

База:       (0, 0, 0)
```

---

## Додаткові приклади

### Функція з кількома return

```rust
fn get_battery_status(level: f64) -> &'static str {
    if level >= 80.0 {
        return "Відмінно";
    }
    if level >= 50.0 {
        return "Добре";
    }
    if level >= 20.0 {
        return "Низький";
    }
    "Критичний"  // Останнє значення без return і ;
}

fn main() {
    println!("100%: {}", get_battery_status(100.0));
    println!("65%:  {}", get_battery_status(65.0));
    println!("25%:  {}", get_battery_status(25.0));
    println!("10%:  {}", get_battery_status(10.0));
}
```

**Примітка:** `&'static str` — це рядковий літерал. Поки що просто використовуйте цей тип для повернення текстових констант.

### Функції, що викликають інші функції

```rust
fn square(x: f64) -> f64 {
    x * x
}

fn distance(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    (square(dx) + square(dy)).sqrt()
}

fn main() {
    let d = distance(0.0, 0.0, 3.0, 4.0);
    println!("Відстань: {}", d);  // 5.0
}
```

### Функція з блоком як виразом

```rust
fn calculate_flight_time(distance: f64, speed: f64) -> (f64, i32, i32) {
    let total_seconds = distance / speed;
    
    let minutes_and_seconds = {
        let total = total_seconds as i32;
        let mins = total / 60;
        let secs = total % 60;
        (mins, secs)  // Значення блоку — кортеж
    };
    
    (total_seconds, minutes_and_seconds.0, minutes_and_seconds.1)
}

fn main() {
    let (seconds, mins, secs) = calculate_flight_time(1500.0, 10.0);
    println!("Час польоту: {} сек ({} хв {} сек)", seconds, mins, secs);
}
```

---

## Типові помилки та їх виправлення

### Помилка 1: Забутий тип параметра

```rust
fn greet(name) {  // ПОМИЛКА! Не вказано тип
    println!("Привіт, {}!", name);
}
```

**Повідомлення:**
```
error: expected one of `:`, `@`, or `|`, found `)`
```

**Виправлення:** Завжди вказуйте тип: `fn greet(name: &str)`

### Помилка 2: Крапка з комою після поверненого виразу

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b;  // ПОМИЛКА! ; перетворює вираз на інструкцію
}
```

**Повідомлення:**
```
error[E0308]: mismatched types
  expected `i32`, found `()`
```

**Виправлення:** Видаліть `;` або використайте `return a + b;`

### Помилка 3: Неправильний тип повернення

```rust
fn get_value() -> i32 {
    "hello"  // ПОМИЛКА! Повертає &str, а не i32
}
```

**Повідомлення:**
```
error[E0308]: mismatched types
  expected `i32`, found `&str`
```

**Виправлення:** Поверніть значення правильного типу або змініть тип повернення.

### Помилка 4: Відсутній тип повернення

```rust
fn calculate() {
    5 + 3  // Обчислюємо, але функція нічого не повертає
}

fn main() {
    let result = calculate();  // ПОМИЛКА! calculate() повертає ()
}
```

**Виправлення:** Додайте `-> i32` до оголошення функції.

### Помилка 5: Неправильна кількість аргументів

```rust
fn add(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let result = add(5);  // ПОМИЛКА! Потрібно 2 аргументи
}
```

**Повідомлення:**
```
error[E0061]: this function takes 2 arguments but 1 argument was supplied
```

**Виправлення:** Передайте правильну кількість аргументів: `add(5, 3)`

---

## Домашнє завдання

### Завдання 1: Відстань між точками

**Умова:** Напишіть функцію `calculate_distance`, яка приймає координати двох точок (x1, y1) та (x2, y2) і повертає відстань між ними. Формула:

$$d = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}$$

Протестуйте функцію на кількох парах точок.

**Розв'язання:**

```rust
fn calculate_distance(x1: f64, y1: f64, x2: f64, y2: f64) -> f64 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    (dx * dx + dy * dy).sqrt()
}

fn main() {
    // Тест 1: класичний трикутник 3-4-5
    let d1 = calculate_distance(0.0, 0.0, 3.0, 4.0);
    println!("Відстань від (0,0) до (3,4): {}", d1);
    
    // Тест 2: горизонтальна лінія
    let d2 = calculate_distance(0.0, 0.0, 10.0, 0.0);
    println!("Відстань від (0,0) до (10,0): {}", d2);
    
    // Тест 3: вертикальна лінія
    let d3 = calculate_distance(5.0, 5.0, 5.0, 15.0);
    println!("Відстань від (5,5) до (5,15): {}", d3);
    
    // Тест 4: довільні точки
    let d4 = calculate_distance(1.0, 2.0, 4.0, 6.0);
    println!("Відстань від (1,2) до (4,6): {}", d4);
    
    // Практичне застосування: відстань від дрона до бази
    println!("\n=== Практичне застосування ===");
    let drone_x = 150.0;
    let drone_y = 200.0;
    let base_x = 0.0;
    let base_y = 0.0;
    
    let distance_to_base = calculate_distance(drone_x, drone_y, base_x, base_y);
    println!("Дрон: ({}, {})", drone_x, drone_y);
    println!("База: ({}, {})", base_x, base_y);
    println!("Відстань до бази: {:.2} м", distance_to_base);
}
```

**Пояснення:**

1. Функція приймає 4 параметри — координати двох точок
2. `dx` та `dy` — різниці координат
3. `dx * dx + dy * dy` — сума квадратів (теорема Піфагора)
4. `.sqrt()` — метод для обчислення квадратного кореня
5. `{:.2}` — форматування з 2 знаками після коми

**Результат:**
```
Відстань від (0,0) до (3,4): 5
Відстань від (0,0) до (10,0): 10
Відстань від (5,5) до (5,15): 10
Відстань від (1,2) до (4,6): 5

=== Практичне застосування ===
Дрон: (150, 200)
База: (0, 0)
Відстань до бази: 250.00 м
```

---

### Завдання 2: Конвертація швидкості

**Умова:** Напишіть дві функції:
- `kmh_to_ms` — конвертує км/год у м/с (поділити на 3.6)
- `ms_to_kmh` — конвертує м/с у км/год (помножити на 3.6)

Продемонструйте конвертацію в обидва боки.

**Розв'язання:**

```rust
fn kmh_to_ms(kmh: f64) -> f64 {
    kmh / 3.6
}

fn ms_to_kmh(ms: f64) -> f64 {
    ms * 3.6
}

fn main() {
    println!("=== Конвертація швидкості ===\n");
    
    // Конвертація км/год → м/с
    println!("Км/год → М/с:");
    let speeds_kmh = [36.0, 72.0, 100.0, 120.0];
    for speed in speeds_kmh {
        println!("  {} км/год = {:.2} м/с", speed, kmh_to_ms(speed));
    }
    
    // Конвертація м/с → км/год
    println!("\nМ/с → Км/год:");
    let speeds_ms = [10.0, 15.0, 20.0, 25.0];
    for speed in speeds_ms {
        println!("  {} м/с = {:.1} км/год", speed, ms_to_kmh(speed));
    }
    
    // Перевірка: туди і назад
    println!("\n=== Перевірка (туди і назад) ===");
    let original = 90.0;  // км/год
    let converted = kmh_to_ms(original);
    let back = ms_to_kmh(converted);
    println!("{} км/год → {} м/с → {} км/год", original, converted, back);
}
```

**Пояснення:**

1. `kmh / 3.6` — формула конвертації (1 м/с = 3.6 км/год)
2. `ms * 3.6` — зворотна конвертація
3. Цикл `for speed in speeds_kmh` ітерує по масиву (детальніше про цикли — в наступних заняттях)
4. Перевірка "туди і назад" показує, що конвертації коректні

**Результат:**
```
=== Конвертація швидкості ===

Км/год → М/с:
  36 км/год = 10.00 м/с
  72 км/год = 20.00 м/с
  100 км/год = 27.78 м/с
  120 км/год = 33.33 м/с

М/с → Км/год:
  10 м/с = 36.0 км/год
  15 м/с = 54.0 км/год
  20 м/с = 72.0 км/год
  25 м/с = 90.0 км/год

=== Перевірка (туди і назад) ===
90 км/год → 25 м/с → 90 км/год
```

---

### Завдання 3: Час до розряду батареї

**Умова:** Напишіть функцію `time_to_empty`, яка приймає:
- Поточний рівень батареї (%)
- Швидкість розряду (% за хвилину)

Функція повертає час у хвилинах до повного розряду. Також напишіть допоміжну функцію `format_time`, яка перетворює хвилини у формат "X год Y хв".

**Розв'язання:**

```rust
fn time_to_empty(current_level: f64, discharge_rate: f64) -> f64 {
    current_level / discharge_rate
}

fn format_time(total_minutes: f64) -> String {
    let total = total_minutes as i32;
    let hours = total / 60;
    let minutes = total % 60;
    
    if hours > 0 {
        format!("{} год {} хв", hours, minutes)
    } else {
        format!("{} хв", minutes)
    }
}

fn main() {
    println!("=== Розрахунок часу автономної роботи ===\n");
    
    // Сценарій 1: Звичайний політ
    let battery1 = 100.0;
    let rate1 = 0.5;  // 0.5% за хвилину = 200 хвилин на повний заряд
    let time1 = time_to_empty(battery1, rate1);
    println!("Режим: Звичайний політ");
    println!("Батарея: {}%, розряд: {}%/хв", battery1, rate1);
    println!("Час роботи: {:.0} хв ({})\n", time1, format_time(time1));
    
    // Сценарій 2: Інтенсивний політ
    let battery2 = 80.0;
    let rate2 = 1.2;  // 1.2% за хвилину
    let time2 = time_to_empty(battery2, rate2);
    println!("Режим: Інтенсивний політ");
    println!("Батарея: {}%, розряд: {}%/хв", battery2, rate2);
    println!("Час роботи: {:.1} хв ({})\n", time2, format_time(time2));
    
    // Сценарій 3: Режим очікування
    let battery3 = 50.0;
    let rate3 = 0.1;  // 0.1% за хвилину
    let time3 = time_to_empty(battery3, rate3);
    println!("Режим: Очікування");
    println!("Батарея: {}%, розряд: {}%/хв", battery3, rate3);
    println!("Час роботи: {:.0} хв ({})", time3, format_time(time3));
}
```

**Пояснення:**

1. `time_to_empty` — проста формула: рівень / швидкість = час
2. `format_time` конвертує хвилини у зручний формат
3. `if hours > 0` — показуємо години тільки якщо вони є
4. `format!` повертає `String`, тому тип повернення — `String`

**Результат:**
```
=== Розрахунок часу автономної роботи ===

Режим: Звичайний політ
Батарея: 100%, розряд: 0.5%/хв
Час роботи: 200 хв (3 год 20 хв)

Режим: Інтенсивний політ
Батарея: 80%, розряд: 1.2%/хв
Час роботи: 66.7 хв (1 год 6 хв)

Режим: Очікування
Батарея: 50%, розряд: 0.1%/хв
Час роботи: 500 хв (8 год 20 хв)
```

---

### Завдання 4: Статус дрона

**Умова:** Напишіть функцію `get_drone_status`, яка приймає:
- Рівень батареї (%)
- Чи є з'єднання (bool)
- Чи є GPS сигнал (bool)

Функція повертає текстовий статус:
- "READY" — якщо батарея ≥ 20%, є з'єднання і GPS
- "LOW BATTERY" — якщо батарея < 20%
- "NO CONNECTION" — якщо немає з'єднання
- "NO GPS" — якщо немає GPS
- "MULTIPLE ERRORS" — якщо кілька проблем одночасно

**Розв'язання:**

```rust
fn get_drone_status(battery: f64, has_connection: bool, has_gps: bool) -> &'static str {
    // Підраховуємо кількість проблем
    let mut problems = 0;
    
    if battery < 20.0 {
        problems += 1;
    }
    if !has_connection {
        problems += 1;
    }
    if !has_gps {
        problems += 1;
    }
    
    // Визначаємо статус
    if problems == 0 {
        "READY"
    } else if problems > 1 {
        "MULTIPLE ERRORS"
    } else if battery < 20.0 {
        "LOW BATTERY"
    } else if !has_connection {
        "NO CONNECTION"
    } else {
        "NO GPS"
    }
}

fn print_drone_status(name: &str, battery: f64, connection: bool, gps: bool) {
    let status = get_drone_status(battery, connection, gps);
    println!("{}: батарея={}%, зв'язок={}, GPS={} → [{}]",
             name, battery, connection, gps, status);
}

fn main() {
    println!("=== Перевірка статусу дронів ===\n");
    
    // Різні сценарії
    print_drone_status("Дрон-1", 85.0, true, true);   // READY
    print_drone_status("Дрон-2", 15.0, true, true);   // LOW BATTERY
    print_drone_status("Дрон-3", 50.0, false, true);  // NO CONNECTION
    print_drone_status("Дрон-4", 50.0, true, false);  // NO GPS
    print_drone_status("Дрон-5", 10.0, false, true);  // MULTIPLE ERRORS
    print_drone_status("Дрон-6", 5.0, false, false);  // MULTIPLE ERRORS
}
```

**Пояснення:**

1. Функція аналізує три умови та повертає відповідний статус
2. `&'static str` — тип для рядкових літералів
3. `let mut problems = 0` — лічильник проблем
4. `!has_connection` — оператор заперечення (NOT)
5. Допоміжна функція `print_drone_status` робить код `main` чистішим

**Результат:**
```
=== Перевірка статусу дронів ===

Дрон-1: батарея=85%, зв'язок=true, GPS=true → [READY]
Дрон-2: батарея=15%, зв'язок=true, GPS=true → [LOW BATTERY]
Дрон-3: батарея=50%, зв'язок=false, GPS=true → [NO CONNECTION]
Дрон-4: батарея=50%, зв'язок=true, GPS=false → [NO GPS]
Дрон-5: батарея=10%, зв'язок=false, GPS=true → [MULTIPLE ERRORS]
Дрон-6: батарея=5%, зв'язок=false, GPS=false → [MULTIPLE ERRORS]
```

---

## Підсумок заняття

На цьому занятті ви навчились:

1. **Оголошувати функції** за допомогою `fn`
2. **Передавати параметри** з обов'язковим зазначенням типів
3. **Повертати значення** через `->` та останній вираз без `;`
4. **Розуміти різницю** між виразами (повертають значення) та інструкціями (не повертають)
5. **Використовувати return** для раннього виходу
6. **Викликати функції** з інших функцій
7. **Форматувати рядки** за допомогою `format!`

---

## Перевірте себе

1. Як оголосити функцію, що приймає два числа і повертає їх суму?
2. Чим відрізняється `a + b` від `a + b;` в кінці функції?
3. Коли потрібно використовувати `return`?
4. Який тип використовувати для текстового параметра?
5. Чи важливий порядок оголошення функцій у файлі?
6. Що поверне функція без `->` в оголошенні?

**Відповіді:**
1. `fn add(a: i32, b: i32) -> i32 { a + b }`
2. `a + b` — вираз, значення повертається; `a + b;` — інструкція, нічого не повертає
3. Для раннього виходу з функції або коли хочете явно показати повернення
4. `&str` для вхідних параметрів
5. Ні, Rust аналізує весь файл перед компіляцією
6. `()` — unit type (порожній тип)

---

## Наступне заняття

На наступному занятті ми вивчимо **умовні оператори**: `if/else`, логічні операції та вступ до `match`. Ви навчитесь писати код, що приймає рішення залежно від умов.
