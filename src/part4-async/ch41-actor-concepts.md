# Розділ 41: Actor Model — Концептуальні основи

---

## 📋 Анотація

У попередніх розділах ви опанували async/await, Tokio runtime, канали та streams. Це потужні примітиви для асинхронного програмування. Але виникає питання: як **організувати** async код у великій системі? Як структурувати взаємодію сотень чи тисяч асинхронних компонентів? Як забезпечити відмовостійкість, коли один компонент виходить з ладу?

**Actor Model** — це архітектурний патерн, що відповідає на ці питання. Створений у 1973 році Карлом Х'юіттом для дослідження штучного інтелекту, Actor Model став основою найнадійніших розподілених систем у світі. Телефонні станції Ericsson, WhatsApp з мільярдами повідомлень, Discord з мільйонами одночасних користувачів — всі вони побудовані на ідеях Actor Model.

Ключова ідея проста: замість спільного стану та locks, система складається з **ізольованих акторів**, що спілкуються через **повідомлення**. Кожен актор — маленька автономна одиниця зі своїм приватним станом та поведінкою. Актори не можуть напряму читати чи змінювати стан інших акторів — тільки надсилати повідомлення.

Цей розділ **концептуальний** — ми зосередимось на розумінні філософії Actor Model, її переваг та обмежень. Ви побачите, чому **агент ≈ актор** — це природна відповідність, що робить Actor Model ідеальним для мультиагентних систем. Практичну реалізацію на Tokio розглянемо в наступному розділі.

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Пояснити** історію та філософію Actor Model
2. **Описати** три аксіоми поведінки актора
3. **Порівняти** Actor Model з shared state та message passing підходами
4. **Розуміти** концепцію supervision та відмовостійкості
5. **Аргументувати** чому агент природно відображається на актора
6. **Визначати** коли Actor Model є найкращим вибором

---

## 📚 Ключові терміни

| Термін | Визначення |
|--------|------------|
| **Actor** | Фундаментальна одиниця обчислення: ізольований стан + поведінка + mailbox |
| **Mailbox** | Черга вхідних повідомлень актора; обробка послідовна |
| **Behavior** | Логіка обробки повідомлень; визначає реакцію на кожен тип повідомлення |
| **Supervision** | Стратегія відновлення після збоїв; батьківський актор контролює дочірніх |
| **Let it Crash** | Філософія: не намагайся запобігти всім помилкам — нехай падає, supervisor перезапустить |
| **Location Transparency** | Акторам байдуже, чи інший актор локальний чи віддалений |
| **Fire-and-Forget** | Надсилання повідомлення без очікування відповіді |

---

## 💡 Мотиваційний кейс: WhatsApp — 2 мільярди користувачів на Erlang

2014 рік. Facebook купує WhatsApp за $19 мільярдів. На той момент WhatsApp обслуговує **450 мільйонів** активних користувачів. Командою з **35 інженерів**.

Як це можливо? Секрет — **Erlang** та **Actor Model**.

```
┌─────────────────────────────────────────────────────────────────────┐
│                    АРХІТЕКТУРА WHATSAPP                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Користувач A                               Користувач B           │
│        │                                          ▲                 │
│        ▼                                          │                 │
│   ┌─────────┐                               ┌─────────┐            │
│   │ Actor A │ ─── Повідомлення ───────────► │ Actor B │            │
│   │         │                               │         │            │
│   │ (сесія) │ ◄─── Повідомлення ─────────── │ (сесія) │            │
│   └─────────┘                               └─────────┘            │
│        │                                          │                 │
│        └────────────┬─────────────────────────────┘                │
│                     │                                               │
│                     ▼                                               │
│              ┌────────────┐                                        │
│              │ Supervisor │                                        │
│              │            │                                        │
│              │ Якщо Actor │                                        │
│              │ впаде —    │                                        │
│              │ перезапуск │                                        │
│              └────────────┘                                        │
│                                                                     │
│   Масштаб:                                                         │
│   • 1 Erlang процес (actor) на з'єднання                           │
│   • Мільйони акторів на сервер                                     │
│   • Кожен актор ~2KB пам'яті                                       │
│   • Збій одного актора не впливає на інших                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Чому Actor Model працює для WhatsApp:**

1. **Ізоляція**: Кожне з'єднання — окремий актор. Якщо один клієнт надсилає "поганий" пакет, падає тільки його актор.

2. **Масштабованість**: Актори легкі — можна мати мільйони на одному сервері.

3. **Supervision**: Якщо актор падає — supervisor автоматично перезапускає його. Користувач просто перепідключається.

4. **Простота**: Код актора послідовний, без locks та race conditions.

Сьогодні WhatsApp обслуговує **2+ мільярди** користувачів. Actor Model — не теоретична модель, а production-proven підхід.

---

## 41.1 ІСТОРІЯ ТА ФІЛОСОФІЯ ACTOR MODEL

### 41.1.1 Народження: MIT, 1973 рік

Історія Actor Model починається з **Карла Х'юітта** (Carl Hewitt) та його колег у MIT. У 1973 році вони опублікували статтю "A Universal Modular ACTOR Formalism for Artificial Intelligence". Контекст важливий: це були роки, коли дослідники штучного інтелекту шукали нові моделі обчислень для представлення "розумних агентів".

Х'юітт шукав модель, де:
- **Автономні агенти** можуть діяти незалежно
- **Комунікація** відбувається через повідомлення, не через спільну пам'ять
- **Паралелізм** є природним, а не "приклеєним" до послідовної моделі

Результат — Actor Model, де кожен **актор** — це автономна сутність зі своїм станом, що реагує на повідомлення.

### 41.1.2 Три аксіоми актора

Х'юітт сформулював три фундаментальні аксіоми — що актор **може робити**, отримавши повідомлення:

**Аксіома 1: Надіслати скінченну кількість повідомлень іншим акторам**

Актор знає "адреси" інших акторів і може надіслати їм повідомлення. Ці адреси можуть бути отримані з вхідного повідомлення, відомі заздалегідь, або належати новоствореним акторам.

```
┌─────────┐     повідомлення      ┌─────────┐
│ Actor A │ ──────────────────────► Actor B │
└─────────┘                       └─────────┘
     │                                  
     │         повідомлення      ┌─────────┐
     └────────────────────────────► Actor C │
                                 └─────────┘
```

**Аксіома 2: Створити скінченну кількість нових акторів**

Актор може "народжувати" нових акторів. Це основа масштабованості: якщо роботи забагато — створи більше workers.

```
┌─────────┐
│ Actor A │
└────┬────┘
     │ spawn
     ├──────────► ┌─────────┐
     │            │ Actor B │
     │            └─────────┘
     │ spawn
     └──────────► ┌─────────┐
                  │ Actor C │
                  └─────────┘
```

**Аксіома 3: Визначити поведінку для обробки наступного повідомлення**

Актор може змінити свій внутрішній стан або навіть логіку обробки. Наступне повідомлення буде оброблено з урахуванням цих змін.

```
Повідомлення 1                  Повідомлення 2
      │                               │
      ▼                               ▼
┌───────────────┐             ┌───────────────┐
│ Actor         │             │ Actor         │
│               │  змінює     │               │
│ State: A      │ ──────────► │ State: B      │
│ Mode: Normal  │   себе      │ Mode: Alert   │
└───────────────┘             └───────────────┘
```

Ці три прості аксіоми створюють надзвичайно гнучку та потужну модель обчислень.

### 41.1.3 Erlang: від теорії до production

Теорія Actor Model залишалась переважно академічною до **1986 року**, коли шведська компанія **Ericsson** почала розробку мови **Erlang** для телекомунікаційних систем.

**Вимоги Ericsson були екстремальними:**

| Вимога | Значення |
|--------|----------|
| Доступність | 99.9999% ("шість дев'яток") = 32 секунди downtime на рік |
| Відмовостійкість | Система має працювати навіть якщо частини виходять з ладу |
| Hot Code Upgrade | Оновлення коду без зупинки системи |
| Масштабованість | Мільйони одночасних з'єднань |

Actor Model ідеально відповідала цим вимогам. В Erlang актори називаються **процесами** (не плутати з процесами ОС):

- **Легкі**: 2KB пам'яті на процес, мільйони на одній машині
- **Ізольовані**: Повна ізоляція — збій одного не впливає на інших
- **Комунікація через повідомлення**: Ніякого shared state
- **"Let it Crash"**: Нехай падає — supervisor перезапустить

Телефонні станції Ericsson на базі Erlang працюють **десятиліттями** з мінімальним downtime.

### 41.1.4 Філософія "Let it Crash"

Одна з найважливіших ідей Erlang — **"Let it Crash"** (нехай падає). Це контрінтуїтивно: замість того, щоб намагатись обробити всі можливі помилки, ми дозволяємо процесу впасти.

**Традиційний підхід (defensive programming):**

```
function process_request(data) {
    if (!validate(data)) {
        log_error("Invalid data");
        return error;
    }
    if (!check_permissions()) {
        log_error("No permissions");
        return error;
    }
    try {
        result = do_work(data);
    } catch (e) {
        log_error(e);
        cleanup();
        return error;
    }
    if (!save_result(result)) {
        log_error("Save failed");
        rollback();
        return error;
    }
    return ok;
}
```

Код засмічений обробкою помилок. Легко пропустити edge case.

**Erlang підхід (Let it Crash):**

```erlang
process_request(Data) ->
    validate(Data),
    check_permissions(),
    Result = do_work(Data),
    save_result(Result).
```

Якщо щось піде не так — процес впаде. **Supervisor** помітить це і перезапустить процес у чистому стані. Код чистий, зрозумілий, сфокусований на "happy path".

**Чому це працює:**

1. **Ізоляція**: Падіння одного процесу не впливає на інших
2. **Supervisor**: Автоматичне відновлення
3. **Чистий стан**: Після перезапуску процес у відомому хорошому стані
4. **Швидкість відновлення**: Мілісекунди, не хвилини

### 41.1.5 Сучасні реалізації Actor Model

Actor Model знайшла втілення в багатьох мовах та фреймворках:

| Платформа | Мова | Особливості | Використання |
|-----------|------|-------------|--------------|
| **Erlang/OTP** | Erlang | Оригінал, production-proven | Telecom, messaging |
| **Akka** | Scala/Java | Typed actors, clustering | JVM enterprise |
| **Orleans** | C# | "Virtual actors", Microsoft | Games, Azure |
| **Actix** | Rust | Високопродуктивний, async | Web services |
| **Proto.Actor** | Go, C#, Kotlin | Cross-platform | Microservices |
| **Tokio (вручну)** | Rust | Патерн, не фреймворк | Будь-що |

Для нашого підручника ми реалізуємо Actor Model **вручну на Tokio**. Це дає найкраще розуміння механізмів та максимальну гнучкість.

---

## 41.2 АНАТОМІЯ АКТОРА: БУДОВА ТА ГАРАНТІЇ

### 41.2.1 П'ять компонентів актора

Кожен актор складається з п'яти ключових компонентів:

```
┌──────────────────────────────────────────────────────────────────────┐
│                           ACTOR                                       │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │ 1. IDENTITY (Ідентичність)                                     │  │
│  │    • Унікальна адреса актора                                   │  │
│  │    • Може бути локальною або мережевою                         │  │
│  │    • Інші актори використовують адресу для надсилання          │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │ 2. MAILBOX (Поштова скринька)                                  │  │
│  │    • Черга вхідних повідомлень                                 │  │
│  │    • FIFO порядок (зазвичай)                                   │  │
│  │    • Може бути bounded або unbounded                           │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼                                       │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │ 3. BEHAVIOR (Поведінка)                                        │  │
│  │    • Логіка обробки повідомлень                                │  │
│  │    • Pattern matching на тип повідомлення                      │  │
│  │    • Може змінюватись з часом                                  │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                              │                                       │
│                              ▼                                       │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │ 4. STATE (Стан)                                                │  │
│  │    • Приватні дані актора                                      │  │
│  │    • Недоступні ззовні — тільки через повідомлення             │  │
│  │    • Змінюється тільки актором                                 │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                                                                      │
│  ┌────────────────────────────────────────────────────────────────┐  │
│  │ 5. CHILDREN (Дочірні актори)                                   │  │
│  │    • Актори, створені цим актором                              │  │
│  │    • Формують ієрархію supervision                             │  │
│  │    • Батько відповідає за долю дітей                           │  │
│  └────────────────────────────────────────────────────────────────┘  │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

### 41.2.2 Послідовна обробка: ключова гарантія

Це **найважливіша властивість** Actor Model: актор обробляє **одне повідомлення за раз**. Не існує паралельного доступу до стану актора.

```
Mailbox:    [Msg1] [Msg2] [Msg3] [Msg4] [Msg5]
                │
                ▼
Обробка:   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐   ┌─────┐
           │Msg1 │ → │Msg2 │ → │Msg3 │ → │Msg4 │ → │Msg5 │
           └─────┘   └─────┘   └─────┘   └─────┘   └─────┘
              │         │         │         │         │
              ▼         ▼         ▼         ▼         ▼
State:      [S0] →   [S1]   → [S2]   → [S3]   → [S4]   → [S5]
```

**Що це означає для розробника:**

1. **Немає гонок даних всередині актора**: Неможливо мати два потоки, що одночасно змінюють стан актора.

2. **Немає потреби в locks**: Оскільки доступ до стану послідовний, синхронізація не потрібна.

3. **Простіший код**: Можна думати послідовно, як у звичайній функції.

4. **Передбачуваність**: Легше тестувати та debug'ати.

**Приклад мислення:**

```
Без Actor Model (shared state):
─────────────────────────────────
Thread 1: read counter  ─┐
Thread 2: read counter   ├─► Race condition!
Thread 1: write counter+1─┤     Хто перший?
Thread 2: write counter+1─┘     Результат непередбачуваний

З Actor Model:
─────────────
Msg1: Increment ──► Actor ──► counter = 1
Msg2: Increment ──► Actor ──► counter = 2
Msg3: Increment ──► Actor ──► counter = 3

Послідовно, передбачувано, без сюрпризів
```

### 41.2.3 Асинхронність повідомлень: Fire-and-Forget

Надсилання повідомлення в Actor Model — **асинхронна** операція. Відправник не чекає:

```
┌─────────┐                                      ┌─────────┐
│ Actor A │                                      │ Actor B │
└────┬────┘                                      └────┬────┘
     │                                                │
     │  send(message)                                 │
     │ ─────────────────────────────────────────────► │
     │                                                │
     │  (A НЕ чекає)                          [mailbox]
     │                                                │
     │  продовжує                                     │
     │  свою роботу                                   │
     ▼                                                │
                                                      │
     (пізніше)                                        │
                                                      ▼
                                               обробка message
```

Це **fire-and-forget**: Actor A надсилає повідомлення і продовжує роботу. Він не знає:
- Коли повідомлення буде оброблено
- Чи буде воно взагалі оброблено (Actor B міг "померти")
- Який результат обробки

**Переваги fire-and-forget:**
- Висока пропускна здатність (не чекаємо)
- Decoupling (відправник не залежить від отримувача)
- Природна асинхронність

**Якщо потрібна відповідь:**

Існує патерн **request-response**, де відправник передає свою адресу (або oneshot channel), і отримувач надсилає відповідь:

```
Actor A                                Actor B
   │                                      │
   │  Request { data, reply_to: A }       │
   │ ────────────────────────────────────►│
   │                                      │
   │                               process request
   │                                      │
   │  Response { result }                 │
   │◄────────────────────────────────────│
   │                                      │
   ▼                                      ▼
```

Ми розглянемо цей патерн детально в наступному розділі.

### 41.2.4 Відсутність спільного стану: головний закон

Actor Model **категорично забороняє** спільний мутабельний стан між акторами:

```
❌ ЗАБОРОНЕНО — Shared State:
═══════════════════════════════════════════════════════════════
     
     Actor A                Actor B
         │                      │
         │    shared_memory     │
         └────────► ◄───────────┘
                    ▲
                    │
                Race conditions!
                Deadlocks!
                Heisenbugs!


✅ ПРАВИЛЬНО — Message Passing:
═══════════════════════════════════════════════════════════════

     Actor A                Actor B
     ┌─────┐                ┌─────┐
     │state│                │state│
     │  a  │                │  b  │
     └──┬──┘                └──┬──┘
        │                      │
        │    Повідомлення      │
        │   (копія даних)      │
        └─────────────────────►│
                               │
```

**Дані передаються через повідомлення.** Кожен актор має свою **копію** даних. Це може здаватись неефективним (копіювання!), але переваги переважують:

1. **Немає гонок даних**: Неможливо мати data race, якщо немає shared data
2. **Простота reasoning**: Актор контролює свій стан повністю
3. **Location transparency**: Актор може бути на іншій машині — механізм той самий
4. **Відмовостійкість**: Падіння одного актора не corrupts стан інших

---

## 41.3 ACTOR MODEL VS ІНШІ ПІДХОДИ

### 41.3.1 Підхід 1: Shared State з Locks

Традиційний підхід до паралелізму: спільна пам'ять, захищена locks (mutexes, semaphores):

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SHARED STATE + LOCKS                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│     Thread 1              Shared Data              Thread 2         │
│         │                     │                        │            │
│         │    ┌────────────────┼────────────────┐      │            │
│         │    │                ▼                │      │            │
│         │    │     ┌──────────────────┐       │      │            │
│         └────┼────►│  Mutex<HashMap>  │◄──────┼──────┘            │
│              │     └──────────────────┘       │                    │
│              │              ▲                 │                    │
│              │              │                 │                    │
│              │     lock() / unlock()         │                    │
│              │                                │                    │
│              └────────────────────────────────┘                    │
│                                                                     │
│  Проблеми:                                                         │
│  • Deadlocks (A чекає B, B чекає A)                               │
│  • Priority inversion                                              │
│  • Важко масштабувати (contention на lock)                        │
│  • Складно reasoning про коректність                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Приклад deadlock:**

```
Thread 1:                    Thread 2:
  lock(A)                      lock(B)
  lock(B)  <--- чекає          lock(A)  <--- чекає
  ...                          ...
  
  Обидва чекають вічно!
```

### 41.3.2 Підхід 2: Message Passing (канали)

Підхід, який ви вже знаєте з Tokio — канали mpsc, broadcast, тощо:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MESSAGE PASSING (CHANNELS)                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│     Task 1                                       Task 2             │
│     ┌───────┐                                   ┌───────┐          │
│     │ state │                                   │ state │          │
│     └───┬───┘                                   └───┬───┘          │
│         │                                           │               │
│         │            ┌─────────────┐               │               │
│         └───────────►│   Channel   │◄──────────────┘               │
│                      └─────────────┘                                │
│                                                                     │
│  Переваги:                                                         │
│  • Немає shared state                                              │
│  • Добра ізоляція                                                  │
│                                                                     │
│  Недоліки:                                                         │
│  • Немає структури (хто з ким спілкується?)                       │
│  • Немає supervision (хто відновлює при збої?)                    │
│  • Немає стандартних патернів                                     │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

Канали — хороший примітив, але це **занадто низький рівень** для побудови складних систем. Немає відповіді на:
- Як організувати комунікацію десятків компонентів?
- Хто відповідає за перезапуск при збої?
- Як масштабувати?

### 41.3.3 Підхід 3: Actor Model

Actor Model — це **структурований підхід** до message passing:

```
┌─────────────────────────────────────────────────────────────────────┐
│                         ACTOR MODEL                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│              ┌─────────────────────────────────┐                   │
│              │         ROOT SUPERVISOR         │                   │
│              │         (відновлення)           │                   │
│              └────────────────┬────────────────┘                   │
│                               │                                     │
│            ┌──────────────────┼──────────────────┐                 │
│            ▼                  ▼                  ▼                 │
│      ┌──────────┐       ┌──────────┐       ┌──────────┐           │
│      │ Actor A  │       │ Actor B  │       │ Actor C  │           │
│      │          │       │          │       │          │           │
│      │ [mailbox]│◄─────►│ [mailbox]│◄─────►│ [mailbox]│           │
│      │ [state]  │  msg  │ [state]  │  msg  │ [state]  │           │
│      │          │       │          │       │          │           │
│      └──────────┘       └────┬─────┘       └──────────┘           │
│                              │                                     │
│                    ┌─────────┴─────────┐                          │
│                    ▼                   ▼                          │
│              ┌──────────┐        ┌──────────┐                     │
│              │ Actor D  │        │ Actor E  │                     │
│              │ (child)  │        │ (child)  │                     │
│              └──────────┘        └──────────┘                     │
│                                                                     │
│  Структура:                                                        │
│  • Ієрархія supervision                                            │
│  • Кожен актор — ізольована одиниця                               │
│  • Комунікація через повідомлення                                  │
│  • Стандартні патерни (request-response, pub-sub)                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 41.3.4 Порівняльна таблиця підходів

| Аспект | Shared State + Locks | Channels | Actor Model |
|--------|---------------------|----------|-------------|
| **Ізоляція стану** | ❌ Ні | ✅ Так | ✅ Так |
| **Простота reasoning** | ❌ Складно | ⚠️ Середньо | ✅ Просто |
| **Масштабованість** | ❌ Lock contention | ⚠️ Вручну | ✅ Вбудована |
| **Відмовостійкість** | ❌ Cascade failures | ❌ Вручну | ✅ Supervision |
| **Структура системи** | ❌ Немає | ❌ Немає | ✅ Ієрархія |
| **Накладні витрати** | ✅ Мінімальні | ⚠️ Копіювання | ⚠️ Копіювання |
| **Коли використовувати** | Рідко | Прості сценарії | Складні системи |

---

## 41.4 SUPERVISION: ВІДМОВОСТІЙКІСТЬ ЗА ЗАМОВЧУВАННЯМ

### 41.4.1 Ієрархія supervision

В Actor Model актори організовані в **ієрархію**. Кожен актор (крім кореневого) має батька — **supervisor**. Коли дочірній актор падає, supervisor вирішує, що робити:

```
┌─────────────────────────────────────────────────────────────────────┐
│                       SUPERVISION TREE                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    ┌─────────────────────┐                         │
│                    │    Root Supervisor   │                         │
│                    │                     │                         │
│                    │  Стратегія: restart │                         │
│                    └──────────┬──────────┘                         │
│                               │                                     │
│              ┌────────────────┼────────────────┐                   │
│              │                │                │                   │
│              ▼                ▼                ▼                   │
│       ┌────────────┐   ┌────────────┐   ┌────────────┐            │
│       │   Agent    │   │ Coordinator│   │   Logger   │            │
│       │ Supervisor │   │            │   │            │            │
│       └──────┬─────┘   └────────────┘   └────────────┘            │
│              │                                                      │
│     ┌────────┼────────┐                                            │
│     │        │        │                                            │
│     ▼        ▼        ▼                                            │
│ ┌───────┐┌───────┐┌───────┐                                       │
│ │Agent 1││Agent 2││Agent 3│                                       │
│ │       ││  💥   ││       │  ← Agent 2 впав!                      │
│ └───────┘└───────┘└───────┘                                       │
│              │                                                      │
│              ▼                                                      │
│     Agent Supervisor бачить збій                                   │
│     і перезапускає Agent 2                                         │
│              │                                                      │
│              ▼                                                      │
│ ┌───────┐┌───────┐┌───────┐                                       │
│ │Agent 1││Agent 2││Agent 3│  ← Agent 2 знову працює!             │
│ └───────┘└───────┘└───────┘                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 41.4.2 Стратегії supervision

Коли дочірній актор падає, supervisor може застосувати одну зі стратегій:

**1. One-for-One (Один за одного)**

Перезапускається тільки актор, що впав. Інші не чіпаються.

```
Before:  [A] [B💥] [C]
After:   [A] [B✓]  [C]
```

Використовується, коли актори незалежні.

**2. One-for-All (Один за всіх)**

Перезапускаються всі дочірні актори.

```
Before:  [A] [B💥] [C]
After:   [A✓] [B✓] [C✓]
```

Використовується, коли актори мають спільний стан або залежності.

**3. Rest-for-One (Решта за одного)**

Перезапускається актор, що впав, і всі актори, створені після нього.

```
Before:  [A] [B💥] [C] [D]
         (створені в порядку A, B, C, D)
After:   [A] [B✓] [C✓] [D✓]
```

Використовується, коли актори мають послідовні залежності.

**4. Stop (Зупинка)**

Supervisor зупиняє всіх дочірніх акторів і сам зупиняється. Проблема ескалюється вгору.

### 41.4.3 Практичний приклад: рій з supervision

Уявімо рій БПЛА з ієрархією supervision:

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SWARM SUPERVISION TREE                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                ┌───────────────────────────────┐                   │
│                │       Mission Controller      │                   │
│                │                               │                   │
│                │  Стратегія: one-for-one      │                   │
│                │  (кожен сектор незалежний)   │                   │
│                └───────────────┬───────────────┘                   │
│                                │                                    │
│         ┌──────────────────────┼──────────────────────┐            │
│         │                      │                      │            │
│         ▼                      ▼                      ▼            │
│  ┌──────────────┐      ┌──────────────┐      ┌──────────────┐     │
│  │ Sector A     │      │ Sector B     │      │ Sector C     │     │
│  │ Supervisor   │      │ Supervisor   │      │ Supervisor   │     │
│  │              │      │              │      │              │     │
│  │ one-for-all  │      │ one-for-all  │      │ one-for-all  │     │
│  └──────┬───────┘      └──────┬───────┘      └──────┬───────┘     │
│         │                     │                     │              │
│    ┌────┴────┐           ┌────┴────┐           ┌────┴────┐        │
│    ▼         ▼           ▼         ▼           ▼         ▼        │
│ [Drone1] [Drone2]    [Drone3] [Drone4]    [Drone5] [Drone6]       │
│                                                                     │
│                                                                     │
│  Сценарій: Drone3 виходить з ладу                                  │
│  ═══════════════════════════════                                   │
│                                                                     │
│  1. Drone3 падає (втрата зв'язку, збій сенсора)                   │
│  2. Sector B Supervisor бачить збій                                │
│  3. Стратегія one-for-all: перезапускає Drone3 І Drone4           │
│     (вони координували роботу в секторі)                           │
│  4. Mission Controller НЕ чіпає сектори A і C                      │
│  5. Місія продовжується з мінімальними втратами                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

Supervision дозволяє системі **самовідновлюватись** без втручання оператора.

---

## 41.5 АГЕНТ ЯК АКТОР: ПРИРОДНА ВІДПОВІДНІСТЬ

### 41.5.1 Порівняння визначень

Порівняємо визначення агента (з теорії MAS) та актора:

**Агент (Multi-Agent Systems):**
> Автономна обчислювальна одиниця, що сприймає середовище через сенсори, приймає рішення на основі внутрішнього стану, та діє через актуатори.

**Актор (Actor Model):**
> Фундаментальна одиниця обчислення, що отримує повідомлення, обробляє їх на основі внутрішнього стану, може надсилати повідомлення, створювати нових акторів, та змінювати поведінку.

Бачите схожість? Обидва:
- **Автономні**: діють незалежно
- **Мають внутрішній стан**: приватний, ізольований
- **Комунікують через повідомлення**: perceive/act ≈ receive/send
- **Приймають рішення**: behavior/decide

### 41.5.2 Маппінг концепцій

| Концепція MAS | Концепція Actor Model |
|---------------|----------------------|
| Агент | Актор |
| Сприйняття (perceive) | Отримання повідомлення |
| Дія (act) | Надсилання повідомлення |
| Внутрішній стан | State актора |
| Beliefs/Desires/Intentions | State + Behavior |
| Середовище | Інші актори + зовнішні системи |
| Комунікація агентів | Message passing |
| Координатор | Supervisor актор |

### 41.5.3 Цикл агента як behavior актора

Класичний цикл агента perceive-decide-act природно відображається на обробку повідомлень:

```
┌─────────────────────────────────────────────────────────────────────┐
│                AGENT LOOP AS ACTOR BEHAVIOR                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│     ТРАДИЦІЙНИЙ АГЕНТ              АГЕНТ ЯК АКТОР                  │
│     ══════════════════              ══════════════                  │
│                                                                     │
│     loop {                         // Actor::handle_message         │
│         perception = perceive();   match message {                  │
│         decision = decide();           SensorData(d) => {          │
│         act(decision);                     // perceive              │
│     }                                      let decision = decide(d);│
│                                            // act                   │
│                                            send(target, decision);  │
│                                        }                            │
│                                        Command(c) => {              │
│                                            execute(c);              │
│                                        }                            │
│                                        Tick => {                    │
│                                            // periodic work         │
│                                        }                            │
│                                    }                                │
│                                                                     │
│     Блокуючий цикл                 Event-driven                    │
│     Важко масштабувати             Легко масштабувати              │
│     Важко координувати             Природна координація            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 41.5.4 Переваги Actor Model для MAS

**1. Ізоляція стану агентів**

Кожен агент — окремий актор з приватним станом. Неможливо випадково "зламати" стан іншого агента.

```
Agent 1 (Actor)           Agent 2 (Actor)
┌─────────────────┐      ┌─────────────────┐
│ beliefs: {...}  │      │ beliefs: {...}  │
│ position: (x,y) │      │ position: (x,y) │
│ battery: 80%    │      │ battery: 60%    │
└─────────────────┘      └─────────────────┘
       ╲                        ╱
        ╲   Тільки через      ╱
         ╲   повідомлення!   ╱
          ╲                 ╱
           ╲───────────────╱
```

**2. Природна комунікація**

Агенти спілкуються через повідомлення — це і є спосіб комунікації в Actor Model.

```
Agent 1: "Виявив ціль на координатах (10, 20)"
         │
         └───► broadcast ───► Agent 2, Agent 3, Coordinator
```

**3. Масштабованість**

Актори легкі — можна мати тисячі агентів без проблем.

```
1 агент = 1 актор ≈ кілька KB пам'яті
1000 агентів = 1000 акторів ≈ кілька MB пам'яті
```

**4. Відмовостійкість через supervision**

Якщо агент "падає" (помилка, втрата зв'язку), supervisor може перезапустити його.

```
Drone 5: 💥 Критична помилка!
         │
         └───► Sector Supervisor: "Перезапускаю Drone 5..."
                                    │
                                    └───► Drone 5: ✅ Відновлено
```

---

## 41.6 ПАТЕРНИ ACTOR MODEL

### 41.6.1 Request-Response

Надіслати запит і отримати відповідь:

```
┌───────────┐                              ┌───────────┐
│ Requester │                              │ Responder │
└─────┬─────┘                              └─────┬─────┘
      │                                          │
      │  Request { data, reply_to }              │
      │ ─────────────────────────────────────────►
      │                                          │
      │                                    process
      │                                          │
      │  Response { result }                     │
      │ ◄─────────────────────────────────────────
      │                                          │
      ▼                                          ▼
```

В Rust реалізується через oneshot channel у повідомленні.

### 41.6.2 Publish-Subscribe

Один публікує, багато підписані:

```
                    ┌───────────────┐
                    │   Publisher   │
                    └───────┬───────┘
                            │
                            │ Event
                            ▼
                    ┌───────────────┐
                    │    Broker     │
                    │  (optional)   │
                    └───────┬───────┘
                            │
           ┌────────────────┼────────────────┐
           │                │                │
           ▼                ▼                ▼
    ┌────────────┐   ┌────────────┐   ┌────────────┐
    │Subscriber 1│   │Subscriber 2│   │Subscriber 3│
    └────────────┘   └────────────┘   └────────────┘
```

Реалізується через broadcast channel або явний список підписників.

### 41.6.3 Router (Load Balancing)

Розподіл роботи між workers:

```
                    ┌───────────────┐
                    │    Router     │
                    │               │
                    │ Round-robin / │
                    │ Least-loaded  │
                    └───────┬───────┘
                            │
           ┌────────────────┼────────────────┐
           │                │                │
           ▼                ▼                ▼
    ┌────────────┐   ┌────────────┐   ┌────────────┐
    │  Worker 1  │   │  Worker 2  │   │  Worker 3  │
    └────────────┘   └────────────┘   └────────────┘
```

### 41.6.4 Aggregator

Збір результатів від багатьох:

```
    ┌────────────┐   ┌────────────┐   ┌────────────┐
    │  Source 1  │   │  Source 2  │   │  Source 3  │
    └──────┬─────┘   └──────┬─────┘   └──────┬─────┘
           │                │                │
           │   partial      │                │
           │   results      │                │
           └────────────────┼────────────────┘
                            │
                            ▼
                    ┌───────────────┐
                    │  Aggregator   │
                    │               │
                    │ Combine &     │
                    │ Forward       │
                    └───────────────┘
```

---

## 41.7 ОБМЕЖЕННЯ ТА КОМПРОМІСИ

### 41.7.1 Накладні витрати на повідомлення

Actor Model вимагає копіювання даних у повідомленнях:

```
┌──────────────────────────────────────────────────────────────────────┐
│                   НАКЛАДНІ ВИТРАТИ                                    │
├──────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Shared State:                                                       │
│  ─────────────                                                       │
│  Data (1MB) ◄─── Thread 1 читає                                     │
│             ◄─── Thread 2 читає                                     │
│             Ніякого копіювання!                                     │
│                                                                      │
│                                                                      │
│  Actor Model:                                                        │
│  ────────────                                                        │
│  Actor 1: Data (1MB) ───copy───► Actor 2: Data (1MB)                │
│                                                                      │
│           Копіювання 1MB на кожне повідомлення!                     │
│                                                                      │
└──────────────────────────────────────────────────────────────────────┘
```

**Рішення:**
- Передавайте посилання (`Arc<Data>`) замість копій для великих даних
- Проєктуйте маленькі повідомлення
- Використовуйте zero-copy де можливо

### 41.7.2 Складність debugging

Асинхронність та message passing ускладнюють відладку:

```
Проблема: "Чому актор не відповідає?"

Можливі причини:
1. Повідомлення не надіслано?
2. Повідомлення загубилось?
3. Актор зайнятий обробкою іншого?
4. Актор впав?
5. Черга переповнена?
6. Deadlock на рівні повідомлень?
```

**Рішення:**
- Структуроване логування (tracing)
- Таймаути на всіх операціях
- Моніторинг стану акторів
- Тестування окремих акторів

### 41.7.3 Ordering guarantees

Actor Model гарантує FIFO порядок повідомлень **від одного відправника до одного отримувача**:

```
Actor A ─── msg1 ──► Actor B    (порядок: 1, 2, 3)
        ─── msg2 ──►
        ─── msg3 ──►

Але:

Actor A ─── msg1 ──► Actor C    (порядок: невідомий)
Actor B ─── msg2 ──►

Повідомлення від різних акторів можуть прийти в будь-якому порядку!
```

### 41.7.4 Коли Actor Model — правильний вибір

**Обирайте Actor Model, коли:**

| Ситуація | Причина |
|----------|---------|
| Багато незалежних компонентів | Природна ізоляція |
| Потрібна відмовостійкість | Supervision |
| Розподілена система | Location transparency |
| Складна координація | Структуровані патерни |
| Мультиагентна система | Агент ≈ актор |

**Не обирайте Actor Model, коли:**

| Ситуація | Причина |
|----------|---------|
| Простий скрипт | Overkill, зайва складність |
| Тісно пов'язані дані | Накладні витрати на копіювання |
| Синхронні обчислення | Async overhead непотрібний |
| Критична латентність | Message passing додає затримку |

---

## 41.8 ACTOR MODEL В RUST

### 41.8.1 Чому Rust не має вбудованих акторів

На відміну від Erlang, Rust не має вбудованої підтримки Actor Model. Це свідомий вибір:

1. **Zero-cost abstractions**: Rust надає примітиви, а не нав'язує патерни
2. **Гнучкість**: Різні реалізації для різних потреб
3. **Ownership system**: Вже забезпечує ізоляцію без акторів

### 41.8.2 Підходи до реалізації

**1. Вручну на Tokio (наш підхід)**

```rust
// Actor = tokio::spawn + mpsc channel
let (tx, mut rx) = mpsc::channel(32);

tokio::spawn(async move {
    while let Some(msg) = rx.recv().await {
        // handle message
    }
});
```

**Переваги:**
- Повний контроль
- Мінімальні залежності
- Найкраще для навчання

**2. Actix**

Популярний actor framework для Rust:

```rust
use actix::prelude::*;

struct MyActor;

impl Actor for MyActor {
    type Context = Context<Self>;
}
```

**Переваги:**
- Production-ready
- Багато features
- Гарна документація

**3. Bastion**

Fault-tolerant runtime, натхненний Erlang:

```rust
use bastion::prelude::*;

Bastion::children(|children| {
    children.with_exec(|ctx| async move {
        // actor logic
    })
});
```

### 41.8.3 Чому ми обираємо "вручну"

Для навчання найкраще реалізувати акторів вручну на Tokio:

1. **Розуміння механізмів**: Бачите, як все працює "під капотом"
2. **Відсутність "магії"**: Немає прихованих абстракцій
3. **Гнучкість**: Можете адаптувати під свої потреби
4. **Перенесення знань**: Легше перейти на фреймворк пізніше

---

## 41.9 ЛАБОРАТОРНА РОБОТА

### Мета роботи

Закріпити концептуальне розуміння Actor Model через аналіз та проєктування.

### Завдання 1: Аналіз системи (4 бали)

Опишіть, як би ви змоделювали **систему керування розумним будинком** через Actor Model:

1. Які актори потрібні? (мінімум 5)
2. Які повідомлення вони обмінюються?
3. Яка ієрархія supervision?
4. Яка стратегія відновлення при збоях?

Надайте діаграму та текстовий опис.

### Завдання 2: Порівняння підходів (3 бали)

Для сценарію "Рій з 100 БПЛА патрулює територію" порівняйте:
1. Shared State + Mutex
2. Channels (mpsc)
3. Actor Model

Для кожного підходу опишіть: структуру коду, проблеми масштабування, відмовостійкість.

### Завдання 3: Патерни Actor Model (3 бали)

Для кожного сценарію визначте найкращий патерн (Request-Response, Pub-Sub, Router, Aggregator):

1. Агент запитує у координатора дозвіл на дію
2. Координатор розсилає команду всім агентам
3. 10 агентів виконують обчислення, результати збираються разом
4. Нові завдання розподіляються між вільними агентами

---

## 41.10 РЕЗЮМЕ

### Ключові концепції

**Actor Model** — архітектурний патерн, де система складається з ізольованих акторів, що спілкуються через повідомлення.

**Три аксіоми актора:**
1. Надіслати повідомлення іншим акторам
2. Створити нових акторів
3. Визначити поведінку для наступного повідомлення

**Ключові властивості:**
- Послідовна обробка повідомлень (немає гонок всередині актора)
- Асинхронність (fire-and-forget)
- Відсутність спільного стану

**Supervision** — ієрархія контролю, де батьківський актор відповідає за відновлення дочірніх.

**"Let it Crash"** — філософія: не намагайся запобігти всім помилкам, дозволь впасти і перезапусти.

### Агент ≈ Актор

| Агент | Актор |
|-------|-------|
| Автономний | Автономний |
| Має внутрішній стан | Має state |
| Perceive/Act | Receive/Send |
| Комунікація через повідомлення | Message passing |

### Коли обирати Actor Model

✅ **Обирайте:**
- Багато незалежних компонентів
- Потрібна відмовостійкість
- Мультиагентні системи
- Розподілені системи

❌ **Не обирайте:**
- Прості скрипти
- Критична латентність
- Тісно пов'язані дані

---

## 🔗 ЗВ'ЯЗОК З НАСТУПНИМ РОЗДІЛОМ

Ви зрозуміли **філософію та концепції** Actor Model. Тепер час **реалізувати** це на практиці.

У **Розділі 42: Actor Model — Реалізація на Tokio** ви:
- Побудуєте актора через `tokio::spawn` + `mpsc` channel
- Створите `ActorHandle` для зовнішньої взаємодії
- Реалізуєте патерн Request-Response через oneshot
- Імплементуєте graceful shutdown
- Перетворите агента БПЛА на актора

Від теорії — до робочого коду!

---

> **Наступний розділ:** [Розділ 42: Actor Model — Реалізація на Tokio](./42_Actor_Tokio.md)
