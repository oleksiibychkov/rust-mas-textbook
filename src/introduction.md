# РОЗУМ РОЮ

## Програмування мультиагентних систем мовою Rust

### Наскрізний проєкт: Інтелектуальний автономний рій БПЛА

---

# ВСТУП

---

## Нова парадигма: Навіщо світові потрібен Rust?

Десятиліттями інженерія програмного забезпечення існувала у світі фундаментального компромісу. Цей компроміс змушував розробників обирати між двома протилежними таборами.

**Світ Контролю (C/C++):** З одного боку — мови з ручним керуванням пам'яттю. Вони пропонують абсолютну владу: програміст вручну виділяє та звільняє пам'ять, досягаючи максимальної швидкості. Але ця влада має жахливу ціну — вона є джерелом незліченних небезпечних помилок: "висячих вказівників", "подвійного звільнення" та "витоків пам'яті".

**Світ Безпеки (Java/C#/Python):** З іншого боку — мови зі "збирачем сміття" (Garbage Collector, GC). Вони роблять програмування значно простішим і безпечнішим, оскільки автоматичний процес сам шукає і звільняє пам'ять. Але за цей комфорт ми платимо продуктивністю. GC додає фонові витрати і, що найгірше, може непередбачувано "заморозити" програму для виконання прибирання.

Здавалося, цей компроміс вічний. Або швидкість, або безпека.

### Третій шлях: Обіцянка Rust

Rust — це сучасна мова програмування, створена Mozilla Research, яка зосереджена на трьох цілях: **безпека**, **швидкість** та **паралелізм**. Вона пропонує третій шлях, який змінює правила гри.

**Ключова філософія:** Rust гарантує безпеку пам'яті під час компіляції, при цьому не маючи "збирача сміття".

Це означає, що ви отримуєте надійність і безпеку, як у Java, але зі швидкістю і контролем, як у C++. Як це можливо? Це не магія. Це фундаментальний принцип дизайну, який ми будемо називати **"філософією компілятора-наставника"**:

> Rust перетворює потенційні помилки, які в інших мовах виявляються (або не виявляються) лише під час виконання програми, на помилки, які виявляються під час компіляції.

---

## Чому Rust для мультиагентних систем?

У світі мультиагентних систем (МАС), де автономні агенти взаємодіють, обмінюються ресурсами та конкурують за спільні об'єкти, компроміс "швидкість vs безпека" стає ще більш критичним.

### Вимоги МАС до мови програмування

**1. Надійність**

Один агент не повинен "зламати" інших. У рої з 100 дронів помилка пам'яті в одному може призвести до катастрофи.

**2. Продуктивність**

Агенти часто працюють у реальному часі. Затримка в 100 мс може означати зіткнення. Пауза GC неприйнятна.

**3. Паралелізм**

Десятки, сотні, тисячі агентів працюють одночасно. Потрібна безпечна робота з потоками.

**4. Передбачуваність**

Для real-time МАС, де агенти повинні швидко реагувати на зміни середовища, непередбачувані паузи GC неприйнятні.

### Порівняння мов

```text
┌─────────────────────────────────────────────────────────────────────────┐
│                    ПОРІВНЯННЯ МОВ ДЛЯ МАС                                │
├─────────────┬─────────────┬─────────────┬─────────────┬─────────────────┤
│             │    C/C++    │   Python    │    Java     │      Rust       │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│ Швидкість   │    ★★★★★    │    ★★☆☆☆    │   ★★★☆☆     │     ★★★★★       │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│ Безпека     │    ★★☆☆☆    │    ★★★★☆    │   ★★★★☆     │     ★★★★★       │
│ пам'яті     │ (небезпечно)│   (GC)      │   (GC)      │  (компілятор)   │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│ Паралелізм  │    ★★★☆☆    │    ★★☆☆☆    │   ★★★★☆     │     ★★★★★       │
│ (безпека)   │ (data races)│   (GIL)     │   (GC)      │ (Borrow Checker)│
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│ Передбачув. │    ★★★★★    │    ★★☆☆☆    │   ★★★☆☆     │     ★★★★★       │
│ latency     │             │ (непередб.) │  (GC паузи) │  (без GC)       │
├─────────────┼─────────────┼─────────────┼─────────────┼─────────────────┤
│ Легкість    │    ★★☆☆☆    │    ★★★★★    │   ★★★★☆     │     ★★★☆☆       │
│ навчання    │             │             │             │                 │
└─────────────┴─────────────┴─────────────┴─────────────┴─────────────────┘
```

### Що Rust означає для МАС

Для МАС з тисячами агентів, що виконуються одночасно, переваги Rust критичні:

- ✅ **Агент не може отримати доступ до ресурсу, який вже звільнено**
- ✅ **Два агенти не можуть одночасно змінювати спільний ресурс** (data race)
- ✅ **Агент не може використовувати посилання на іншого агента, якого вже знищено**
- ✅ **Середовище (environment) завжди у валідному стані**
- ✅ **10,000 агентів одночасно без страху витоків пам'яті**

---

## Проблема на практиці: Розповідь про трьох користувачів

Давайте не будемо теоретизувати. Розглянемо найпростіше завдання:

**Завдання:** У нас є список користувачів. Потрібно написати функцію, яка шукає користувача за ID. Потім ми спробуємо знайти користувача, якого не існує (наприклад, з ID 99), і вивести його ім'я.

**Паралель з МАС:** Замініть "користувачів" на "агентів", і "пошук за ID" на "пошук агента для взаємодії". Це одна з найпоширеніших операцій у МАС. Що станеться, якщо агента з таким ID не існує?

Саме в цій простій задачі "знайти те, чого немає" криється фундаментальна різниця між мовами.

---

### Версія 1: Пастка на Python (Помилка часу виконання)

Python використовує спеціальне значення `None` для позначення відсутності. Проблема в тому, що програміст може легко забути перевірити це значення.

**Постановка:** Створимо клас User, список користувачів та функцію пошуку. Потім "забудемо" перевірити результат.

```python
class User:
    def __init__(self, id, name):
        self.id = id
        self.name = name

users = [User(1, "Alice"), User(2, "Bob")]

def find_user(id):
    for user in users:
        if user.id == id:
            return user
    return None  # Повертаємо "нічого", якщо не знайдено

# --- Помилка програміста ---
# Ми шукаємо ID 99, якого не існує.
user = find_user(99)

# Програміст забув перевірити, чи user не є None
print(user.name)
```

**Результат:** Програма успішно запускається, але падає під час виконання:

```text
AttributeError: 'NoneType' object has no attribute 'name'
```

**Розглянемо, що сталося:**

1. Функція `find_user(99)` не знайшла користувача і повернула `None`
2. Змінна `user` тепер містить `None`, а не об'єкт User
3. Спроба звернутися до `user.name` викликає помилку — у `None` немає атрибута `name`
4. Програма аварійно завершується

Це **runtime error** (помилка часу виконання). Вона сталася тому, що програміст покладався на власну дисципліну (пам'ятати про перевірку `is not None`), але забув це зробити.

**Сценарій МАС:** Уявіть, що агент А намагається надіслати повідомлення агенту Б, якого вже не існує. У Python-based МАС така помилка виявиться лише під час симуляції, можливо, після годин роботи. Debugging — це пошук голки в копиці сіна серед тисяч агентів.

---

### Версія 2: Катастрофа на C (Невизначена поведінка)

У C для позначення "нічого" використовують `NULL` (нульовий вказівник). Спроба звернутися до пам'яті за адресою NULL — це не просто помилка, це катастрофа.

**Постановка:** Аналогічний код на C — структура User, масив користувачів, функція пошуку.

```c
#include <stdio.h>

struct User {
    int id;
    const char* name;
};

struct User users[] = {{1, "Alice"}, {2, "Bob"}};
int user_count = 2;

struct User* find_user(int id) {
    for (int i = 0; i < user_count; i++) {
        if (users[i].id == id) {
            return &users[i];
        }
    }
    return NULL; // Повертаємо "нічого", якщо не знайдено
}

// --- Помилка програміста ---
int main() {
    // Ми шукаємо ID 99, якого не існує.
    struct User* user = find_user(99);

    // Програміст забув перевірити, чи user != NULL
    printf("%s\n", user->name); // <--- ЗБІЙ!
    return 0;
}
```

**Результат:** Програма **успішно компілюється**. Компілятор C не бачить жодної проблеми. Але під час запуску:

```rust
Segmentation Fault (порушення доступу до пам'яті)
```

**Розглянемо, що сталося:**

1. Функція `find_user(99)` повернула `NULL`
2. Змінна `user` тепер містить адресу 0 (NULL)
3. Спроба прочитати `user->name` означає спробу прочитати пам'ять за адресою 0
4. Операційна система захищає цю область пам'яті — програма аварійно завершується

Це називається **undefined behavior** (невизначена поведінка). Це найгірший тип помилок. Програма може:
- Впасти одразу (як у нашому прикладі)
- Впасти через годину роботи
- Не впасти взагалі, але мовчки псувати дані
- Створити вразливість безпеки, яку можуть використати хакери

**Сценарій МАС:** У високопродуктивних МАС на C/C++ (робототехніка, drone swarms) такий збій може означати:
- Фізичне пошкодження робота
- Втрату координації всього рою
- Непередбачувану поведінку в критичних системах

---

### Версія 3: Гарантія Rust (Безпека під час компіляції) 🛡️

Тепер подивимося, як із цим справляється Rust. У Rust **немає `null`**. Замість цього мова змушує нас використовувати спеціальний тип-контейнер `Option<T>`, який чітко говорить: "значення може бути, а може й не бути".

`Option<T>` — це enum (перелічуваний тип) з двома варіантами:
- `Some(value)` — значення є, і ось воно
- `None` — значення немає

**Постановка:** Аналогічний код на Rust — структура User, масив користувачів, функція пошуку.

```rust
struct User {
    id: i32,
    name: &'static str,
}

// Масив користувачів
static USERS: [User; 2] = [
    User { id: 1, name: "Alice" },
    User { id: 2, name: "Bob" },
];

// Функція чітко каже: "можливо, знайду користувача, а можливо — ні"
fn find_user(id: i32) -> Option<&'static User> {
    for user in USERS.iter() {
        if user.id == id {
            return Some(user); // Знайшли — повертаємо Some(користувач)
        }
    }
    None // Не знайшли — повертаємо None
}

fn main() {
    // Ми шукаємо ID 99, якого не існує.
    let user = find_user(99); // user має тип Option<&User>

    // --- Спроба програміста помилитися ---
    // println!("{}", user.name);
    // ^^^
    // ЯКЩО ВИ СПРОБУЄТЕ НАПИСАТИ ЦЕЙ РЯДОК,
    // ПРОГРАМА **НЕ СКОМПІЛЮЄТЬСЯ!**
    //
    // Компілятор зупинить вас і скаже:
    // error: no field `name` on type `Option<&User>`
    // (Помилка: немає поля `name` у типу `Option<&User>`)

    // --- Правильний, безпечний шлях ---
    // Rust змушує нас обробити обидва випадки:
    match user {
        Some(found_user) => println!("{}", found_user.name),
        None => println!("Користувача не знайдено."),
    }
}
```

**Результат:** Програма, в якій програміст забув обробити випадок `None`, **просто не скомпілюється**.

**Розглянемо, як працює цей захист:**

1. Функція `find_user` повертає не `User`, а `Option<&User>` — "можливо, посилання на User"
2. Змінна `user` має тип `Option<&User>`, а не `&User`
3. У типу `Option` **немає поля `name`** — це контейнер, а не сам User
4. Щоб дістати User з контейнера, потрібно явно обробити два випадки: `Some` і `None`
5. Конструкція `match` змушує обробити **всі** можливі варіанти

**Сценарій МАС:** Уявіть, що ви розробляєте trading МАС з сотнями агентів-трейдерів. Агент намагається знайти counterparty для угоди. У Rust компілятор **змусить** вас обробити випадок "агента не знайдено" **до** запуску симуляції. Не може бути ситуації, де агент "думає", що відправив запит, а насправді надіслав його в нікуди.

---

### Підсумок трьох версій

| Мова | Що відбувається | Коли виявляється проблема | Наслідки |
|------|-----------------|---------------------------|----------|
| **Python** | RuntimeError | Під час виконання | Програма падає |
| **C** | Segmentation Fault | Під час виконання | Undefined behavior |
| **Rust** | Помилка компіляції | До запуску | Програма не збереться |

**Ключова перевага Rust:** Він перетворює небезпечну помилку часу виконання на безпечну помилку часу компіляції. Ви покладаєтесь не на дисципліну програміста, а на **гарантії компілятора**.

---

## Що ще перевіряє компілятор Rust?

Магія з `Option` — це лише початок. Той самий механізм, який усуває null pointer, також усуває всі інші страшні помилки C/C++.

### Класи помилок, які Rust усуває на етапі компіляції

**1. Використання після звільнення (Use-After-Free)**

```text
Помилка: Використання посилання на дані, які вже були видалені/звільнені.
У Rust: Неможливо — компілятор відстежує "час життя" кожних даних.
```

**2. Подвійне звільнення (Double Free)**

```text
Помилка: Спроба звільнити ту саму ділянку пам'яті двічі.
У Rust: Неможливо — у кожних даних рівно один власник.
```

**3. Використання неініціалізованої пам'яті**

```text
Помилка: Читання змінної, якій ще не присвоєно значення.
У Rust: Неможливо — компілятор відстежує стан ініціалізації.
```

**4. Гонки даних (Data Races)**

```text
Помилка: Два потоки одночасно змінюють ті самі дані без синхронізації.
У Rust: Неможливо — правила запозичення застосовуються і між потоками.
```

**5. Необроблені помилки**

```text
Помилка: Функція повернула помилку, але ви її проігнорували.
У Rust: Компілятор попереджає, якщо ви не обробили Result.
```

### Таблиця порівняння

| Клас помилок | C/C++ | Python | Rust |
|--------------|-------|--------|------|
| Null pointer dereference | Можливе, UB | RuntimeError | **Неможливе** (Option) |
| Use-After-Free | Можливе, UB | Неможливе (GC) | **Неможливе** (Lifetimes) |
| Double Free | Можливе, UB | Неможливе (GC) | **Неможливе** (Ownership) |
| Data Races | Можливе | GIL захищає | **Неможливе** (Borrow Checker) |
| Витоки пам'яті | Часті | Рідкісні (GC) | **Рідкісні** (RAII) |
| Переповнення буфера | Можливе | IndexError | **Перевірка меж** |

*UB = Undefined Behavior — непередбачувана поведінка*

---

## Зміна способу мислення: Концепції Rust для МАС

Rust досягає безпеки за допомогою унікальних концепцій, які вимагають від програміста зміни способу мислення. Дивовижно, але ці концепції **природно моделюють поведінку мультиагентних систем**!

### Від "Коли це видалити?" до "Хто цим володіє?"

**Старе мислення (C/C++):** "Я створив об'єкт (malloc). Я маю пам'ятати, хто і коли викличе free. Якщо я забуду — витік пам'яті. Якщо зроблю це двічі — збій".

**Мислення Rust (Володіння):** "Хто **володіє** цими даними?". У Rust кожне значення має рівно одного власника. Коли власник виходить з області видимості, Rust автоматично звільняє пам'ять. Якщо ви передаєте дані, ви **переміщуєте** володіння, і старий власник більше не має до них доступу.

**Застосування в МАС:** Це ідеально моделює ресурси в МАС!

- Агент **володіє** енергією → коли агент знищується, енергія автоматично повертається в систему
- Агент **передає** ресурс іншому агенту → move semantics гарантує, що перший агент більше не має доступу
- Агент **володіє** завданням → неможливо, щоб два агенти одночасно "володіли" тим самим завданням

**Приклад: Передача ресурсу між агентами**

Цей приклад демонструє, як система володіння Rust природно моделює передачу ресурсів у МАС. Коли агент передає ресурс іншому агенту, компілятор гарантує, що перший агент більше не може використовувати цей ресурс.

```rust
struct Resource {
    energy: i32,
}

struct Agent {
    id: u32,
    resource: Option<Resource>, // Агент може володіти ресурсом
}

impl Agent {
    // Агент віддає ресурс (переміщує володіння)
    fn transfer_resource(&mut self) -> Option<Resource> {
        self.resource.take() // take() переміщує значення, залишаючи None
    }
    
    // Агент отримує ресурс (приймає володіння)
    fn receive_resource(&mut self, res: Resource) {
        self.resource = Some(res);
    }
}

fn main() {
    let mut agent1 = Agent { 
        id: 1, 
        resource: Some(Resource { energy: 100 }) 
    };
    let mut agent2 = Agent { 
        id: 2, 
        resource: None 
    };
    
    // Агент 1 передає ресурс агенту 2
    if let Some(res) = agent1.transfer_resource() {
        agent2.receive_resource(res);
    }
    
    // agent1.resource тепер None — він більше не має доступу до ресурсу!
    // Компілятор гарантує це на етапі компіляції.
    
    println!("Agent 1 resource: {:?}", agent1.resource); // None
    println!("Agent 2 resource: {:?}", agent2.resource); // Some(Resource { energy: 100 })
}
```

**Розглянемо логіку цього коду:**

1. `Resource` — це ресурс з енергією, яким може володіти агент
2. `Option<Resource>` — агент може мати ресурс (`Some`) або не мати (`None`)
3. Метод `take()` — забирає значення з `Option`, залишаючи `None`
4. Після передачі `agent1.resource` автоматично стає `None`
5. Компілятор **гарантує**, що ресурс не може бути в двох місцях одночасно

---

### Від "Ось вказівник" до "Позич мені це"

**Старе мислення (C/C++):** "Ось вказівник (*ptr). Роби з ним, що хочеш. Сподіваюся, інший потік не пише в нього одночасно".

**Мислення Rust (Запозичення):** "Я можу **позичити** тобі дані, але за суворими правилами, які перевірить компілятор":
- **Правило 1:** Ви можете мати **одне** змінюване посилання (`&mut T`) для запису
- **Правило 2:** АБО **безліч** незмінних посилань (`&T`) тільки для читання
- **Ніколи обидва одночасно**

Цей простий набір правил повністю усуває гонки даних на етапі компіляції.

**Застосування в МАС:** Це природна модель для агентів і середовища!

- **Сприйняття (perceive):** Агент запозичує незмінне посилання на середовище `&Environment` — тільки для читання
- **Дія (act):** Агент запозичує змінюване посилання `&mut Environment` — може змінювати
- **Багато агентів:** Всі агенти можуть одночасно "дивитися" на середовище
- **Один змінює:** Тільки один агент може змінювати середовище в конкретний момент

**Приклад: Агент спостерігає та діє на середовище**

Цей приклад показує, як правила запозичення моделюють доступ агентів до середовища. Багато агентів можуть одночасно читати середовище, але тільки один може його змінювати.

```rust
struct Environment {
    grid: Vec<Vec<i32>>,
}

struct Agent {
    x: usize,
    y: usize,
}

impl Agent {
    // Агент спостерігає середовище (незмінне запозичення)
    fn perceive(&self, env: &Environment) -> i32 {
        env.grid[self.x][self.y] // Тільки читання
    }
    
    // Агент змінює середовище (змінюване запозичення)
    fn act(&self, env: &mut Environment, new_value: i32) {
        env.grid[self.x][self.y] = new_value; // Зміна
    }
}

fn main() {
    let mut env = Environment { 
        grid: vec![vec![0; 10]; 10] 
    };
    let agent1 = Agent { x: 5, y: 5 };
    let agent2 = Agent { x: 3, y: 7 };
    
    // Багато агентів можуть одночасно спостерігати (багато &env)
    let value1 = agent1.perceive(&env);
    let value2 = agent2.perceive(&env);
    println!("Agent 1 бачить: {}", value1);
    println!("Agent 2 бачить: {}", value2);
    
    // Тільки один може змінювати (&mut env)
    agent1.act(&mut env, 42);
    
    // Якщо б ми спробували:
    // agent1.act(&mut env, 1);
    // agent2.act(&mut env, 2); // одночасно
    // Компілятор НЕ ДОЗВОЛИВ БИ — це потенційна data race!
}
```

**Розглянемо логіку цього коду:**

1. `perceive(&self, env: &Environment)` — метод приймає **незмінне посилання** на середовище
2. `act(&self, env: &mut Environment)` — метод приймає **змінюване посилання**
3. Можна викликати `perceive` для багатьох агентів одночасно — всі тільки читають
4. `act` вимагає ексклюзивного доступу — тільки один агент може змінювати
5. Компілятор **гарантує** відсутність data races без жодних runtime перевірок

---

### Від "Чи дійсні ці дані?" до "Як довго вони живуть?"

**Старе мислення (C/C++):** "Я повернув вказівник на локальну змінну. Функція завершилася, стек очистився. Коли я спробую використати цей вказівник — БУМ! (висячий вказівник)".

**Мислення Rust (Час життя):** Компілятор відстежує "час життя" (scope) кожних даних та кожного посилання. Він не дасть вам зібрати програму, якщо посилання може "пережити" дані, на які воно вказує.

**Застосування в МАС:**

- Агент А зберігає посилання на агента Б
- Агент Б знищується
- Компілятор **НЕ ДОЗВОЛИТЬ** агенту А використовувати це посилання!

У C++ це призвело б до use-after-free. У Rust — це помилка компіляції.

---

## Чому не можна просто покращити компілятор C++?

Після прочитання попередніх розділів у вас може виникнути логічне запитання: якщо переваги Rust — це перевірки компілятора, то чому б просто не створити такий самий потужний компілятор для C++?

### Справа не в компіляторі, а в дизайні мови

Особливості Rust — це **не просто "розумний компілятор"**. Це **дизайн самої мови**, який робить перевірки можливими. Компілятор C++ не може робити такі ж перевірки, тому що **сама мова C++ не надає йому достатньо інформації**.

**Володіння (Ownership) — не виражене в типах C++**

```cpp
// C++: Хто володіє цим об'єктом? Компілятор не знає.
void process(std::string* s);  // Функція забирає володіння? Просто читає? Невідомо.
```

```rust
// Rust: Володіння явне в сигнатурі функції
fn process(s: String);       // Забирає володіння
fn process(s: &String);      // Тільки читає (позичає)
fn process(s: &mut String);  // Модифікує (позичає мутабельно)
```

Компілятор C++ **не знає**, чи функція "забирає" об'єкт, чи просто використовує. Ця інформація не записана в мові.

**Час життя (Lifetimes) — відсутній як концепція**

```cpp
// C++: Компілятор не знає, як довго живе посилання
int* get_ref() {
    int x = 42;
    return &x;  // Висячий вказівник! Компілятор може попередити, але не гарантує.
}
```

```rust
// Rust: Час життя — частина системи типів
fn get_ref<'a>() -> &'a i32 {
    let x = 42;
    &x  // ПОМИЛКА КОМПІЛЯЦІЇ: x не живе достатньо довго
}
```

У Rust `'a` — це **параметр часу життя**, частина системи типів. Компілятор **математично доводить**, що посилання валідне.

### Аналогія: Бухгалтерський облік

**C++** — це записи на серветках: "Петро винен Марії гроші". Аудитор (компілятор) може спробувати розібратися, але інформації недостатньо.

**Rust** — це подвійний запис з підписами: кожна транзакція має дебет і кредит, підписи сторін, дату. Аудитор може **математично довести** баланс.

Ви не можете зробити "кращого аудитора" для серветок — потрібна **інша система обліку**.

---

## Що таке мультиагентні системи

### Визначення агента

**Агент** — це автономна обчислювальна сутність, яка:

1. **Сприймає** своє середовище через сенсори (чи їх програмні аналоги)
2. **Приймає рішення** на основі своїх цілей та отриманої інформації
3. **Діє** на середовище через актуатори (чи програмні дії)
4. **Автономна** — працює без постійного зовнішнього керування

```text
┌─────────────────────────────────────────────────────────────────┐
│                        АГЕНТ                                    │
│                                                                 │
│    СЕРЕДОВИЩЕ                                                   │
│        │                                                        │
│        ▼ сприйняття                                            │
│   ┌─────────────┐                                               │
│   │  СЕНСОРИ    │                                               │
│   └──────┬──────┘                                               │
│          │                                                      │
│          ▼                                                      │
│   ┌─────────────────────────────────────────┐                  │
│   │         СИСТЕМА ПРИЙНЯТТЯ РІШЕНЬ         │                  │
│   │  ┌─────────┐  ┌─────────┐  ┌─────────┐  │                  │
│   │  │ Знання  │  │  Цілі   │  │ Правила │  │                  │
│   │  └─────────┘  └─────────┘  └─────────┘  │                  │
│   └──────────────────┬──────────────────────┘                  │
│                      │                                          │
│                      ▼                                          │
│   ┌─────────────┐                                               │
│   │ АКТУАТОРИ   │                                               │
│   └──────┬──────┘                                               │
│          │ дія                                                  │
│          ▼                                                      │
│    СЕРЕДОВИЩЕ                                                   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### Типи агентів

**Реактивні агенти (Reactive Agents)** — найпростіший тип, діють за принципом "стимул → реакція":

```text
IF бачу_перешкоду THEN повернути
IF бачу_ціль THEN рухатись_до_цілі
IF батарея_низька THEN повернутись_на_базу
```

**Агенти з моделлю світу (Model-based Agents)** — підтримують внутрішнє уявлення про стан світу: карту території, позиції інших агентів, історію подій.

**Цілеспрямовані агенти (Goal-based Agents)** — мають явні цілі та планують дії для їх досягнення.

**BDI-агенти (Belief-Desire-Intention)** — найскладніший тип, моделюють людське мислення:
- **Beliefs** (переконання) — що агент вважає правдою
- **Desires** (бажання) — чого агент хоче досягти
- **Intentions** (наміри) — що агент вирішив робити

### Від одного агента до мультиагентної системи

**Мультиагентна система (МАС)** — це система, де кілька агентів взаємодіють для досягнення індивідуальних чи спільних цілей.

```text
┌─────────────────────────────────────────────────────────────────┐
│              МУЛЬТИАГЕНТНА СИСТЕМА                              │
│                                                                 │
│   ┌─────────┐      комунікація      ┌─────────┐                │
│   │ Агент А │◄─────────────────────►│ Агент Б │                │
│   └────┬────┘                       └────┬────┘                │
│        │                                 │                      │
│        │         ┌─────────┐            │                      │
│        └────────►│ Агент В │◄───────────┘                      │
│                  └────┬────┘                                    │
│                       │                                         │
│                       ▼                                         │
│              СПІЛЬНЕ СЕРЕДОВИЩЕ                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

**Ключові характеристики МАС:**

1. **Децентралізація** — немає єдиного центру керування
2. **Автономність** — кожен агент приймає власні рішення
3. **Взаємодія** — агенти спілкуються та координуються
4. **Емерджентність** — складна поведінка "виникає" з простих локальних правил

### Де застосовуються МАС

- 🚁 **Роєва робототехніка** — координація дронів, роботів
- 🚗 **Автономний транспорт** — взаємодія безпілотних авто
- 💰 **Фінансові ринки** — торгові боти
- 🎮 **Відеоігри** — NPC з реалістичною поведінкою
- 🏭 **Розумні виробництва** — координація обладнання
- 🌐 **Інтернет речей** — взаємодія пристроїв

---

## Наскрізний проєкт: Інтелектуальний автономний рій БПЛА

### Концепція

Протягом усього підручника ви будуватимете одну систему, що еволюціонує від простого агента до повноцінного рою. Це **симуляція автономного рою безпілотних літальних апаратів (БПЛА)** для виконання розвідувальних та пошукових місій.

### Архітектура рою

```text
┌─────────────────────────────────────────────────────────────┐
│                      КОМАНДИР РОЮ                           │
│         (стратегічне планування, координація)               │
└─────────────────────────┬───────────────────────────────────┘
                          │
        ┌─────────────────┼─────────────────┐
        │                 │                 │
        ▼                 ▼                 ▼
┌───────────────┐ ┌───────────────┐ ┌───────────────┐
│  КОМАНДИР     │ │  КОМАНДИР     │ │  КОМАНДИР     │
│  ГРУПИ 1      │ │  ГРУПИ 2      │ │  ГРУПИ N      │
└───────┬───────┘ └───────┬───────┘ └───────┬───────┘
        │                 │                 │
   ┌────┴────┐       ┌────┴────┐       ┌────┴────┐
   ▼    ▼    ▼       ▼    ▼    ▼       ▼    ▼    ▼
  🛸   🛸   🛸      🛸   🛸   🛸      🛸   🛸   🛸
 Дрони групи      Дрони групи       Дрони групи
```

### Типи груп у рої

| Група | Призначення | Ключові можливості |
|-------|-------------|-------------------|
| **Розвідники (Scouts)** | Пошук об'єктів, передача координат | Сенсори, швидке переміщення |
| **Штурманська (Navigation)** | Планування маршрутів | Алгоритми шляху, карта |
| **Бойова (Combat)** | Ударні функції | Точність, координація атак |
| **РЕБ (Electronic Warfare)** | Радіоелектронна боротьба | Глушіння, захист зв'язку |
| **Зв'язківці (Communications)** | Ретрансляція даних | Надійний зв'язок |
| **Транспортна (Transport)** | Доставка, евакуація | Вантажопідйомність |
| **Розпізнавачі (Recognizers)** | Обробка даних сенсорів | Класифікація об'єктів |
| **Радники (Advisors)** | Аналітика, моделювання | Оцінка ризиків |
| **Центр прийняття рішень** | Агрегація, координація | Колективний аналіз |

### Гібридна схема управління

Рій використовує **гібридний підхід**:

1. **Ієрархічність:** Командир рою → Командири груп → Окремі дрони
2. **Децентралізація:** Кожен дрон має локальну політику і може діяти автономно при втраті зв'язку
3. **Обмін досвідом:** Централізоване тренування на основі даних з усіх дронів

### Еволюція проєкту через підручник

| Частина | Стан проєкту | Нові можливості |
|---------|--------------|-----------------|
| **0: Bootcamp** | Агент-патрульний на сітці | Базова логіка без складної пам'яті |
| **I: Агент як об'єкт** | Автономний агент v1.0 | Структури, машина станів, модулі |
| **II: Робастність** | Робастний агент v2.0 | Обробка помилок, логування, серіалізація |
| **III: Спільна пам'ять** | Локальний рій v3.0 | Потоки, синхронізація, канали |
| **IV: Асинхронність** | Асинхронний рій v4.0 | Tokio, актори, масштабування |
| **V: Архітектури** | Фінальний рій БПЛА | ECS, BDI, мережа, WebAssembly |

---

## Битва, яку варто виграти

Головний "недолік" Rust, про який вам скаже кожен, — це його крута крива навчання. Спочатку вивчення Rust виглядає як постійна "битва з компілятором". Він здається надто прискіпливим і постійно скаржиться на код, який, на вашу думку, є ідеальним.

**Але ця "битва" — і є процес навчання.**

Компілятор Rust — це ваш особистий "інспектор якості", суворий, але справедливий наставник, який змушує вас довести, що ваш код безпечний, **до** того, як він запуститься.

### Для МАС ця битва особливо важлива

- Симуляція з 10,000 агентів — це складно для debugging
- Помилка може проявитися через години роботи
- У паралельних МАС помилки недетерміновані (важко відтворити)
- Rust гарантує, що багато помилок **просто неможливі**

### Нагорода за цю битву величезна

**Надійність:** Коли ваша МАС на Rust компілюється, ви отримуєте впевненість, що в ній відсутні цілі класи критичних помилок.

**Продуктивність:** Код компілюється в такий самий ефективний машинний код, як C. Ви можете симулювати 100,000 агентів без пауз GC.

**Паралелізм:** "Fearless concurrency" — девіз Rust. Для МАС, де природна паралельність (кожен агент — окремий процес), це революція.

**Інструменти:** Cargo — вбудований менеджер пакетів та система збірки. Компілятор дає найкорисніші повідомлення про помилки в індустрії.

---

## Як читати повідомлення компілятора

Компілятор Rust — ваш вчитель. Його повідомлення — найкраща документація.

```text
error[E0382]: borrow of moved value: `s1`
 --> src/main.rs:4:20
  │
2 │     let s1 = String::from("hello");
  │         -- move occurs because `s1` has type `String`
3 │     let s2 = s1;
  │              -- value moved here
4 │     println!("{}", s1);
  │                    ^^ value borrowed here after move
```

**Структура повідомлення:**
1. **Код помилки (E0382)** — можна шукати документацію
2. **Короткий опис проблеми**
3. **Де проблема в коді** (з номерами рядків)
4. **Пояснення, що сталося**
5. **Часто: підказка як виправити**

---

## Карта підручника

```text
┌─────────────────────────────────────────────────────────────────┐
│                     КАРТА ПІДРУЧНИКА                            │
│                                                                 │
│  ЧАСТИНА 0: ІМПЕРАТИВНИЙ RUST (Розділи 1-6)                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Змінні → Функції → Цикли → Масиви → Практикум          │   │
│  │ Результат: агент-патрульний на сітці                    │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ЧАСТИНА I: АГЕНТ ЯК ОБ'ЄКТ (Розділи 7-15)                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Ownership → Borrowing → Struct → Enum → Modules         │   │
│  │ Результат: автономний агент v1.0 з машиною станів       │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ЧАСТИНА II: РОБАСТНІСТЬ (Розділи 16-27)                       │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Vec → HashMap → Result → Traits → Generics → Serde      │   │
│  │ Результат: робастний агент v2.0 з обробкою помилок      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ЧАСТИНА III: СПІЛЬНА ПАМ'ЯТЬ (Розділи 28-36)                 │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Box → Rc → RefCell → Lifetimes → Threads → Channels     │   │
│  │ Результат: локальний рій v3.0 з кількох агентів         │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ЧАСТИНА IV: АСИНХРОННІСТЬ (Розділи 37-44)                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Async/Await → Tokio → Streams → Actors → Rayon          │   │
│  │ Результат: асинхронний рій v4.0 на 1000+ агентів        │   │
│  └─────────────────────────────────────────────────────────┘   │
│                            │                                    │
│                            ▼                                    │
│  ЧАСТИНА V: АРХІТЕКТУРИ МАС (Розділи 45-53)                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │ Macros → Unsafe → ECS → BDI → Network → WASM → Project  │   │
│  │ Результат: production-ready система рою БПЛА            │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

---

## Для кого цей підручник

- **Студенти** курсів штучного інтелекту, робототехніки, розподілених систем
- **Розробники на C/C++**, які шукають безпечнішу альтернативу без втрати продуктивності
- **Розробники на Python/Java**, які хочуть зрозуміти системне програмування
- **Інженери** у сфері робототехніки, IoT, вбудованих систем
- **Усі, хто цікавиться** мультиагентними системами

**Попередні вимоги:** Підручник розрахований на читачів **без попереднього досвіду з Rust**. Базове розуміння програмування (будь-якою мовою) буде корисним.

---

## Як читати цю книгу

1. **Послідовно:** Розділи побудовані один на одному. Агент еволюціонує.
2. **Практично:** Кожен розділ має лабораторну роботу. Код потрібно писати.
3. **Терпляче:** Ownership та Borrow Checker спочатку здаються ворогами. Вони стануть друзями.
4. **Експериментуйте:** Компілятор — найкращий вчитель. Навмисно робіть помилки.

---

## Готові почати?

Перегорніть сторінку — і ласкаво просимо до **Частини 0: Імперативний Rust (Bootcamp)**!

Ваш перший агент чекає.

🛸

---

> **Наступний розділ:** [Розділ 1: Налаштування середовища та перший проєкт](./01_Setup.md)
