# Розділ 36: Практикум — Локальний рій агентів v3.0

---

## 📋 Анотація

Цей розділ є кульмінацією всієї Частини III підручника. Протягом попередніх восьми розділів ви опанували потужний арсенал інструментів багатопотоковості Rust: smart pointers для керування пам'яттю (Box, Rc, Arc), механізми interior mutability (RefCell, Cell), явні анотації часу життя (lifetimes), потоки та примітиви синхронізації (Mutex, RwLock), а також канали для передачі повідомлень. Кожен з цих інструментів вивчався окремо, на ізольованих прикладах. Тепер настав час зібрати все докупи.

Цей практикум — не просто "ще один приклад коду". Це **архітектурний практикум**, де ви навчитесь мислити як системний архітектор. Перед вами постануть питання, на які немає єдиної правильної відповіді: коли використовувати спільний стан, а коли передачу повідомлень? Як структурувати код для майбутнього розширення? Як мінімізувати блокування без втрати коректності? Як забезпечити graceful shutdown складної системи?

Результатом вашої роботи буде повноцінна симуляція **локального рою агентів** — системи, де кілька автономних БПЛА працюють паралельно в окремих потоках, ділять спільну карту світу, координують свої дії через канали та звітують про свої знахідки центральному координатору. Ця система стане фундаментом для подальшого розвитку в Частині IV (де ви навчитесь масштабувати до тисяч агентів через асинхронність) та Частині V (де рій стане розподіленим по мережі).

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Аналізувати** вимоги до багатопотокової системи та визначати оптимальну архітектуру
2. **Обґрунтовувати** вибір між спільним станом та передачею повідомлень для кожного компонента
3. **Проєктувати** типи даних з урахуванням вимог багатопотоковості (Send, Sync, Clone)
4. **Комбінувати** різні примітиви синхронізації в одній системі без конфліктів
5. **Реалізовувати** патерн coordinator-workers з graceful shutdown
6. **Тестувати** багатопотоковий код та виявляти потенційні проблеми

---

## 📚 Ключові терміни

| Термін | Визначення |
|--------|------------|
| **координатор** | Центральний потік системи, що ініціалізує ресурси, запускає робочі потоки, збирає результати та керує завершенням роботи |
| **worker (робітник)** | Потік-виконавець, що реалізує логіку окремого агента; працює автономно, взаємодіючи з іншими через синхронізовані механізми |
| **спільний стан** | Дані, доступні кільком потокам одночасно; потребує синхронізації через Arc<Mutex> або Arc<RwLock> |
| **канал звітів** | Однонаправлений шлях передачі інформації від агентів до координатора через mpsc |
| **perceive-decide-act** | Класичний цикл автономного агента: сприйняття оточення → прийняття рішення → виконання дії |
| **graceful shutdown** | Коректне завершення всіх потоків системи з очікуванням завершення поточних операцій та збереженням стану |
| **критична секція** | Ділянка коду, що виконується під захистом lock; має бути якомога коротшою |

---

## 💡 Мотиваційний кейс: Від теорії до реальної системи

Уявіть, що ви отримали замовлення на розробку прототипу системи керування роєм БПЛА для моніторингу сільськогосподарських угідь. Замовник сформулював такі вимоги:

**Функціональні вимоги:**
- Система має підтримувати від 4 до 8 агентів, що працюють паралельно
- Всі агенти ділять спільну карту території розміром 50×50 клітин
- На карті є перешкоди (дерева, будівлі), які агенти мають обходити
- Агенти шукають цілі (пошкоджені ділянки посівів) та позначають їх на карті
- Координатор збирає звіти про знахідки в реальному часі
- Після завершення місії виводиться статистика: скільки території досліджено, скільки цілей знайдено

**Нефункціональні вимоги:**
- Система має коректно завершуватись навіть при аварійних ситуаціях
- Код має бути структурований для подальшого розширення
- Жодних гонок даних чи deadlock'ів

Як підійти до такого завдання? Які інструменти з вашого арсеналу обрати? Як уникнути типових помилок багатопотокового програмування?

---

## 36.1 АРХІТЕКТУРНИЙ АНАЛІЗ СИСТЕМИ

### 36.1.1 Еволюція агента через підручник

Перш ніж проєктувати систему, корисно простежити, як агент еволюціонував протягом нашого підручника. Це допоможе зрозуміти, чому ми прийшли саме до такої архітектури.

**Частини 0-I: Агент як структура даних**

На початку підручника агент був просто набором даних — структурою з полями для позиції, рівня батареї, напрямку руху:

```text
┌─────────────────────────────────┐
│         DroneState              │
│  ┌────────────────────────┐     │
│  │ position: (x, y)       │     │
│  │ battery: u8            │     │
│  │ heading: Direction     │     │
│  │ is_active: bool        │     │
│  └────────────────────────┘     │
└─────────────────────────────────┘
         Пасивні дані
```

Вся логіка знаходилась зовні — у функціях `main()` або окремих модулях. Агент нічого "не знав" про своє призначення; він був об'єктом маніпуляцій зовнішнього коду.

**Частина II: Агент як автономний об'єкт**

Далі агент набув автономності. Ми інкапсулювали поведінку всередині структури через методи:

```text
┌─────────────────────────────────┐
│            Agent                │
│  ┌────────────────────────┐     │
│  │ state: AgentState      │     │
│  │ sensors: SensorArray   │     │
│  └────────────────────────┘     │
│  ┌────────────────────────┐     │
│  │ fn perceive(&self)     │     │
│  │ fn decide(&mut self)   │     │
│  │ fn act(&mut self)      │     │
│  └────────────────────────┘     │
└─────────────────────────────────┘
    Автономний об'єкт з поведінкою
```

Тепер агент "знав", як сприймати оточення, приймати рішення та діяти. Але виконання все ще було послідовним — один агент за раз, у головному потоці.

**Частина III (поточний стан): Агент як паралельний процес**

Нарешті, агент став повноцінним паралельним процесом — окремим потоком з власним життєвим циклом:

```text
┌─────────────────────────────────────────────────────┐
│              Agent Thread                           │
│  ┌──────────────────────────────────────────────┐  │
│  │ Приватний стан (без синхронізації):          │  │
│  │   - position, battery, mode, targets_found   │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │ Доступ до спільних ресурсів:                 │  │
│  │   - Arc<RwLock<WorldMap>>  ←── читання/запис │  │
│  │   - Arc<Mutex<Statistics>> ←── оновлення     │  │
│  └──────────────────────────────────────────────┘  │
│  ┌──────────────────────────────────────────────┐  │
│  │ Комунікація:                                 │  │
│  │   - Sender<AgentReport>    ←── звіти назовні │  │
│  └──────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────┘
        Паралельний процес з визначеними інтерфейсами
```

Агент працює незалежно від інших, має чітко визначені точки взаємодії із зовнішнім світом, і його внутрішній стан захищений від зовнішнього втручання.

### 36.1.2 Центральне архітектурне питання: що ділити, а що ізолювати?

Це найважливіше рішення при проєктуванні багатопотокової системи. Неправильний вибір призведе або до надмірного блокування (якщо ділити забагато), або до неузгодженості даних (якщо ізолювати забагато). Розглянемо кожен компонент нашої системи.

**Карта світу (WorldMap)**

Карта — це центральний ресурс системи. Проаналізуємо патерн доступу:

| Операція | Частота | Тип доступу |
|----------|---------|-------------|
| Перевірка прохідності клітини | Дуже часто (кожен крок) | Читання |
| Читання типу клітини | Часто | Читання |
| Позначення дослідженої клітини | Рідко | Запис |
| Позначення знайденої цілі | Дуже рідко | Запис |

**Аналіз:** Операції читання домінують. Кілька агентів одночасно перевіряють прохідність різних клітин, але записи відбуваються рідко і зазвичай в різні клітини.

**Рішення:** `Arc<RwLock<WorldMap>>` — ідеальний вибір. RwLock дозволяє кільком читачам працювати паралельно, блокуючи лише на час запису. Arc забезпечує спільне володіння між потоками.

**Стан окремого агента (позиція, батарея, режим)**

Ці дані належать виключно одному агенту:

| Питання | Відповідь |
|---------|-----------|
| Хто читає ці дані? | Тільки власний потік агента |
| Хто змінює ці дані? | Тільки власний потік агента |
| Чи потрібен доступ іншим агентам? | Ні (вони можуть дізнатись через звіти) |

**Рішення:** Локальні змінні всередині потоку, без жодної синхронізації. Це найефективніший підхід — немає накладних витрат на блокування.

**Звіти про знахідки**

Агенти генерують звіти, координатор їх обробляє:

| Характеристика | Значення |
|----------------|----------|
| Напрямок потоку даних | Односпрямований: агенти → координатор |
| Кількість виробників | Багато (всі агенти) |
| Кількість споживачів | Один (координатор) |
| Чи потрібен двосторонній зв'язок? | Ні (для MVP) |

**Рішення:** `mpsc::channel<AgentReport>` — класичний патерн fan-in. Кожен агент отримує клонований Sender, координатор тримає Receiver.

**Статистика місії**

Глобальні лічильники успіхів, помилок, прогресу:

| Операція | Джерело |
|----------|---------|
| Інкремент "клітин досліджено" | Будь-який агент |
| Інкремент "цілей знайдено" | Будь-який агент |
| Читання для відображення | Координатор |

**Рішення:** `Arc<Mutex<Statistics>>` — простий Mutex достатній, оскільки операції короткі (інкременти), а частота невисока.

### 36.1.3 Візуалізація архітектури

Зберемо все разом у діаграму:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                         СИСТЕМА РОЮ v3.0                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      КООРДИНАТОР                             │   │
│  │  ┌─────────────────┐  ┌─────────────────┐                   │   │
│  │  │ Обробник звітів │  │ Монітор стану   │                   │   │
│  │  │ (Receiver)      │  │                 │                   │   │
│  │  └────────▲────────┘  └────────│────────┘                   │   │
│  └───────────│────────────────────│─────────────────────────────┘   │
│              │                    │                                  │
│              │ Канал звітів       │ Arc<Mutex<Statistics>>           │
│              │ (mpsc)             │                                  │
│   ┌──────────┴──────────┬────────┴────────┬─────────────────┐       │
│   │                     │                 │                 │       │
│   ▼                     ▼                 ▼                 ▼       │
│ ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐                      │
│ │Агент 1 │  │Агент 2 │  │Агент 3 │  │Агент 4 │   ...                │
│ │(потік) │  │(потік) │  │(потік) │  │(потік) │                      │
│ └───┬────┘  └───┬────┘  └───┬────┘  └───┬────┘                      │
│     │           │           │           │                           │
│     └─────────┬─┴───────────┴───────────┘                           │
│               │                                                      │
│               │ Arc<RwLock<WorldMap>>                                │
│               ▼                                                      │
│     ┌─────────────────────────────────┐                             │
│     │          СПІЛЬНА КАРТА          │                             │
│     │  ┌───┬───┬───┬───┬───┬───┐     │                             │
│     │  │   │ █ │   │ ◎ │   │   │     │    █ = перешкода            │
│     │  ├───┼───┼───┼───┼───┼───┤     │    ◎ = ціль                 │
│     │  │ █ │   │   │   │ █ │   │     │    · = досліджено           │
│     │  ├───┼───┼───┼───┼───┼───┤     │                             │
│     │  │   │   │ · │ · │   │ ◎ │     │                             │
│     │  └───┴───┴───┴───┴───┴───┘     │                             │
│     └─────────────────────────────────┘                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 36.1.4 Обґрунтування архітектурних рішень

Підсумуємо вибір примітивів у вигляді таблиці з обґрунтуванням:

| Компонент | Примітив | Чому саме цей? |
|-----------|----------|----------------|
| Карта світу | `Arc<RwLock<T>>` | Багато читачів, рідкісні записи; RwLock оптимальний для цього патерну |
| Статистика | `Arc<Mutex<T>>` | Прості інкременти; Mutex простіший і достатній |
| Звіти | `mpsc::channel` | Односпрямований потік даних; ownership transfer замість shared state |
| Стан агента | Локальні змінні | Доступ тільки з одного потоку; синхронізація непотрібна |

---

## 36.2 ПРОЄКТУВАННЯ ТИПІВ ДАНИХ

### 36.2.1 Філософія проєктування типів для багатопотоковості

При проєктуванні типів для багатопотокової системи слід керуватися кількома принципами.

**Принцип 1: Мінімізуйте те, що потрібно синхронізувати**

Чим менше даних ділиться між потоками, тим простіша синхронізація. Якщо дані можуть бути локальними — зробіть їх локальними.

**Принцип 2: Derive-атрибути повинні відповідати призначенню**

- `Clone` — якщо тип буде копіюватись (наприклад, для передачі в інший потік)
- `Copy` — лише для маленьких типів без heap-даних (Position, Direction)
- `Debug` — майже завжди, для діагностики
- `PartialEq` — якщо потрібні порівняння
- `Send` — автоматично, якщо всі поля Send (для передачі між потоками)
- `Sync` — автоматично, якщо всі поля Sync (для спільного доступу)

**Принцип 3: Використовуйте enum для взаємовиключних станів**

Замість кількох bool-полів або числових кодів, enum гарантує, що тип може бути лише в одному з визначених станів.

### 36.2.2 Базові типи: Position та Direction

Почнемо з найпростіших типів, що представляють просторові концепції.

**Постановка задачі:** Нам потрібен тип для представлення позиції агента на двовимірній сітці та тип для напрямку руху.

```rust
/// Позиція на двовимірній сітці
/// 
/// Copy та Clone дозволяють ефективно копіювати позицію
/// (це всього два числа — 8 байт на стеку).
/// Debug та PartialEq потрібні для логування та порівнянь.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct Position {
    pub x: i32,  // i32 дозволяє від'ємні координати (якщо потрібно)
    pub y: i32,
}

impl Position {
    /// Створює нову позицію
    pub fn new(x: i32, y: i32) -> Self {
        Self { x, y }
    }
    
    /// Обчислює нову позицію після руху в заданому напрямку
    pub fn moved(&self, direction: Direction) -> Self {
        match direction {
            Direction::North => Position::new(self.x, self.y - 1),
            Direction::South => Position::new(self.x, self.y + 1),
            Direction::East => Position::new(self.x + 1, self.y),
            Direction::West => Position::new(self.x - 1, self.y),
        }
    }
    
    /// Обчислює манхеттенську відстань до іншої позиції
    /// (корисно для оцінки "як далеко до бази")
    pub fn distance_to(&self, other: &Position) -> u32 {
        ((self.x - other.x).abs() + (self.y - other.y).abs()) as u32
    }
}

/// Напрямок руху на сітці
/// 
/// Чотири кардинальні напрямки. Copy та Clone — оскільки
/// це всього один байт (enum без даних).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Direction {
    North,
    South,
    East,
    West,
}

impl Direction {
    /// Повертає всі можливі напрямки (корисно для перебору)
    pub fn all() -> [Direction; 4] {
        [Direction::North, Direction::South, Direction::East, Direction::West]
    }
    
    /// Повертає протилежний напрямок
    pub fn opposite(&self) -> Direction {
        match self {
            Direction::North => Direction::South,
            Direction::South => Direction::North,
            Direction::East => Direction::West,
            Direction::West => Direction::East,
        }
    }
}
```

**Як працює цей код:**

Типи `Position` та `Direction` максимально прості і ефективні:

1. **Derive-атрибути:** `Copy` та `Clone` дозволяють передавати ці типи за значенням без явного клонування. `Hash` для Position дозволяє використовувати позиції як ключі в HashMap (якщо потрібно).

2. **Метод `moved`:** Замість мутації позиції, створюється нова. Це функціональний підхід, що спрощує reasoning про код.

3. **Метод `distance_to`:** Манхеттенська відстань (сума абсолютних різниць координат) — стандартна метрика для сіткових світів.

### 36.2.3 Тип клітини карти: Cell

**Постановка задачі:** Кожна клітина карти може бути в одному з кількох станів: порожня (прохідна), перешкода, ціль для пошуку, або база агентів.

```rust
/// Тип клітини карти світу
/// 
/// Enum гарантує, що клітина може бути тільки в одному стані.
/// Це краще, ніж окремі поля is_obstacle, is_target, is_explored —
/// такий підхід міг би створити неконсистентні комбінації.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Cell {
    /// Порожня прохідна клітина
    Empty,
    
    /// Перешкода (непрохідна)
    Obstacle,
    
    /// Ціль для пошуку (прохідна)
    Target,
    
    /// База агентів (прохідна, точка старту/повернення)
    Base,
    
    /// Досліджена клітина (була Empty, агент її відвідав)
    Explored,
    
    /// Знайдена ціль (була Target, агент її виявив)
    FoundTarget,
}

impl Cell {
    /// Чи може агент пройти через цю клітину?
    pub fn is_passable(&self) -> bool {
        match self {
            Cell::Obstacle => false,
            _ => true,  // Всі інші типи прохідні
        }
    }
    
    /// Чи є ця клітина невідкритою ціллю?
    pub fn is_undiscovered_target(&self) -> bool {
        matches!(self, Cell::Target)
    }
    
    /// Чи була ця клітина вже досліджена?
    pub fn is_explored(&self) -> bool {
        matches!(self, Cell::Explored | Cell::FoundTarget)
    }
}
```

**Як працює цей код:**

1. **Enum замість полів:** Уявіть альтернативу — структуру з полями `is_obstacle: bool, is_target: bool, is_explored: bool`. Що означає `{is_obstacle: true, is_target: true, is_explored: false}`? Перешкода, яка є ціллю? Enum робить такі неконсистентні стани неможливими.

2. **Методи-предикати:** `is_passable()`, `is_undiscovered_target()` інкапсулюють логіку перевірки, що робить код агента чистішим.

3. **Два "фінальні" стани:** `Explored` та `FoundTarget` — це "кінцеві" стани для клітин `Empty` та `Target` відповідно. Клітина може перейти з `Empty` → `Explored` або з `Target` → `FoundTarget`, але не назад.

### 36.2.4 Звіти агентів: AgentReport

**Постановка задачі:** Агенти повинні повідомляти координатора про різні події: зміну позиції, виявлення цілі, завершення місії. Кожен тип події має різні асоційовані дані.

```rust
/// Звіт від агента до координатора
/// 
/// Використовуємо enum з даними — кожен варіант несе
/// саме ту інформацію, яка потрібна для цього типу події.
#[derive(Debug, Clone)]
pub enum AgentReport {
    /// Агент оновлює свою позицію
    /// Координатор може використати для візуалізації
    PositionUpdate {
        agent_id: u32,
        position: Position,
        battery_level: u8,
    },
    
    /// Агент виявив ціль
    /// Найважливіший тип звіту для місії
    TargetDiscovered {
        agent_id: u32,
        target_position: Position,
        timestamp: std::time::Instant,
    },
    
    /// Агент досліджує нову клітину
    /// Для відстеження прогресу місії
    CellExplored {
        agent_id: u32,
        position: Position,
    },
    
    /// Агент завершив місію
    /// Може бути з різних причин
    MissionComplete {
        agent_id: u32,
        reason: MissionEndReason,
        total_steps: u32,
        targets_found: u32,
    },
    
    /// Агент повідомляє про проблему
    Warning {
        agent_id: u32,
        message: String,
    },
}

/// Причина завершення місії агента
#[derive(Debug, Clone)]
pub enum MissionEndReason {
    /// Батарея розрядилась
    BatteryDepleted,
    
    /// Агент повернувся на базу за планом
    ReturnedToBase,
    
    /// Зовнішній сигнал завершення
    ExternalShutdown,
    
    /// Помилка під час виконання
    Error(String),
}
```

**Як працює цей код:**

1. **Enum з даними:** Кожен варіант `AgentReport` несе саме ті дані, які потрібні для цього типу події. `TargetDiscovered` включає позицію цілі та час виявлення; `MissionComplete` включає статистику виконання.

2. **Вкладений enum:** `MissionEndReason` — окремий тип для причини завершення. Це краще, ніж String, оскільки компілятор гарантує обробку всіх варіантів.

3. **Clone замість Copy:** `AgentReport` містить `String` (у варіантах `Warning` та `MissionEndReason::Error`), тому не може бути `Copy`. Але `Clone` достатньо для передачі через канал.

### 36.2.5 Приватний стан агента: AgentState

**Постановка задачі:** Кожен агент має внутрішній стан, що не потребує синхронізації — він належить тільки цьому потоку.

```rust
/// Режим роботи агента
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AgentMode {
    /// Патрулювання території
    Patrol,
    
    /// Повернення на базу (низький заряд)
    Returning,
    
    /// Робота завершена
    Stopped,
}

/// Приватний стан агента (не синхронізується)
/// 
/// Цей стан існує тільки всередині потоку агента.
/// Інші потоки не мають до нього доступу — тому
/// ніякої синхронізації не потрібно.
#[derive(Debug)]
pub struct AgentState {
    /// Унікальний ідентифікатор агента
    pub id: u32,
    
    /// Поточна позиція
    pub position: Position,
    
    /// Рівень заряду батареї (0-100)
    pub battery: u8,
    
    /// Поточний режим роботи
    pub mode: AgentMode,
    
    /// Кількість зроблених кроків
    pub steps_taken: u32,
    
    /// Кількість знайдених цілей
    pub targets_found: u32,
    
    /// Позиція бази (для повернення)
    pub base_position: Position,
}

impl AgentState {
    /// Створює новий стан агента
    pub fn new(id: u32, start_position: Position) -> Self {
        Self {
            id,
            position: start_position,
            battery: 100,
            mode: AgentMode::Patrol,
            steps_taken: 0,
            targets_found: 0,
            base_position: start_position,  // База = точка старту
        }
    }
    
    /// Перевіряє, чи потрібно повертатись на базу
    pub fn should_return(&self) -> bool {
        // Повертаємось, якщо батареї залишилось менше, ніж відстань до бази + запас
        let distance = self.position.distance_to(&self.base_position);
        self.battery as u32 <= distance + 5  // +5 як запас безпеки
    }
    
    /// Витрачає енергію на крок
    pub fn consume_energy(&mut self) {
        self.battery = self.battery.saturating_sub(1);
        self.steps_taken += 1;
    }
}
```

**Як працює цей код:**

1. **Немає Arc, Mutex, RwLock:** Цей тип не огорнутий у жодні примітиви синхронізації. Він існує як локальна змінна всередині функції потоку агента.

2. **Метод `should_return`:** Агент приймає рішення про повернення на основі свого стану. Це приклад автономності — агент сам вирішує, коли йому пора додому.

3. **`saturating_sub`:** Безпечне віднімання, що не дозволяє overflow (якщо батарея = 0, залишиться 0, а не 255).

---

## 36.3 РЕАЛІЗАЦІЯ СПІЛЬНИХ РЕСУРСІВ

### 36.3.1 Карта світу: WorldMap

**Постановка задачі:** Карта має зберігати стан кожної клітини та надавати методи для читання і модифікації. Оскільки карта ділиться між потоками, потрібно визначити типи для спільного доступу.

```rust
use std::sync::{Arc, RwLock};

/// Карта світу агентів
/// 
/// Внутрішньо це двовимірний масив клітин.
/// Зовнішній вектор — рядки, внутрішній — клітини в рядку.
pub struct WorldMap {
    cells: Vec<Vec<Cell>>,
    width: usize,
    height: usize,
}

/// Тип-аліас для зручності: спільна карта з RwLock
/// 
/// Arc забезпечує спільне володіння між потоками.
/// RwLock дозволяє багатьом читачам АБО одному писцю.
pub type SharedMap = Arc<RwLock<WorldMap>>;

impl WorldMap {
    /// Створює нову карту заданого розміру, заповнену порожніми клітинами
    pub fn new(width: usize, height: usize) -> Self {
        let cells = vec![vec![Cell::Empty; width]; height];
        Self { cells, width, height }
    }
    
    /// Повертає розміри карти
    pub fn dimensions(&self) -> (usize, usize) {
        (self.width, self.height)
    }
    
    /// Перевіряє, чи позиція в межах карти
    pub fn is_valid_position(&self, pos: &Position) -> bool {
        pos.x >= 0 
            && pos.y >= 0 
            && (pos.x as usize) < self.width 
            && (pos.y as usize) < self.height
    }
    
    /// Отримує тип клітини за позицією
    /// Повертає None, якщо позиція за межами карти
    pub fn get(&self, pos: &Position) -> Option<Cell> {
        if self.is_valid_position(pos) {
            Some(self.cells[pos.y as usize][pos.x as usize])
        } else {
            None
        }
    }
    
    /// Встановлює тип клітини за позицією
    /// Повертає true, якщо операція успішна
    pub fn set(&mut self, pos: &Position, cell: Cell) -> bool {
        if self.is_valid_position(pos) {
            self.cells[pos.y as usize][pos.x as usize] = cell;
            true
        } else {
            false
        }
    }
    
    /// Перевіряє, чи можна пройти в задану позицію
    pub fn is_passable(&self, pos: &Position) -> bool {
        self.get(pos).map_or(false, |cell| cell.is_passable())
    }
    
    /// Позначає клітину як досліджену
    /// Повертає true, якщо клітина була змінена
    pub fn mark_explored(&mut self, pos: &Position) -> bool {
        match self.get(pos) {
            Some(Cell::Empty) => {
                self.set(pos, Cell::Explored);
                true
            }
            _ => false,
        }
    }
    
    /// Позначає знайдену ціль
    /// Повертає true, якщо це була справді ціль
    pub fn mark_target_found(&mut self, pos: &Position) -> bool {
        match self.get(pos) {
            Some(Cell::Target) => {
                self.set(pos, Cell::FoundTarget);
                true
            }
            _ => false,
        }
    }
}
```

**Як працює цей код:**

1. **Структура зберігання:** `Vec<Vec<Cell>>` — вектор рядків, кожен рядок — вектор клітин. Це класичне представлення 2D карти.

2. **Тип-аліас `SharedMap`:** `Arc<RwLock<WorldMap>>` — довгий тип, тому аліас робить код чистішим. Тепер замість `Arc<RwLock<WorldMap>>` пишемо просто `SharedMap`.

3. **Методи з перевіркою меж:** `get` та `set` перевіряють валідність позиції перед доступом, запобігаючи panic.

4. **Семантичні методи:** `mark_explored` та `mark_target_found` інкапсулюють логіку переходу станів. Агент викликає ці методи, не знаючи деталей реалізації.

### 36.3.2 Статистика місії: MissionStatistics

**Постановка задачі:** Потрібно збирати глобальну статистику місії, яка оновлюється з різних потоків.

```rust
use std::sync::{Arc, Mutex};

/// Статистика виконання місії
/// 
/// Оновлюється з різних потоків (агентів),
/// читається координатором для моніторингу.
#[derive(Debug, Default)]
pub struct MissionStatistics {
    /// Загальна кількість досліджених клітин
    pub cells_explored: u32,
    
    /// Кількість знайдених цілей
    pub targets_found: u32,
    
    /// Загальна кількість кроків всіх агентів
    pub total_steps: u32,
    
    /// Кількість агентів, що завершили місію
    pub agents_finished: u32,
}

/// Тип-аліас для спільної статистики
pub type SharedStats = Arc<Mutex<MissionStatistics>>;

impl MissionStatistics {
    /// Створює нову статистику з нульовими значеннями
    pub fn new() -> Self {
        Self::default()
    }
    
    /// Інкрементує лічильник досліджених клітин
    pub fn record_exploration(&mut self) {
        self.cells_explored += 1;
    }
    
    /// Записує знахідку цілі
    pub fn record_target_found(&mut self) {
        self.targets_found += 1;
    }
    
    /// Записує завершення місії агентом
    pub fn record_agent_finished(&mut self, steps: u32) {
        self.agents_finished += 1;
        self.total_steps += steps;
    }
}
```

**Як працює цей код:**

1. **`#[derive(Default)]`:** Автоматично реалізує `Default` trait, де всі поля ініціалізуються нулями. Це дозволяє писати `MissionStatistics::default()` або `Self::default()`.

2. **Mutex замість RwLock:** Для статистики ми обрали `Mutex`, а не `RwLock`. Чому? Операції дуже короткі (інкремент), і RwLock має більші накладні витрати. Плюс, читання статистики відбувається рідко (тільки для відображення), тому оптимізація для читачів непотрібна.

3. **Методи запису:** `record_*` методи інкапсулюють логіку оновлення. Якщо в майбутньому потрібно буде додати логування або валідацію — змінювати потрібно тільки ці методи.

---

## 36.4 ЛОГІКА АГЕНТА: ЦИКЛ PERCEIVE-DECIDE-ACT

### 36.4.1 Класичний цикл автономного агента

Ядро будь-якого автономного агента — це цикл **perceive-decide-act** (сприйняття-рішення-дія). Цей патерн походить з класичної теорії штучного інтелекту і описує, як агент взаємодіє з середовищем:

```text
┌─────────────────────────────────────────────────────────────┐
│                    ЦИКЛ АГЕНТА                               │
│                                                              │
│    ┌──────────┐      ┌──────────┐      ┌──────────┐         │
│    │ PERCEIVE │ ───► │  DECIDE  │ ───► │   ACT    │         │
│    │          │      │          │      │          │         │
│    │ Що навко-│      │ Що роби- │      │ Виконати │         │
│    │ ло мене? │      │ ти далі? │      │ рішення  │         │
│    └──────────┘      └──────────┘      └──────────┘         │
│         ▲                                    │               │
│         │                                    │               │
│         └────────────────────────────────────┘               │
│                    Повторювати                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**PERCEIVE (Сприйняття):** Агент збирає інформацію про своє оточення. В нашому випадку — читає карту навколо своєї позиції, перевіряє рівень батареї.

**DECIDE (Рішення):** На основі сприйнятої інформації та внутрішнього стану, агент обирає наступну дію. Це може бути простий алгоритм (рухатись до найближчої невідомої клітини) або складна логіка (враховувати позиції інших агентів, пріоритети цілей).

**ACT (Дія):** Агент виконує обрану дію — переміщується, позначає клітину, надсилає звіт. Дія змінює або середовище (карту), або стан агента, або обидва.

### 36.4.2 Принципи реалізації циклу агента

**Принцип 1: Мінімізуйте час утримання lock**

Найважливіше правило при роботі зі спільним станом: захопили lock → скопіювали потрібні дані → звільнили lock → працюємо з локальною копією.

**Поганий підхід:**
```rust
// НЕ РОБІТЬ ТАК!
fn perceive_bad(agent: &AgentState, map: &SharedMap) -> Surroundings {
    let guard = map.read().unwrap();
    
    // Тримаємо lock, поки робимо обчислення...
    let mut result = Surroundings::default();
    for direction in Direction::all() {
        let new_pos = agent.position.moved(direction);
        // Складні обчислення під lock
        if guard.is_passable(&new_pos) {
            result.passable_directions.push(direction);
        }
    }
    
    // Lock звільняється тільки тут
    result
}
```

**Правильний підхід:**
```rust
// РОБІТЬ ТАК!
fn perceive_good(agent: &AgentState, map: &SharedMap) -> Surroundings {
    // Швидко копіюємо потрібні дані
    let local_data = {
        let guard = map.read().unwrap();
        // Копіюємо тільки те, що потрібно
        let current = guard.get(&agent.position);
        let neighbors: Vec<_> = Direction::all()
            .iter()
            .map(|d| {
                let pos = agent.position.moved(*d);
                (*d, guard.get(&pos))
            })
            .collect();
        (current, neighbors)
    };  // Lock звільняється ТУТ
    
    // Тепер працюємо з локальними даними без lock
    let (current, neighbors) = local_data;
    Surroundings::from_data(current, neighbors)
}
```

**Принцип 2: Атомарність операцій з точки зору бізнес-логіки**

Якщо операція складається з кількох кроків, які мають бути атомарними (наприклад, "перевірити, чи клітина — ціль, і якщо так — позначити знайденою"), виконуйте їх під одним lock:

```rust
fn process_cell(map: &SharedMap, pos: &Position) -> bool {
    let mut guard = map.write().unwrap();
    
    // Перевірка і модифікація — атомарно
    if guard.get(pos) == Some(Cell::Target) {
        guard.set(pos, Cell::FoundTarget);
        true
    } else {
        false
    }
    // Без атомарності: між перевіркою і модифікацією
    // інший агент міг би змінити клітину!
}
```

### 36.4.3 Структура оточення для передачі результатів сприйняття

**Постановка задачі:** Результат функції `perceive` має містити всю інформацію, потрібну для прийняття рішення, без необхідності повторного доступу до карти.

```rust
/// Інформація про оточення агента
/// 
/// Збирається під час PERCEIVE фази та використовується
/// в DECIDE фазі без повторного доступу до спільних ресурсів.
#[derive(Debug)]
pub struct Surroundings {
    /// Тип клітини, на якій стоїть агент
    pub current_cell: Cell,
    
    /// Прохідні напрямки (куди можна рухатись)
    pub passable_directions: Vec<Direction>,
    
    /// Напрямки, де є невідкриті цілі
    pub target_directions: Vec<Direction>,
    
    /// Напрямки, де є недосліджені клітини
    pub unexplored_directions: Vec<Direction>,
}

impl Surroundings {
    /// Перевіряє, чи є куди рухатись
    pub fn has_options(&self) -> bool {
        !self.passable_directions.is_empty()
    }
    
    /// Чи стоїть агент на невідкритій цілі?
    pub fn standing_on_target(&self) -> bool {
        self.current_cell == Cell::Target
    }
}
```

**Як працює цей код:**

Структура `Surroundings` — це "знімок" оточення агента в конкретний момент. Вона дозволяє функції `decide` працювати без доступу до спільної карти, що зменшує час утримання locks.

### 36.4.4 Повна функція роботи агента

**Постановка задачі:** Реалізувати головну функцію, яка виконується в потоці агента та реалізує повний цикл perceive-decide-act.

```rust
use std::sync::mpsc::Sender;
use std::thread;
use std::time::Duration;

/// Головна функція потоку агента
/// 
/// Ця функція викликається в окремому потоці для кожного агента.
/// Вона реалізує нескінченний цикл perceive-decide-act до завершення місії.
/// 
/// # Параметри
/// - `id`: унікальний ідентифікатор агента
/// - `start_pos`: початкова позиція (зазвичай база)
/// - `map`: спільна карта світу
/// - `stats`: спільна статистика місії
/// - `report_tx`: канал для надсилання звітів координатору
pub fn run_agent(
    id: u32,
    start_pos: Position,
    map: SharedMap,
    stats: SharedStats,
    report_tx: Sender<AgentReport>,
) {
    // Ініціалізація локального стану агента
    let mut state = AgentState::new(id, start_pos);
    
    // Надсилаємо початковий звіт
    let _ = report_tx.send(AgentReport::PositionUpdate {
        agent_id: id,
        position: state.position,
        battery_level: state.battery,
    });
    
    // Головний цикл агента
    while state.mode != AgentMode::Stopped {
        // ═══════════════════════════════════════════════════════
        // ФАЗА 1: PERCEIVE (Сприйняття)
        // ═══════════════════════════════════════════════════════
        let surroundings = perceive(&state, &map);
        
        // ═══════════════════════════════════════════════════════
        // ФАЗА 2: DECIDE (Прийняття рішення)
        // ═══════════════════════════════════════════════════════
        let action = decide(&state, &surroundings);
        
        // ═══════════════════════════════════════════════════════
        // ФАЗА 3: ACT (Виконання дії)
        // ═══════════════════════════════════════════════════════
        execute_action(&mut state, action, &map, &stats, &report_tx);
        
        // Затримка для реалістичності симуляції
        // (в реальній системі це був би час виконання дії)
        thread::sleep(Duration::from_millis(50));
        
        // Перевірка умов завершення
        check_termination_conditions(&mut state, &report_tx);
    }
    
    // Фінальний звіт про завершення
    send_final_report(&state, &report_tx);
}

/// Фаза PERCEIVE: збір інформації про оточення
fn perceive(state: &AgentState, map: &SharedMap) -> Surroundings {
    // Захоплюємо read lock — інші агенти можуть читати паралельно
    let guard = map.read().expect("Карта заблокована (poisoned)");
    
    let current_cell = guard.get(&state.position).unwrap_or(Cell::Empty);
    
    let mut passable = Vec::new();
    let mut targets = Vec::new();
    let mut unexplored = Vec::new();
    
    for direction in Direction::all() {
        let new_pos = state.position.moved(direction);
        
        if let Some(cell) = guard.get(&new_pos) {
            if cell.is_passable() {
                passable.push(direction);
            }
            if cell.is_undiscovered_target() {
                targets.push(direction);
            }
            if cell == Cell::Empty {
                unexplored.push(direction);
            }
        }
    }
    
    // Lock автоматично звільняється при виході з функції
    
    Surroundings {
        current_cell,
        passable_directions: passable,
        target_directions: targets,
        unexplored_directions: unexplored,
    }
}

/// Перелік можливих дій агента
#[derive(Debug)]
enum AgentAction {
    /// Рухатись в напрямку
    Move(Direction),
    
    /// Позначити знайдену ціль
    MarkTarget,
    
    /// Залишатись на місці (немає куди йти)
    Stay,
}

/// Фаза DECIDE: вибір наступної дії
fn decide(state: &AgentState, surroundings: &Surroundings) -> AgentAction {
    // Пріоритет 1: Якщо стоїмо на цілі — позначити
    if surroundings.standing_on_target() {
        return AgentAction::MarkTarget;
    }
    
    // Пріоритет 2: Якщо режим повернення — рухатись до бази
    if state.mode == AgentMode::Returning {
        return decide_return_direction(state, surroundings);
    }
    
    // Пріоритет 3: Якщо є видима ціль — йти до неї
    if let Some(&dir) = surroundings.target_directions.first() {
        return AgentAction::Move(dir);
    }
    
    // Пріоритет 4: Досліджувати нові клітини
    if let Some(&dir) = surroundings.unexplored_directions.first() {
        return AgentAction::Move(dir);
    }
    
    // Пріоритет 5: Рухатись куди завгодно
    if let Some(&dir) = surroundings.passable_directions.first() {
        return AgentAction::Move(dir);
    }
    
    // Немає куди йти
    AgentAction::Stay
}

/// Допоміжна функція: вибір напрямку для повернення на базу
fn decide_return_direction(state: &AgentState, surroundings: &Surroundings) -> AgentAction {
    // Шукаємо напрямок, що наближає до бази
    let mut best_direction = None;
    let mut best_distance = state.position.distance_to(&state.base_position);
    
    for &dir in &surroundings.passable_directions {
        let new_pos = state.position.moved(dir);
        let distance = new_pos.distance_to(&state.base_position);
        
        if distance < best_distance {
            best_distance = distance;
            best_direction = Some(dir);
        }
    }
    
    match best_direction {
        Some(dir) => AgentAction::Move(dir),
        None => AgentAction::Stay,  // Заблоковані, не можемо наблизитись
    }
}

/// Фаза ACT: виконання обраної дії
fn execute_action(
    state: &mut AgentState,
    action: AgentAction,
    map: &SharedMap,
    stats: &SharedStats,
    report_tx: &Sender<AgentReport>,
) {
    match action {
        AgentAction::Move(direction) => {
            // Оновлюємо позицію
            state.position = state.position.moved(direction);
            state.consume_energy();
            
            // Позначаємо клітину як досліджену (якщо вона була Empty)
            {
                let mut guard = map.write().expect("Карта заблокована");
                if guard.mark_explored(&state.position) {
                    // Оновлюємо статистику
                    stats.lock().expect("Статистика заблокована")
                        .record_exploration();
                    
                    // Надсилаємо звіт про дослідження
                    let _ = report_tx.send(AgentReport::CellExplored {
                        agent_id: state.id,
                        position: state.position,
                    });
                }
            }
            
            // Надсилаємо оновлення позиції
            let _ = report_tx.send(AgentReport::PositionUpdate {
                agent_id: state.id,
                position: state.position,
                battery_level: state.battery,
            });
        }
        
        AgentAction::MarkTarget => {
            // Позначаємо ціль як знайдену
            {
                let mut guard = map.write().expect("Карта заблокована");
                if guard.mark_target_found(&state.position) {
                    state.targets_found += 1;
                    
                    // Оновлюємо статистику
                    stats.lock().expect("Статистика заблокована")
                        .record_target_found();
                    
                    // Надсилаємо важливий звіт!
                    let _ = report_tx.send(AgentReport::TargetDiscovered {
                        agent_id: state.id,
                        target_position: state.position,
                        timestamp: std::time::Instant::now(),
                    });
                }
            }
        }
        
        AgentAction::Stay => {
            // Нічого не робимо, але витрачаємо трохи енергії
            state.battery = state.battery.saturating_sub(1);
        }
    }
}

/// Перевірка умов завершення місії
fn check_termination_conditions(
    state: &mut AgentState,
    report_tx: &Sender<AgentReport>,
) {
    // Перевірка батареї
    if state.battery == 0 {
        state.mode = AgentMode::Stopped;
        return;
    }
    
    // Перевірка, чи потрібно повертатись
    if state.mode == AgentMode::Patrol && state.should_return() {
        state.mode = AgentMode::Returning;
        let _ = report_tx.send(AgentReport::Warning {
            agent_id: state.id,
            message: "Низький заряд, повертаюсь на базу".to_string(),
        });
    }
    
    // Перевірка, чи повернулись на базу
    if state.mode == AgentMode::Returning && state.position == state.base_position {
        state.mode = AgentMode::Stopped;
    }
}

/// Надсилання фінального звіту про завершення
fn send_final_report(state: &AgentState, report_tx: &Sender<AgentReport>) {
    let reason = if state.battery == 0 {
        MissionEndReason::BatteryDepleted
    } else {
        MissionEndReason::ReturnedToBase
    };
    
    let _ = report_tx.send(AgentReport::MissionComplete {
        agent_id: state.id,
        reason,
        total_steps: state.steps_taken,
        targets_found: state.targets_found,
    });
}
```

**Як працює цей код:**

1. **Структура функції `run_agent`:** Це точка входу для потоку агента. Вона отримує всі необхідні ресурси (спільні та канал), ініціалізує локальний стан і запускає головний цикл.

2. **Три фази чітко розділені:** `perceive`, `decide`, `execute_action` — окремі функції з чіткою відповідальністю. Це полегшує тестування та модифікацію.

3. **Мінімізація критичних секцій:** В `perceive` ми захоплюємо read lock, копіюємо дані і одразу звільняємо. В `execute_action` write lock захоплюється тільки на час модифікації, а оновлення статистики — окремим lock.

4. **Graceful termination:** Агент перевіряє умови завершення після кожної ітерації та коректно надсилає фінальний звіт.

---

## 36.5 КООРДИНАТОР: СЕРЦЕ СИСТЕМИ

### 36.5.1 Роль та відповідальності координатора

Координатор — це "диригент оркестру", що керує всією системою:

| Відповідальність | Опис |
|------------------|------|
| **Ініціалізація** | Створення карти, розміщення перешкод та цілей |
| **Запуск агентів** | Створення потоків, передача ресурсів |
| **Моніторинг** | Отримання та обробка звітів |
| **Завершення** | Graceful shutdown, збір статистики |

### 36.5.2 Що таке Graceful Shutdown і чому це важливо

**Graceful shutdown** — це коректне завершення багатопотокової програми, при якому:

1. Всі потоки отримують сигнал про завершення
2. Потоки завершують поточні операції (не обриваються посеред роботи)
3. Всі ресурси звільняються коректно
4. Дані не втрачаються і не пошкоджуються

**Чому це важливо?** Уявіть, що агент посеред запису на карту, і ми просто "вбиваємо" потік. Карта може залишитись у неконсистентному стані. Або агент не надішле фінальний звіт, і статистика буде неповною.

**Як досягти graceful shutdown в нашій системі:**

1. Канал звітів природно закривається, коли всі Sender (агенти) завершуються
2. Координатор чекає на `join()` всіх потоків
3. Агенти завершують цикл при досягненні умов завершення

### 36.5.3 Реалізація координатора

**Постановка задачі:** Реалізувати функцію, яка ініціалізує систему, запускає агентів, обробляє їхні звіти та коректно завершує роботу.

```rust
use std::sync::{mpsc, Arc, Mutex, RwLock};
use std::thread::{self, JoinHandle};

/// Конфігурація місії
pub struct MissionConfig {
    pub map_width: usize,
    pub map_height: usize,
    pub num_agents: u32,
    pub num_obstacles: usize,
    pub num_targets: usize,
}

impl Default for MissionConfig {
    fn default() -> Self {
        Self {
            map_width: 20,
            map_height: 20,
            num_agents: 4,
            num_obstacles: 30,
            num_targets: 5,
        }
    }
}

/// Головна функція координатора
/// 
/// Ініціалізує систему, запускає агентів та обробляє звіти.
pub fn run_mission(config: MissionConfig) {
    println!("═══════════════════════════════════════════════════════════");
    println!("       СИСТЕМА КЕРУВАННЯ РОЄМ БПЛА v3.0");
    println!("═══════════════════════════════════════════════════════════");
    println!("Карта: {}×{}", config.map_width, config.map_height);
    println!("Агентів: {}", config.num_agents);
    println!("Цілей: {}", config.num_targets);
    println!();
    
    // ═══════════════════════════════════════════════════════════════
    // ФАЗА 1: Ініціалізація спільних ресурсів
    // ═══════════════════════════════════════════════════════════════
    
    // Створюємо карту та розміщуємо об'єкти
    let map = Arc::new(RwLock::new(
        create_map(&config)
    ));
    
    // Створюємо статистику
    let stats = Arc::new(Mutex::new(MissionStatistics::new()));
    
    // Створюємо канал для звітів
    let (report_tx, report_rx) = mpsc::channel::<AgentReport>();
    
    // ═══════════════════════════════════════════════════════════════
    // ФАЗА 2: Запуск агентів
    // ═══════════════════════════════════════════════════════════════
    
    let mut agent_handles: Vec<JoinHandle<()>> = Vec::new();
    
    // Позиція бази (центр карти)
    let base_position = Position::new(
        (config.map_width / 2) as i32,
        (config.map_height / 2) as i32,
    );
    
    // Позначаємо базу на карті
    {
        let mut guard = map.write().unwrap();
        guard.set(&base_position, Cell::Base);
    }
    
    for agent_id in 1..=config.num_agents {
        // Клонуємо спільні ресурси для кожного агента
        let map_clone = Arc::clone(&map);
        let stats_clone = Arc::clone(&stats);
        let tx_clone = report_tx.clone();
        
        // Запускаємо потік агента
        let handle = thread::spawn(move || {
            println!("[Агент {}] Запущено", agent_id);
            run_agent(agent_id, base_position, map_clone, stats_clone, tx_clone);
        });
        
        agent_handles.push(handle);
    }
    
    // КРИТИЧНО: закриваємо оригінальний Sender!
    // Без цього канал ніколи не закриється
    drop(report_tx);
    
    // ═══════════════════════════════════════════════════════════════
    // ФАЗА 3: Обробка звітів
    // ═══════════════════════════════════════════════════════════════
    
    println!("── Початок місії ──────────────────────────────────────────");
    
    // Обробляємо звіти, поки канал не закриється
    for report in report_rx {
        process_report(&report);
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ФАЗА 4: Очікування завершення та збір результатів
    // ═══════════════════════════════════════════════════════════════
    
    println!("\n── Очікування завершення агентів ─────────────────────────");
    
    for (i, handle) in agent_handles.into_iter().enumerate() {
        match handle.join() {
            Ok(()) => println!("[Координатор] Агент {} завершився успішно", i + 1),
            Err(_) => println!("[Координатор] Агент {} завершився з помилкою!", i + 1),
        }
    }
    
    // ═══════════════════════════════════════════════════════════════
    // ФАЗА 5: Підсумки місії
    // ═══════════════════════════════════════════════════════════════
    
    print_mission_summary(&stats, &config);
}

/// Створення карти з випадковим розміщенням об'єктів
fn create_map(config: &MissionConfig) -> WorldMap {
    use rand::Rng;
    let mut rng = rand::thread_rng();
    
    let mut map = WorldMap::new(config.map_width, config.map_height);
    
    // Розміщуємо перешкоди
    let mut placed = 0;
    while placed < config.num_obstacles {
        let x = rng.gen_range(0..config.map_width as i32);
        let y = rng.gen_range(0..config.map_height as i32);
        let pos = Position::new(x, y);
        
        // Не ставимо в центрі (там буде база)
        let center = Position::new(
            (config.map_width / 2) as i32,
            (config.map_height / 2) as i32,
        );
        if pos.distance_to(&center) > 2 {
            if map.set(&pos, Cell::Obstacle) {
                placed += 1;
            }
        }
    }
    
    // Розміщуємо цілі
    placed = 0;
    while placed < config.num_targets {
        let x = rng.gen_range(0..config.map_width as i32);
        let y = rng.gen_range(0..config.map_height as i32);
        let pos = Position::new(x, y);
        
        if map.get(&pos) == Some(Cell::Empty) {
            if map.set(&pos, Cell::Target) {
                placed += 1;
            }
        }
    }
    
    map
}

/// Обробка одного звіту від агента
fn process_report(report: &AgentReport) {
    match report {
        AgentReport::PositionUpdate { agent_id, position, battery_level } => {
            println!("  [Агент {}] Позиція: ({}, {}), Батарея: {}%",
                     agent_id, position.x, position.y, battery_level);
        }
        
        AgentReport::TargetDiscovered { agent_id, target_position, .. } => {
            println!("  🎯 [Агент {}] ЦІЛЬ ЗНАЙДЕНО на ({}, {})!",
                     agent_id, target_position.x, target_position.y);
        }
        
        AgentReport::CellExplored { agent_id, position } => {
            // Можна пропустити для зменшення виводу
            // println!("  [Агент {}] Досліджено: ({}, {})", agent_id, position.x, position.y);
        }
        
        AgentReport::MissionComplete { agent_id, reason, total_steps, targets_found } => {
            println!("  ✓ [Агент {}] Місію завершено: {:?}, кроків: {}, знайдено цілей: {}",
                     agent_id, reason, total_steps, targets_found);
        }
        
        AgentReport::Warning { agent_id, message } => {
            println!("  ⚠ [Агент {}] {}", agent_id, message);
        }
    }
}

/// Вивід підсумків місії
fn print_mission_summary(stats: &SharedStats, config: &MissionConfig) {
    let stats = stats.lock().unwrap();
    
    let total_cells = config.map_width * config.map_height;
    let exploration_percent = (stats.cells_explored as f64 / total_cells as f64) * 100.0;
    let targets_found_percent = (stats.targets_found as f64 / config.num_targets as f64) * 100.0;
    
    println!();
    println!("═══════════════════════════════════════════════════════════");
    println!("                    ПІДСУМКИ МІСІЇ                          ");
    println!("═══════════════════════════════════════════════════════════");
    println!("  Досліджено клітин:  {} / {} ({:.1}%)",
             stats.cells_explored, total_cells, exploration_percent);
    println!("  Знайдено цілей:     {} / {} ({:.1}%)",
             stats.targets_found, config.num_targets, targets_found_percent);
    println!("  Загальна к-сть кроків: {}", stats.total_steps);
    println!("  Агентів завершило:  {} / {}",
             stats.agents_finished, config.num_agents);
    println!("═══════════════════════════════════════════════════════════");
}
```

**Як працює цей код:**

1. **Фаза ініціалізації:** Створюємо всі спільні ресурси та канал. Важливо зробити це до запуску потоків.

2. **Фаза запуску:** Для кожного агента клонуємо Arc'и та Sender, створюємо потік. Зберігаємо JoinHandle для очікування.

3. **drop(report_tx):** Критично важливий рядок! Без нього оригінальний Sender залишається живим, канал ніколи не закриється, і цикл `for report in report_rx` буде вічним.

4. **Обробка звітів:** Цикл `for report in report_rx` працює, поки є активні агенти. Коли всі агенти завершуються (і їхні Sender drop'аються), канал закривається і цикл завершується.

5. **Join:** Чекаємо на завершення всіх потоків, перевіряємо результат на помилки (panic в потоці).

---

## 36.6 ТЕСТУВАННЯ БАГАТОПОТОКОВОГО КОДУ

### 36.6.1 Виклики тестування паралельного коду

Тестування багатопотокового коду має унікальні складності:

**Недетермінізм:** Порядок виконання потоків непередбачуваний. Тест може проходити 99 разів і провалюватись на 100-й.

**Гонки даних:** Проявляються тільки при певному timing'у, який важко відтворити в тестах.

**Складність відтворення:** Помилка, знайдена в продакшені, може не відтворюватись в тестовому середовищі.

### 36.6.2 Стратегії тестування

**Стратегія 1: Ізольоване тестування компонентів**

Тестуйте окремі функції без багатопотоковості:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_position_movement() {
        let pos = Position::new(5, 5);
        
        assert_eq!(pos.moved(Direction::North), Position::new(5, 4));
        assert_eq!(pos.moved(Direction::South), Position::new(5, 6));
        assert_eq!(pos.moved(Direction::East), Position::new(6, 5));
        assert_eq!(pos.moved(Direction::West), Position::new(4, 5));
    }
    
    #[test]
    fn test_agent_should_return() {
        let mut state = AgentState::new(1, Position::new(0, 0));
        
        // Повна батарея — не повертатись
        state.battery = 100;
        state.position = Position::new(10, 10);  // 20 кроків до бази
        assert!(!state.should_return());
        
        // Низька батарея — повертатись
        state.battery = 20;
        assert!(state.should_return());  // 20 - 5 (запас) < 20 (відстань)
    }
    
    #[test]
    fn test_world_map_operations() {
        let mut map = WorldMap::new(10, 10);
        
        let pos = Position::new(5, 5);
        assert_eq!(map.get(&pos), Some(Cell::Empty));
        
        map.set(&pos, Cell::Obstacle);
        assert_eq!(map.get(&pos), Some(Cell::Obstacle));
        assert!(!map.is_passable(&pos));
        
        // За межами карти
        let invalid = Position::new(100, 100);
        assert_eq!(map.get(&invalid), None);
        assert!(!map.is_passable(&invalid));
    }
}
```

**Стратегія 2: Тестування з контрольованим середовищем**

Створіть детерміновану карту для передбачуваних результатів:

```rust
#[test]
fn test_agent_finds_target() {
    // Створюємо маленьку карту з однією ціллю
    let mut map = WorldMap::new(3, 3);
    map.set(&Position::new(2, 1), Cell::Target);
    
    let shared_map = Arc::new(RwLock::new(map));
    let stats = Arc::new(Mutex::new(MissionStatistics::new()));
    let (tx, rx) = mpsc::channel();
    
    // Запускаємо агента
    let map_clone = Arc::clone(&shared_map);
    let stats_clone = Arc::clone(&stats);
    
    let handle = thread::spawn(move || {
        run_agent(1, Position::new(0, 0), map_clone, stats_clone, tx);
    });
    
    // Збираємо звіти
    let reports: Vec<_> = rx.iter().collect();
    handle.join().unwrap();
    
    // Перевіряємо, що ціль знайдена
    let found_target = reports.iter().any(|r| {
        matches!(r, AgentReport::TargetDiscovered { .. })
    });
    assert!(found_target, "Агент мав знайти ціль");
}
```

**Стратегія 3: Stress-тестування**

Запускайте багато ітерацій для виявлення race conditions:

```rust
#[test]
fn stress_test_concurrent_access() {
    for iteration in 0..100 {
        let map = Arc::new(RwLock::new(WorldMap::new(50, 50)));
        let mut handles = vec![];
        
        // 10 читачів
        for _ in 0..10 {
            let m = Arc::clone(&map);
            handles.push(thread::spawn(move || {
                for _ in 0..1000 {
                    let _ = m.read().unwrap().get(&Position::new(25, 25));
                }
            }));
        }
        
        // 2 писці
        for i in 0..2 {
            let m = Arc::clone(&map);
            handles.push(thread::spawn(move || {
                for j in 0..100 {
                    m.write().unwrap().set(
                        &Position::new(i, j as i32),
                        Cell::Explored,
                    );
                }
            }));
        }
        
        // Всі мають завершитись без паніки
        for h in handles {
            h.join().expect(&format!("Panic in iteration {}", iteration));
        }
    }
}
```

---

## 36.7 ЛАБОРАТОРНА РОБОТА

### Мета роботи

Інтегрувати всі вивчені концепції багатопотоковості Rust у цілісну систему симуляції рою агентів.

### Завдання 1: Базова інфраструктура (3 бали)

Реалізуйте всі типи даних та структури з розділу 36.2:
- `Position`, `Direction` з усіма методами
- `Cell` з методами `is_passable`, `is_undiscovered_target`
- `AgentReport` з усіма варіантами
- `AgentState` з методами `new`, `should_return`, `consume_energy`
- `WorldMap` з `SharedMap` та всіма методами
- `MissionStatistics` з `SharedStats`

**Критерії:**
- Всі типи коректно derive'ять необхідні traits
- Методи працюють правильно (перевірити unit-тестами)

### Завдання 2: Логіка агента (4 бали)

Реалізуйте функції циклу perceive-decide-act:
- `perceive` — збір інформації з карти
- `decide` — вибір дії на основі пріоритетів
- `execute_action` — виконання дії з оновленням карти та статистики
- `run_agent` — головна функція потоку

**Критерії:**
- Агент коректно обходить перешкоди
- Агент знаходить та позначає цілі
- Агент повертається на базу при низькому заряді
- Locks захоплюються на мінімальний час

### Завдання 3: Координатор та інтеграція (3 бали)

Реалізуйте функцію `run_mission`:
- Ініціалізація карти з перешкодами та цілями
- Запуск 4 агентів у окремих потоках
- Обробка звітів у реальному часі
- Graceful shutdown з очікуванням завершення всіх агентів
- Вивід статистики місії

**Критерії:**
- Всі агенти запускаються та завершуються коректно
- Звіти обробляються без втрат
- Програма завершується без зависання чи паніки
- Статистика відображає реальні результати

### Бонусні завдання (+2 бали)

- Візуалізація карти в консолі після кожного кроку
- Реалізація алгоритму пошуку шляху (A* або Dijkstra)
- Додавання координації між агентами (уникнення колізій)

---

## 36.8 ПОШИРЕНІ ПОМИЛКИ ТА TROUBLESHOOTING

### Помилка: Програма зависає на очікуванні звітів

**Симптом:** `for report in report_rx` ніколи не завершується.

**Причина:** Забули `drop(report_tx)` — оригінальний Sender все ще живий.

**Рішення:**
```rust
drop(report_tx);  // Додайте одразу після створення всіх клонів
```

### Помилка: Deadlock при вкладених locks

**Симптом:** Програма зависає випадково.

**Причина:** Один потік тримає lock на карту і намагається захопити lock на статистику, інший — навпаки.

**Рішення:** Завжди захоплюйте locks в одному порядку, або звільняйте один перед захопленням іншого:

```rust
// НЕПРАВИЛЬНО
{
    let map = map.write().unwrap();
    let stats = stats.lock().unwrap();  // Може deadlock
}

// ПРАВИЛЬНО
{
    let mut map_guard = map.write().unwrap();
    // Робота з картою
}  // map_guard звільняється
{
    let mut stats_guard = stats.lock().unwrap();
    // Робота зі статистикою
}
```

### Помилка: panic в потоці без обробки

**Симптом:** Частина агентів "зникає", статистика неповна.

**Рішення:** Завжди перевіряйте результат `join()`:

```rust
for (i, handle) in handles.into_iter().enumerate() {
    if let Err(e) = handle.join() {
        eprintln!("Агент {} запанікував: {:?}", i, e);
    }
}
```

---

## 36.9 РЕЗЮМЕ

### Архітектурні принципи, що ви засвоїли

1. **Розділення відповідальностей:** Кожен компонент системи має чітку роль (координатор керує, агенти виконують, канали передають).

2. **Мінімізація спільного стану:** Ділимо тільки те, що дійсно потрібно ділити. Приватний стан агента — локальний.

3. **Правильний вибір примітивів:** RwLock для read-heavy даних, Mutex для простих оновлень, канали для потоків даних.

4. **Короткі критичні секції:** Захопили lock → скопіювали → звільнили → обробили.

5. **Graceful shutdown:** Система має завершуватись коректно, без втрати даних.

### Еволюція агента через підручник

```rust
Частина 0-I:  Агент = структура даних
              ↓
Частина II:   Агент = автономний об'єкт з поведінкою
              ↓
Частина III:  Агент = паралельний процес у рої
              ↓
Частина IV:   Агент = асинхронний актор (далі)
              ↓
Частина V:    Агент = розподілений вузол (далі)
```

---

## 🔗 ЗВ'ЯЗОК З НАСТУПНОЮ ЧАСТИНОЮ

Вітаємо! Ви завершили **Частину III: Smart Pointers та спільна пам'ять**!

Тепер ви володієте всіма базовими інструментами багатопотоковості Rust. Але потоки мають обмеження: кожен потік споживає значний об'єм пам'яті (типово 1-8 MB для стека). Для тисяч агентів це неприйнятно.

**Частина IV: Асинхронність та масштабування** покаже, як:

- **Async/await** дозволяє тисячі "легких" задач на одному потоці
- **Tokio runtime** ефективно мультиплексує асинхронні задачі
- **Actor model** структурує асинхронний код
- **Rayon** паралелізує CPU-bound обчислення

Рій v4.0 матиме сотні або навіть тисячі агентів на одній машині!

---

> **Наступна частина:** [Частина IV: Асинхронність та масштабування](../part4/README.md)
