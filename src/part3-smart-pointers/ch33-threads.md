# Розділ 33: Threads — багатопотоковість

## Вступ: один працівник чи ціла команда?

До цього моменту всі ваші програми виконувались **послідовно** — одна інструкція за одною, один рядок за одним. Це схоже на одного працівника, що виконує всі завдання по черзі. Швидкий працівник — але все одно один.

Сучасні комп'ютери мають багато процесорних ядер: 4, 8, 16, навіть 64. Використовувати лише одне — все одно що мати команду з десяти людей, де працює тільки один.

**Багатопотоковість** дозволяє виконувати кілька частин програми **одночасно**. Для рою агентів це природна модель: кожен дрон — незалежна сутність, що приймає рішення паралельно з іншими.

Але багатопотоковість має **похмуру репутацію**:
- Data races — перегони за дані
- Deadlocks — взаємне блокування
- Heisenbugs — помилки, що зникають при спробі їх відлагодити
- Невідтворювані збої — працює в 99% випадків, падає в 1%

Rust змінює правила гри: система типів **гарантує** відсутність data races на етапі компіляції. Якщо програма скомпілювалась — певний клас помилок неможливий за визначенням. Це називають **Fearless Concurrency** — безстрашна конкурентність.

---

## 33.1 Процеси та потоки: фундаментальні концепції

### Що таке процес

Коли ви запускаєте програму, операційна система створює **процес**. Процес — це ізольоване середовище виконання:

| Ресурс | Опис |
|--------|------|
| **Адресний простір** | Власна пам'ять, недоступна іншим процесам |
| **Файлові дескриптори** | Відкриті файли, мережеві з'єднання |
| **Потоки** | Один або більше шляхів виконання |

Процеси **ізольовані** один від одного. Якщо один процес "впаде", інші продовжать працювати. Ця ізоляція — і перевага (безпека), і недолік (складність комунікації між процесами).

### Що таке потік

**Потік** (thread) — це незалежний шлях виконання **всередині процесу**. На відміну від процесів, потоки одного процесу **ділять**:

- Адресний простір (heap, глобальні змінні)
- Файлові дескриптори
- Інші ресурси процесу

Але кожен потік має **власні**:

- **Стек** — локальні змінні, виклики функцій
- **Регістри процесора** — поточний стан обчислень
- **Instruction pointer** — де зараз виконання

### Візуалізація структури

```
┌─────────────────────────────────────────────────────────────┐
│                         ПРОЦЕС                               │
│                                                              │
│  ┌────────────────────────────────────────────────────────┐ │
│  │              СПІЛЬНА ПАМ'ЯТЬ (HEAP)                    │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌───────────────┐   │ │
│  │  │ String data │  │ Vec buffer  │  │ HashMap data  │   │ │
│  │  └─────────────┘  └─────────────┘  └───────────────┘   │ │
│  └────────────────────────────────────────────────────────┘ │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │   Потік 1    │  │   Потік 2    │  │   Потік 3    │       │
│  │  ┌────────┐  │  │  ┌────────┐  │  │  ┌────────┐  │       │
│  │  │  Стек  │  │  │  │  Стек  │  │  │  │  Стек  │  │       │
│  │  │ x = 5  │  │  │  │ y = 10 │  │  │  │ z = 15 │  │       │
│  │  └────────┘  │  │  └────────┘  │  │  └────────┘  │       │
│  │  IP: 0x1000  │  │  IP: 0x2000  │  │  IP: 0x3000  │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
└─────────────────────────────────────────────────────────────┘
```

Всі три потоки мають доступ до **спільної пам'яті** (heap), але кожен має **власний стек** та **власний instruction pointer** (IP) — місце, де зараз виконується код.

### Головний потік

Кожна програма починається з **головного потоку** (main thread). Функція `main()` виконується саме в ньому. Головний потік може створювати інші потоки, які називаються **породженими** (spawned).

**Критично важливо:** коли головний потік завершується — **завершується вся програма**. Навіть якщо породжені потоки ще працюють, вони будуть примусово зупинені. Тому головний потік має **дочекатись** завершення важливих потоків.

---

## 33.2 Проблема Data Race

### Чому спільна пам'ять небезпечна

Спільний доступ до пам'яті — це і благо, і прокляття. Благо — бо дозволяє ефективно обмінюватись даними. Прокляття — бо створює можливість для **data race**.

**Аналогія: два бухгалтери та один баланс**

Уявіть двох бухгалтерів, що одночасно працюють з балансом рахунку. Початковий баланс — 1000 грн:

```
Час    Бухгалтер А               Бухгалтер Б              Баланс у БД
─────────────────────────────────────────────────────────────────────
       (Клієнт вносить 500)      (Клієнт знімає 300)      1000
t1     Читає баланс: 1000        Читає баланс: 1000       1000
t2     Обчислює: 1000+500=1500   Обчислює: 1000-300=700   1000
t3     Записує: 1500             (ще обчислює)            1500
t4     (завершено)               Записує: 700             700
```

**Фінальний баланс: 700 грн**

Але правильний результат: 1000 + 500 - 300 = **1200 грн**!

Внесення 500 грн "зникло", бо бухгалтер Б перезаписав результат бухгалтера А. Це і є **data race** — перегони за дані.

### Формальне визначення

**Data race** відбувається, коли виконуються **всі три умови** одночасно:

1. Два або більше потоків доступаються до **однієї ділянки пам'яті**
2. Принаймні один з них виконує **запис**
3. Доступ **не синхронізований** (немає координації)

Наслідки data race:
- **Невизначена поведінка** — результат залежить від випадкового timing
- **Пошкоджені дані** — як у прикладі з балансом
- **Важковідтворювані помилки** — працює в 99% випадків
- **Heisenbugs** — помилка зникає при спробі її відлагодити (бо дебагер змінює timing)

### Підхід Rust: Fearless Concurrency

У C, C++, Java, Python відповідальність за уникнення data races лежить **повністю на програмістові**. Компілятор не перевіряє. Помилки виявляються **під час виконання** — часто в production.

Rust обрав **революційний підхід**: перенести перевірку на етап компіляції. Система ownership та типів кодує правила потокобезпеки:

- **Trait Send** — "цей тип можна передати в інший потік"
- **Trait Sync** — "на цей тип можна посилатись з різних потоків"

Якщо код порушує ці правила — він **не скомпілюється**. Не "може впасти в runtime", не "іноді працює неправильно" — просто не компілюється.

---

## 33.3 Створення потоків

### Функція thread::spawn

Модуль `std::thread` надає функції для роботи з потоками. Основна — `spawn`, що приймає замикання і виконує його в новому потоці.

**Постановка задачі:** Продемонструвати паралельне виконання двох потоків — головного та породженого.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    // spawn створює новий потік і виконує в ньому замикання
    // Повертає JoinHandle — "ручку" для взаємодії з потоком
    let handle = thread::spawn(|| {
        for i in 1..5 {
            println!("Породжений потік: ітерація {}", i);
            thread::sleep(Duration::from_millis(100));
        }
    });
    
    // Цей код виконується в головному потоці ОДНОЧАСНО з породженим
    for i in 1..3 {
        println!("Головний потік: ітерація {}", i);
        thread::sleep(Duration::from_millis(100));
    }
    
    // join() блокує головний потік, поки породжений не завершиться
    handle.join().unwrap();
    
    println!("Обидва потоки завершились");
}
```

**Можливий вивід:**
```
Головний потік: ітерація 1
Породжений потік: ітерація 1
Головний потік: ітерація 2
Породжений потік: ітерація 2
Породжений потік: ітерація 3
Породжений потік: ітерація 4
Обидва потоки завершились
```

**Як це працює:**

1. `thread::spawn(|| {...})` створює новий потік і запускає в ньому замикання
2. Після виклику spawn обидва потоки працюють **одночасно**
3. Повідомлення переплітаються — порядок може змінюватись від запуску до запуску
4. `thread::sleep` призупиняє поточний потік, даючи іншим можливість працювати
5. `handle.join()` **блокує** головний потік, поки породжений не закінчить
6. Тільки після завершення породженого потоку головний продовжує

### Чому потрібен join

**Постановка задачі:** Показати, що без join породжений потік може не встигнути виконатись.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        // Цей код, ймовірно, НЕ виконається!
        thread::sleep(Duration::from_millis(500));
        println!("Породжений потік: завершення роботи");
    });
    
    // Головний потік завершується майже одразу
    println!("Головний потік: завершення");
    // Програма завершується, породжений потік знищується
}
```

**Вивід:**
```
Головний потік: завершення
```

**Як це працює:**

Породжений потік не встигає навіть "прокинутись" після sleep. Головний потік завершує main() — і вся програма завершується, примусово зупиняючи всі породжені потоки.

**Виправлення — додаємо join:**

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        thread::sleep(Duration::from_millis(500));
        println!("Породжений потік: завершення роботи");
    });
    
    println!("Головний потік: чекаю...");
    handle.join().unwrap();  // Блокуємо, поки породжений не закінчить
    println!("Головний потік: завершення");
}
```

### Обробка паніки в потоках

**Постановка задачі:** Показати, що паніка в породженому потоці не вбиває головний.

```rust
use std::thread;

fn main() {
    let handle = thread::spawn(|| {
        panic!("Щось пішло не так!");
    });
    
    // Головний потік ПРОДОВЖУЄ працювати!
    println!("Головний потік: продовжую роботу");
    
    // join() повертає Err, якщо породжений потік запанікував
    match handle.join() {
        Ok(_) => println!("Потік завершився успішно"),
        Err(_) => println!("Потік запанікував, але ми продовжуємо"),
    }
    
    println!("Програма завершується коректно");
}
```

**Як це працює:**

Паніка в потоці **ізольована**. Інші потоки продовжують працювати. Головний потік може обробити цю ситуацію через `Result` від `join()`. Для рою агентів це критично: якщо один агент "впаде" — решта продовжить місію.

---

## 33.4 Передача даних у потоки

### Проблема з посиланнями

Що якщо породжений потік потребує даних з головного?

**Постановка задачі:** Показати, чому наївний підхід не працює.

```rust
use std::thread;

fn main() {
    let message = String::from("Привіт з головного потоку");
    
    // ❌ Цей код НЕ скомпілюється!
    let handle = thread::spawn(|| {
        println!("{}", message);  // Замикання "захоплює" message
    });
    
    handle.join().unwrap();
}
```

**Помилка компіляції:**
```
error[E0373]: closure may outlive the current function,
              but it borrows `message`
```

**Чому це небезпечно:**

Замикання за замовчуванням **запозичує** змінні — зберігає посилання `&message`. Але породжений потік може жити **довше**, ніж функція main(). Якщо message буде звільнено раніше — породжений потік матиме **звисле посилання** (dangling reference).

Rust бачить потенційну небезпеку і відмовляється компілювати.

### Рішення: ключове слово move

Ключове слово `move` змінює поведінку замикання: замість запозичення воно **забирає володіння** всіма захопленими змінними.

**Постановка задачі:** Показати правильний спосіб передачі даних у потік.

```rust
use std::thread;

fn main() {
    let message = String::from("Привіт з головного потоку");
    
    // move переміщує володіння message у замикання
    let handle = thread::spawn(move || {
        // message тепер належить цьому потоку
        println!("{}", message);
    });
    
    // ❌ Ця строка НЕ скомпілюється!
    // message вже переміщено в потік
    // println!("{}", message);
    
    handle.join().unwrap();
}
```

**Як це працює:**

1. `move` перед замиканням каже: "забери володіння всіма захопленими змінними"
2. `message` переміщується **в** замикання — головний потік більше не володіє нею
3. Породжений потік має **ексклюзивне володіння** — безпечно використовувати
4. Компілятор заборонить використання `message` після spawn — вона вже не існує тут

### Copy типи та move

Для типів з trait `Copy` (числа, bool, char) поведінка дещо інша:

**Постановка задачі:** Показати, що Copy типи копіюються, а не переміщуються.

```rust
use std::thread;

fn main() {
    let x = 42;        // i32 реалізує Copy
    let flag = true;   // bool реалізує Copy
    
    let handle = thread::spawn(move || {
        // x та flag СКОПІЙОВАНО в замикання
        println!("x = {}, flag = {}", x, flag);
    });
    
    // Оригінальні змінні все ще доступні!
    println!("В головному потоці: x = {}, flag = {}", x, flag);
    
    handle.join().unwrap();
}
```

**Як це працює:**

Для Copy типів "переміщення" еквівалентне **копіюванню**. Оригінал залишається в головному потоці, копія йде в породжений. Обидва потоки мають незалежні значення.

### Передача структур

**Постановка задачі:** Передати складну структуру з даними задачі агента.

```rust
use std::thread;

struct AgentTask {
    id: u32,
    name: String,
    target: (f64, f64),
}

fn main() {
    let task = AgentTask {
        id: 1,
        name: String::from("Scout-Alpha"),
        target: (100.0, 200.0),
    };
    
    // Вся структура переміщується в потік
    let handle = thread::spawn(move || {
        println!(
            "Агент {} (ID: {}) прямує до {:?}",
            task.name, task.id, task.target
        );
        
        // Симуляція роботи агента...
        task.target  // Повертаємо фінальну позицію
    });
    
    let final_position = handle.join().unwrap();
    println!("Агент досяг: {:?}", final_position);
}
```

---

## 33.5 Send та Sync: маркерні traits

### Концепція маркерних traits

У Rust є особливий вид traits — **маркерні** (marker traits). Вони не містять жодних методів; їх мета — позначити, що тип має **певну властивість**. Компілятор використовує цю інформацію для перевірок безпеки.

`Send` та `Sync` — найважливіші маркерні traits для багатопотоковості.

### Trait Send: передача між потоками

**Send** означає: "значення цього типу можна безпечно **передати** (move) в інший потік".

Коли ви викликаєте `thread::spawn(move || { ... })`, компілятор перевіряє: чи всі захоплені змінні реалізують Send? Якщо хоча б одна ні — код не скомпілюється.

**Типи, що реалізують Send:**
- Примітивні типи: `i32`, `f64`, `bool`, `char`
- Колекції: `String`, `Vec<T>`, `HashMap<K, V>` (якщо елементи Send)
- Розумні вказівники: `Box<T>`, `Arc<T>` (якщо T: Send)

**Типи, що НЕ реалізують Send:**
- `Rc<T>` — лічильник посилань не атомарний
- Сирі вказівники: `*const T`, `*mut T`

### Trait Sync: спільний доступ з різних потоків

**Sync** означає: "на значення цього типу можна безпечно **посилатись** (`&T`) з різних потоків одночасно".

Формальне визначення: тип `T` є `Sync`, якщо `&T` є `Send`.

**Типи, що реалізують Sync:**
- Примітивні типи (незмінні — безпечні для читання)
- Іммутабельні структури (якщо всі поля Sync)
- `Mutex<T>`, `RwLock<T>` (спеціально для синхронізації)

**Типи, що НЕ реалізують Sync:**
- `Cell<T>`, `RefCell<T>` — мутація без синхронізації
- `Rc<T>` — лічильник не атомарний

### Чому Rc не Send

**Постановка задачі:** Пояснити, чому Rc не можна передавати між потоками.

```
Потік A                         Потік B
───────                         ───────
rc.clone()                      rc.clone()
    ↓                               ↓
читає count (count = 1)         читає count (count = 1)
count = 1 + 1 = 2               count = 1 + 1 = 2
записує count                   записує count
    ↓                               ↓
count = 2                       count = 2

Очікували: count = 3
Отримали:  count = 2  ← DATA RACE!
```

Лічильник Rc оновлюється **не атомарно** — читання та запис відбуваються окремо. Між ними інший потік може втрутитись. Для потоків існує **Arc** (Atomic Reference Counting) — Розділ 34.

### Автоматична реалізація

Rust **автоматично** реалізує Send та Sync для вашого типу, якщо всі його поля їх реалізують:

```rust
// ✅ Ця структура автоматично Send + Sync
struct Agent {
    name: String,      // String: Send + Sync
    position: f64,     // f64: Send + Sync
    active: bool,      // bool: Send + Sync
}

// ❌ Ця структура НЕ Send і НЕ Sync
use std::rc::Rc;

struct UnsafeAgent {
    data: Rc<String>,  // Rc: !Send, !Sync
}
```

Спроба передати `UnsafeAgent` у потік дасть чітку помилку компіляції:

```
error[E0277]: `Rc<String>` cannot be sent between threads safely
```

---

## 33.6 Повернення значень з потоків

### Потік як обчислювальна одиниця

Потік — не тільки спосіб виконати побічні ефекти. Потік може **обчислювати** та повертати результат.

**Постановка задачі:** Обчислити суму чисел у окремому потоці та отримати результат.

```rust
use std::thread;

fn main() {
    // Замикання повертає u64
    // Тип handle: JoinHandle<u64>
    let handle = thread::spawn(|| {
        let sum: u64 = (1..=1_000_000).sum();
        sum  // Це значення буде повернено
    });
    
    // join() повертає Result<u64, ...>
    let result = handle.join().unwrap();
    
    println!("Сума 1..1_000_000 = {}", result);
}
```

**Як це працює:**

1. `JoinHandle<T>` параметризований типом повернення замикання
2. `join()` повертає `Result<T, Box<dyn Any>>`
3. `Ok(value)` — якщо потік завершився успішно
4. `Err(_)` — якщо потік запанікував

### Паралельні обчислення: Fork-Join патерн

**Постановка задачі:** Розподілити обчислення суми на 4 потоки.

```rust
use std::thread;

fn main() {
    const TOTAL: u64 = 1_000_000;
    const NUM_THREADS: u64 = 4;
    const CHUNK: u64 = TOTAL / NUM_THREADS;
    
    // Fork: створюємо потоки, кожен обчислює частину
    let handles: Vec<_> = (0..NUM_THREADS)
        .map(|i| {
            thread::spawn(move || {
                let start = i * CHUNK + 1;
                let end = (i + 1) * CHUNK;
                let partial_sum: u64 = (start..=end).sum();
                
                println!("Потік {}: сума {}..{} = {}", i, start, end, partial_sum);
                partial_sum
            })
        })
        .collect();
    
    // Join: збираємо результати
    let total: u64 = handles
        .into_iter()
        .map(|h| h.join().unwrap())
        .sum();
    
    println!("Загальна сума: {}", total);
}
```

**Як це працює:**

1. **Fork**: створюємо 4 потоки, кожен обчислює свій діапазон
2. Потоки працюють **паралельно** на різних ядрах процесора
3. **Join**: збираємо часткові суми та додаємо їх
4. На 4-ядерному процесорі — до 4x швидше!

---

## 33.7 Практичний приклад: паралельні агенти

**Постановка задачі:** Кожен агент — окремий потік, що виконує свою "місію".

```rust
use std::thread;
use std::time::Duration;

struct Agent {
    id: String,
    position: (f64, f64),
}

impl Agent {
    fn new(id: &str) -> Self {
        Self {
            id: id.to_string(),
            position: (0.0, 0.0),
        }
    }
    
    fn run(&mut self) -> (f64, f64) {
        for step in 0..5 {
            // Симуляція руху
            self.position.0 += 1.0;
            self.position.1 += 0.5;
            
            println!("[{}] Крок {}: позиція {:?}", 
                     self.id, step, self.position);
            
            thread::sleep(Duration::from_millis(50));
        }
        
        println!("[{}] Місію завершено!", self.id);
        self.position
    }
}

fn main() {
    println!("=== Запуск рою агентів ===\n");
    
    let mut handles = vec![];
    
    // Створюємо 3 агенти в окремих потоках
    for i in 0..3 {
        let id = format!("AGENT-{:03}", i);
        
        handles.push(thread::spawn(move || {
            let mut agent = Agent::new(&id);
            agent.run()  // Повертаємо фінальну позицію
        }));
    }
    
    // Збираємо результати
    println!("\n=== Очікуємо завершення ===");
    
    let final_positions: Vec<(f64, f64)> = handles
        .into_iter()
        .map(|h| h.join().unwrap())
        .collect();
    
    println!("\n=== Фінальні позиції ===");
    for (i, pos) in final_positions.iter().enumerate() {
        println!("Агент {}: {:?}", i, pos);
    }
}
```

**Вивід (порядок може змінюватись):**
```
=== Запуск рою агентів ===

[AGENT-000] Крок 0: позиція (1.0, 0.5)
[AGENT-001] Крок 0: позиція (1.0, 0.5)
[AGENT-002] Крок 0: позиція (1.0, 0.5)
[AGENT-000] Крок 1: позиція (2.0, 1.0)
...
[AGENT-002] Місію завершено!

=== Фінальні позиції ===
Агент 0: (5.0, 2.5)
Агент 1: (5.0, 2.5)
Агент 2: (5.0, 2.5)
```

---

## 33.8 Обмеження поточної моделі

### Що ми НЕ можемо зробити

З інструментами цього розділу ми вміємо:
- ✅ Створювати потоки
- ✅ Передавати дані через move
- ✅ Отримувати результати через join

Але є **фундаментальні обмеження**:

1. **Немає спільного мутабельного стану** — кожен потік має власні дані
2. **Немає комунікації під час виконання** — потоки не обмінюються повідомленнями
3. **Немає координації** — неможливо синхронізувати дії

### Спроба використати Rc + RefCell

**Постановка задачі:** Показати, чому Rc<RefCell<T>> не працює між потоками.

```rust
use std::rc::Rc;
use std::cell::RefCell;
use std::thread;

fn main() {
    let counter = Rc::new(RefCell::new(0));
    let counter_clone = Rc::clone(&counter);
    
    // ❌ Помилка компіляції!
    thread::spawn(move || {
        *counter_clone.borrow_mut() += 1;
    });
}
```

**Помилка:**
```
error[E0277]: `Rc<RefCell<i32>>` cannot be sent between threads safely
```

Rust **правильно** відмовляється компілювати. Rc не Send (лічильник не атомарний), RefCell не Sync (перевірки не синхронізовані).

### Потреби рою агентів

Для справжнього рою потрібно:
- **Спільна карта світу** — всі агенти читають і оновлюють
- **Координація дій** — розподіл цілей
- **Збір статистики** — центральний моніторинг

Рішення — в наступних розділах:
- **Розділ 34**: `Arc<T>` та `Mutex<T>` для спільного стану
- **Розділ 35**: Channels для комунікації

---

## 33.9 Лабораторна робота

**Мета:** Набути практичних навичок створення потоків.

### Частина 1: Паралельний пошук (4 бали)

Створіть масив з 1000 чисел. Розділіть на 4 частини та шукайте число паралельно в 4 потоках.

### Частина 2: Симуляція агентів (4 бали)

5 агентів у 5 потоках виконують по 10 "кроків" і повертають фінальну позицію.

### Частина 3: Обробка паніки (2 бали)

3 потоки, один панікує. Головний потік має обробити gracefully.

---

## Підсумок

| Концепція | Опис |
|-----------|------|
| **Потік** | Незалежний шлях виконання |
| **spawn** | Створення нового потоку |
| **join** | Очікування завершення потоку |
| **move** | Передача володіння в потік |
| **Send** | Тип можна передати між потоками |
| **Sync** | На тип можна посилатись з різних потоків |

**Ключові правила:**

- ✅ `thread::spawn(move || {...})` для створення потоків
- ✅ Завжди викликайте `join()` для важливих потоків
- ✅ Rust гарантує відсутність data races на етапі компіляції
- ⚠️ Rc не Send — використовуйте Arc
- ⚠️ RefCell не Sync — використовуйте Mutex

---

## Зв'язок з наступним розділом

Потоки створені, але ізольовані. Кожен має власні дані без спільного доступу. Для рою агентів потрібно **ділити карту**, **координувати дії**.

У **Розділі 34: Arc та Mutex** ви навчитесь:
- Чому потрібен **атомарний** лічильник посилань (Arc)
- Як **Mutex** гарантує ексклюзивний доступ
- Як комбінувати `Arc<Mutex<T>>` для **спільного мутабельного стану**
