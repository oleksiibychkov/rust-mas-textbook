# РОЗУМ РОЮ

## Програмування мультиагентних систем мовою Rust

---

# ПЕРЕДМОВА

---

## Чому ця книга?

Уявіть зграю шпаків над вечірнім полем. Тисячі птахів рухаються як єдиний організм — без диригента, без центрального командира, без заздалегідь прописаного сценарію. Кожен птах бачить лише своїх найближчих сусідів, приймає прості локальні рішення — а в результаті виникає захоплюючий танець колективного інтелекту.

Це і є **рій**. Це і є **мультиагентна система** в дії.

Тепер уявіть, що ви можете програмувати такі системи. Не одного "розумного" агента, а десятки, сотні, тисячі автономних сутностей, що взаємодіють, координуються, адаптуються. Безпілотні літальні апарати, що разом шукають зниклих людей. Роботи-складальники, що самоорганізуються на виробництві. Програмні агенти, що торгують на біржі, модерують контент, оптимізують логістику.

Ця книга — ваш провідник у цей світ. Але не просто провідник — а провідник, що дає вам **правильний інструмент** для цієї подорожі.

---

## Мультиагентні системи: Колективний інтелект

### Що таке агент?

**Агент** — це автономна сутність, що:
- **Сприймає** своє середовище (через сенсори, дані, повідомлення)
- **Приймає рішення** на основі своїх цілей та знань
- **Діє** на середовище (рухається, комунікує, змінює стан)

Агент — це не просто об'єкт з методами. Агент має **автономію**: він сам вирішує, що робити. Агент має **проактивність**: він не чекає команд, а діє заради своїх цілей. Агент має **соціальність**: він взаємодіє з іншими агентами.

### Від одного агента до рою

Один агент — це цікаво. Але справжня магія починається, коли агентів **багато**.

**Мультиагентна система (МАС)** — це система, де кілька агентів взаємодіють для досягнення індивідуальних або спільних цілей. І тут виникають унікальні виклики:

- **Координація**: Як агенти домовляються, хто що робить?
- **Комунікація**: Як вони обмінюються інформацією?
- **Конфлікти**: Що робити, коли цілі агентів суперечать?
- **Емерджентність**: Як з простих локальних правил виникає складна глобальна поведінка?
- **Масштабування**: Як система працює з 10 агентами? А з 10 000?
- **Відмовостійкість**: Що відбувається, коли частина агентів виходить з ладу?

Ці питання роблять мультиагентні системи одночасно захопливими та складними. І саме тут вибір мови програмування стає критично важливим.

### Де застосовуються МАС?

Мультиагентні системи — це не абстрактна академічна концепція. Вони працюють прямо зараз:

- **Робототехніка**: Рої дронів для пошуково-рятувальних операцій, сільськогосподарські роботи, складська логістика
- **Розумні міста**: Координація транспортних потоків, енергетичних мереж, аварійних служб
- **Фінанси**: Алгоритмічна торгівля, виявлення шахрайства, оптимізація портфелів
- **Ігри та симуляції**: NPC з реалістичною поведінкою, військові симулятори, тренажери
- **Кібербезпека**: Розподілене виявлення вторгнень, автономний захист мереж
- **Інтернет речей (IoT)**: Мільйони пристроїв, що координуються без центрального сервера

---

## Чому Rust?

### Три шляхи керування пам'яттю

Коли ми будуємо системи з десятками паралельних агентів, що обмінюються даними, питання керування пам'яттю стає критичним. Історично існувало два підходи:

**Шлях перший: Ручне керування (C, C++)**

Програміст вручну виділяє та звільняє пам'ять. Це дає максимальну швидкість та контроль, але відкриває двері небезпечним помилкам:
- *Висячі вказівники* — посилання на вже звільнену пам'ять
- *Подвійне звільнення* — спроба звільнити те саме двічі
- *Витоки пам'яті* — забули звільнити, і пам'ять "тече"
- *Гонки даних* — два потоки одночасно змінюють одні дані

У мультиагентній системі, де десятки потоків обмінюються повідомленнями, ці помилки стають не просто можливими — вони стають неминучими. І найгірше: вони проявляються не при написанні коду, а під час виконання — через години, дні, тижні роботи системи.

**Шлях другий: Збирач сміття (Java, Python, Go, C#)**

Автоматичний процес (Garbage Collector) періодично шукає та звільняє невикористану пам'ять. Це значно безпечніше та простіше, але має свою ціну:
- *Непередбачувані паузи* — GC може "заморозити" програму в будь-який момент
- *Накладні витрати* — додаткова пам'ять та процесорний час на роботу GC
- *Менший контроль* — ви не знаєте точно, коли пам'ять звільниться

Для системи реального часу, де рій БПЛА має реагувати за мілісекунди, непередбачувана пауза GC може означати катастрофу.

**Шлях третій: Rust**

Rust пропонує революційний підхід: **безпека пам'яті на етапі компіляції без збирача сміття**.

Це не компроміс між двома таборами. Це принципово новий шлях, що дає переваги обох підходів без їхніх недоліків.

### Система володіння: Серце Rust

В основі Rust лежить концепція **володіння (ownership)** — набір правил, які компілятор перевіряє під час збірки:

1. **Кожне значення має рівно одного власника** — змінну, що ним володіє
2. **В один момент може бути лише один власник** — при передачі значення старий власник втрачає доступ
3. **Коли власник виходить з області видимості — значення автоматично звільняється**

Це як фізичний об'єкт: якщо ви віддали комусь книгу — у вас її більше немає. Ви не можете читати книгу, яку віддали.

### Запозичення: Контрольований доступ

Що робити, якщо ви не хочете віддавати книгу назавжди, а лише дати почитати? Rust має систему **запозичення (borrowing)** з суворими правилами:

- Ви можете мати **одне змінюване посилання** (`&mut T`) — для читання та запису
- АБО **безліч незмінних посилань** (`&T`) — тільки для читання
- **Ніколи обидва одночасно**

Компілятор (Borrow Checker) перевіряє ці правила під час збірки. Результат? **Гонки даних неможливі за визначенням**. Не "малоймовірні", не "виявляються тестами" — математично неможливі.

### Час життя: Гарантія валідності

Rust відстежує **час життя (lifetime)** кожних даних та кожного посилання. Компілятор перевіряє просте правило: жодне посилання не може "пережити" дані, на які воно вказує.

Спроба повернути посилання на локальну змінну? Компілятор не дасть зібрати програму. "Висячі" вказівники неможливі — не завдяки перевіркам під час виконання, а завдяки доведенню коректності на етапі компіляції.

### Відсутність null

У Rust немає `null`. Якщо значення може бути відсутнім, ви використовуєте тип `Option<T>`:
- `Some(value)` — значення є
- `None` — значення відсутнє

Ви не можете "забути" перевірити на відсутність — компілятор змусить обробити обидва випадки. "Помилка на мільярд доларів" (NullPointerException) просто не існує в Rust.

---

## Rust проти C та C++: Чесне порівняння

### Однакова продуктивність, різна безпека

Rust компілюється в той самий машинний код, що й C або C++. Немає інтерпретатора, немає віртуальної машини, немає збирача сміття. **Абстракції з нульовою вартістю (zero-cost abstractions)** означають, що високорівневі конструкції Rust (ітератори, дженеріки, pattern matching) компілюються в такий самий ефективний код, як якби ви написали його вручну на C.

Але при однаковій швидкості Rust дає те, чого C та C++ не можуть: **гарантії безпеки на етапі компіляції**.

### Що Rust усуває

| Клас помилок | C/C++ | Rust |
|--------------|-------|------|
| Висячі вказівники | Можливі, виявляються при падінні | Неможливі (Borrow Checker) |
| Подвійне звільнення | Можливе, UB | Неможливе (Ownership) |
| Витоки пам'яті | Часті | Рідкісні (RAII) |
| Переповнення буфера | Критична вразливість | Перевірка меж |
| Null pointer dereference | Можливе | Неможливе (Option) |
| Гонки даних | Дуже ймовірні | Неможливі (Send/Sync) |
| Use-after-free | Можливе, UB | Неможливе (Lifetimes) |

*UB = Undefined Behavior — непередбачувана поведінка*

### Чому це критично для МАС

У мультиагентній системі ці проблеми примножуються:

**Паралелізм**: Кожен агент може працювати в окремому потоці. У C++ синхронізація — це ваша відповідальність. Забули mutex? Гонка даних. Взяли mutex у неправильному порядку? Deadlock. У Rust компілятор перевірить, що ви не можете отримати доступ до даних без належної синхронізації.

**Комунікація**: Агенти обмінюються повідомленнями. Хто володіє повідомленням після відправки? У C++ — невизначено. У Rust — чітко: відправник передає володіння, отримувач стає новим власником.

**Масштабування**: Система з 100 агентами має сотні можливих взаємодій. У C++ кожна взаємодія — потенційна помилка пам'яті. У Rust — кожна взаємодія перевірена компілятором.

**Довготривала робота**: Рій БПЛА може працювати годинами. Витік пам'яті в C++ накопичується. Rust гарантує звільнення ресурсів.

### "Битва з компілятором"

Початківці часто скаржаться, що компілятор Rust "занадто прискіпливий". Він не дає зібрати код, який компілятор C++ пропустив би без питань.

Але ця "битва" — це не недолік, а перевага. Компілятор Rust — суворий наставник, що змушує вас довести безпечність коду **до** його запуску, а не сподіватися, що помилка не проявиться **під час** виконання.

Коли програма на Rust нарешті компілюється, ви отримуєте впевненість, якої жодна кількість тестів у C++ не може дати: ваш код не впаде через помилки пам'яті чи гонки даних.

---

## Чому не можна просто покращити компілятор C++?

Після прочитання попередніх розділів у вас може виникнути логічне запитання: якщо переваги Rust — це перевірки компілятора, то чому б просто не створити такий самий потужний компілятор для C++? Це поширене непорозуміння, яке варто розібрати детально.

### Справа не в компіляторі, а в дизайні мови

Особливості Rust — це **не просто "розумний компілятор"**. Це **дизайн самої мови**, який робить перевірки можливими. Компілятор C++ не може робити такі ж перевірки, тому що **сама мова C++ не надає йому достатньо інформації**.

### Проблема C++: мова не має потрібних концепцій

**Володіння (Ownership) — не виражене в типах C++**

```cpp
// C++: Хто володіє цим об'єктом? Компілятор не знає.
void process(std::string* s);  // Функція забирає володіння? Просто читає? Невідомо.
```

```rust
// Rust: Володіння явне в сигнатурі функції
fn process(s: String);       // Забирає володіння
fn process(s: &String);      // Тільки читає (позичає)
fn process(s: &mut String);  // Модифікує (позичає мутабельно)
```

Компілятор C++ **не знає**, чи функція "забирає" об'єкт, чи просто використовує. Ця інформація не записана в мові — вона існує лише в голові програміста та, можливо, в коментарях.

**Час життя (Lifetimes) — відсутній як концепція**

```cpp
// C++: Компілятор не знає, як довго живе посилання
int* get_ref() {
    int x = 42;
    return &x;  // Висячий вказівник! Компілятор може попередити, але не гарантує.
}
```

```rust
// Rust: Час життя — частина системи типів
fn get_ref<'a>() -> &'a i32 {
    let x = 42;
    &x  // ПОМИЛКА КОМПІЛЯЦІЇ: x не живе достатньо довго
}
```

У Rust `'a` — це **параметр часу життя**, частина системи типів. Компілятор **математично доводить**, що посилання валідне. У C++ такої інформації в типах просто немає — компілятору нічого аналізувати.

**Ексклюзивний доступ — не контролюється**

```cpp
// C++: Нічого не заважає мати два вказівники на ті самі дані
int* a = &x;
int* b = &x;
*a = 1;  // Змінюємо через a
*b = 2;  // Змінюємо через b — можливо, в іншому потоці? Гонка даних.
```

```rust
// Rust: &mut гарантує ексклюзивність
let a = &mut x;
let b = &mut x;  // ПОМИЛКА КОМПІЛЯЦІЇ: не можна мати два &mut одночасно
```

### Чому неможливо "покращити" компілятор C++?

**Зворотна сумісність**

Мільярди рядків коду C++ вже існують і працюють. Якщо новий компілятор почне відхиляти "небезпечний" код — він зламає майже всі існуючі проєкти. Жодна компанія не прийме компілятор, що не збирає їхню кодову базу.

**Мова явно дозволяє небезпечні речі**

C++ **за дизайном** дозволяє:
- Сирі вказівники без будь-яких обмежень
- Довільну арифметику вказівників
- Неініціалізовані змінні
- Неявні конверсії типів

Компілятор не може заборонити те, що мова явно дозволяє. Це було б порушенням стандарту мови.

**Семантика не виражена в типах**

```cpp
void transfer(Account* from, Account* to);
```

Компілятор C++ бачить: "два вказівники на Account". Він **не знає**:
- Чи можуть вони вказувати на той самий об'єкт?
- Чи функція модифікує їх?
- Чи функція зберігає вказівники кудись для пізнішого використання?
- Як довго ці об'єкти мають існувати?

У Rust вся ця інформація **закодована в системі типів**, і компілятор її бачить та перевіряє.

### Аналогія: Бухгалтерський облік

Уявіть два підходи до фінансового обліку:

**C++** — це записи на серветках: "Петро винен Марії гроші". Аудитор (компілятор) може спробувати розібратися, але інформації недостатньо. Скільки винен? Коли повернути? Чи вже повернув? Невідомо.

**Rust** — це подвійний запис з підписами: кожна транзакція має дебет і кредит, підписи сторін, дату, суму. Аудитор може **математично довести** баланс.

Ви не можете зробити "кращого аудитора" для серветок — потрібна **інша система обліку**. Так само ви не можете зробити "кращий компілятор" для C++ — потрібна інша мова.

### Спроби покращити C++: латки замість фундаменту

Спроби зробити C++ безпечнішим існують:

- **Smart pointers** (`unique_ptr`, `shared_ptr`) — допомагають, але їх використання не обов'язкове, і вони не вирішують усіх проблем
- **Static analyzers** (Clang-Tidy, PVS-Studio, Coverity) — знаходять деякі помилки евристично, але не можуть гарантувати відсутність помилок
- **C++ Core Guidelines** — набір рекомендацій, але вони не перевіряються компілятором автоматично
- **Sanitizers** (AddressSanitizer, ThreadSanitizer) — знаходять помилки **під час виконання**, не компіляції, і тільки якщо тест покриває проблемний шлях

Все це — "латки" на мову, яка не була спроектована для безпеки пам'яті. Вони зменшують кількість помилок, але не усувають їх принципово.

### Різниця архітектурна, не інструментальна

Rust — це не "C++ з розумним компілятором". Це **мова, спроектована так, щоб компілятор міг перевіряти безпеку**. Ownership, lifetimes, borrowing — це не фічі компілятора, це **частина системи типів мови**.

Різниця як між:
- Будинком з охоронною сигналізацією (C++ + аналізатори) — сигналізація спрацює, коли злодій вже всередині
- Будинком, архітектурно спроектованим так, що в нього неможливо увійти без ключа (Rust) — злодій не може увійти в принципі

Rust обрав шлях "правильно з самого початку" замість "латаємо проблеми пізніше".

---

## Інструментарій Rust

Окрім безпеки мови, Rust надає один з найкращих наборів інструментів у світі програмування:

**Cargo** — менеджер пакетів та система збірки. Одна команда для компіляції, тестування, генерації документації, публікації бібліотеки. Залежності описуються декларативно і автоматично завантажуються.

**Компілятор** — відомий надзвичайно корисними повідомленнями про помилки. Не просто "помилка в рядку 42", а детальне пояснення проблеми з пропозицією виправлення.

**Clippy** — статичний аналізатор, що знаходить типові помилки та пропонує ідіоматичний код.

**Rustfmt** — автоматичне форматування коду за єдиним стандартом.

**Документація** — rustdoc генерує HTML документацію з коментарів у коді, включаючи приклади, які компілюються та тестуються.

---

## Про цю книгу

### Наскрізний проєкт

Ця книга побудована навколо **одного проєкту, що еволюціонує**: симуляції інтелектуального автономного рою БПЛА. Ви не будете писати десятки розрізнених прикладів — ви будете будувати одну систему від першого рядка до production-ready стану.

Агент починає як проста функція, стає структурою з методами, отримує машину станів, вчиться обробляти помилки, переходить у паралельні потоки, стає асинхронним актором, отримує BDI-архітектуру для прийняття рішень, і врешті — працює в рої з мережевою комунікацією та візуалізацією у браузері.

### Від нуля до production

Книга не вимагає попереднього досвіду з Rust. Частина 0 ("Bootcamp") дає все необхідне для старту. Але книга не зупиняється на "Hello, World" — вона веде вас до рівня, де ви зможете будувати реальні системи.

53 розділи, приблизно 200 годин матеріалу, від базового синтаксису до макросів, WebAssembly та розподілених систем.

### Структура

**Частина 0: Імперативний Rust (Bootcamp)** — базовий синтаксис без ускладнення моделлю пам'яті. На виході: агент, що патрулює сітку.

**Частина I: Агент як автономний об'єкт** — ownership, borrowing, структури, enum, модулі. Ключові концепції Rust через метафору агента.

**Частина II: Робастність, дані та інструментарій** — колекції, обробка помилок, traits, generics, серіалізація. Агент готовий до неідеального світу.

**Частина III: Smart Pointers та спільна пам'ять** — Box, Rc, RefCell, потоки, Arc, Mutex, канали. Локальний рій агентів.

**Частина IV: Асинхронність та масштабування** — async/await, Tokio, Actor Model, Rayon. Система масштабується до тисяч агентів.

**Частина V: Архітектури МАС та екосистема** — макроси, unsafe, ECS, BDI-агенти, мережева комунікація, WebAssembly. Фінальний проєкт.

---

## Для кого ця книга

- **Студенти** курсів штучного інтелекту, робототехніки, розподілених систем, які хочуть практичні навички на сучасній мові
- **Розробники на C/C++**, які шукають безпечнішу альтернативу без втрати продуктивності
- **Розробники на Python/Java/C#**, які хочуть зрозуміти системне програмування та отримати контроль над пам'яттю
- **Інженери**, що працюють з робототехнікою, IoT, вбудованими системами, де важливі надійність та передбачуваність
- **Усі, хто цікавиться** мультиагентними системами та хоче навчитися їх будувати

---

## Як читати цю книгу

1. **Послідовно**: Розділи побудовані один на одному. Агент еволюціонує, і кожна нова концепція Rust з'являється тоді, коли вона потрібна.

2. **Практично**: Кожен розділ має лабораторну роботу. Код потрібно писати, а не тільки читати.

3. **Терпляче**: Ownership та Borrow Checker спочатку здаються ворогами. Вони стануть друзями.

4. **Експериментуйте**: Компілятор — найкращий вчитель. Навмисно робіть помилки, читайте повідомлення, виправляйте.

---

## Подяки

*[Місце для подяк авторам, рецензентам, спільноті]*

---

## Домовленості

У книзі використовуються такі позначення:

- `код` — для імен змінних, функцій, типів у тексті
- **Жирний** — для ключових термінів при першому введенні
- *Курсив* — для акцентування
- Блоки коду — для прикладів програм з поясненнями

Терміни подаються українською, з англійським відповідником у дужках при першому вживанні, якщо англійський термін загальновживаний (наприклад, "володіння (ownership)").

---

*Вирушаймо в подорож. Нехай компілятор буде вашим провідником.*

---

> **Далі:** [Розділ 1: Налаштування середовища та перший проєкт](./01_Setup.md)
