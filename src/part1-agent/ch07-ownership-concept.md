# Розділ 7: Ownership — Концепція володіння

---

## 📋 Анотація

Ласкаво просимо до найважливішого розділу у вивченні Rust! **Ownership** (володіння) — це унікальна система керування пам'яттю, яка робить Rust особливим серед усіх мов програмування. Замість збирача сміття (як у Java, Python, Go) або ручного керування (як у C/C++), Rust використовує набір правил, що перевіряються на етапі компіляції.

У цьому розділі ви зрозумієте філософію ownership через метафору автономного агента: агент володіє своїми ресурсами — батареєю, сенсорами, даними місії. Якщо агент "віддає" ресурс іншому, він більше не може ним користуватись.

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Пояснити** три правила ownership своїми словами
2. **Розуміти** move semantics — чому значення переміщуються
3. **Розрізняти** Copy та Move типи
4. **Передбачати**, коли значення буде автоматично звільнено (drop)

---

## 📚 Ключові терміни

| Термін | Визначення |
|--------|------------|
| **ownership** | Система правил, що визначає, хто відповідає за пам'ять |
| **owner** | Змінна, що володіє значенням |
| **move** | Передача володіння від однієї змінної до іншої |
| **drop** | Автоматичне звільнення ресурсів при виході зі scope |
| **scope** | Блок коду `{ }`, де змінна існує |
| **Copy** | Trait для типів, що копіюються автоматично |
| **Clone** | Метод для явного глибокого копіювання |

---

## 💡 Мотиваційний кейс: Чому це важливо

### Проблема 1: Хто відповідальний за пам'ять?

Уявіть систему керування дронами. Кожен дрон має план місії — список waypoints, координати, параметри. План зберігається в пам'яті.

**У C/C++:** Програміст сам вирішує, коли звільнити пам'ять. Це призводить до помилок:

```rust
Функція create_plan() створює план в пам'яті
Функція повертає вказівник на цей план
...хто звільнить пам'ять? Коли?

Варіант A: Ніхто не звільняє → Memory leak (витік пам'яті)
Варіант B: Звільняємо двічі → Double free (краш програми)
Варіант C: Використовуємо після звільнення → Use-after-free (вразливість безпеки)
```

**У Java/Python:** Збирач сміття автоматично звільняє пам'ять. Але:
- Непередбачуваний час роботи
- Додаткове навантаження (10-30% CPU)
- Непридатний для систем реального часу (дрони!)

### Проблема 2: Хто може змінювати дані?

```text
Дрон A читає waypoint 3 з плану
Дрон B видаляє waypoint 3 з плану (він виконаний)
Дрон A намагається летіти до waypoint 3... куди?
```

Це **data race** — два потоки одночасно працюють з одними даними. У C++ це призводить до непередбачуваної поведінки.

### Рішення Rust: Ownership

```text
✓ Один власник плану в кожен момент часу
✓ Коли власник зникає — план автоматично звільняється
✓ Передача плану = передача володіння (старий власник втрачає доступ)
✓ Компілятор перевіряє всі правила ДО запуску програми
```

**Результат:** Жодних runtime-помилок пам'яті. Жодних збирачів сміття. Жодних витоків.

---

## 7.1 СТЕК ТА HEAP: ДЕ ЖИВУТЬ ДАНІ

### 7.1.1 Що таке стек

Перш ніж розбиратись з ownership, потрібно зрозуміти, де фізично зберігаються дані в програмі.

**Стек (Stack)** — це область пам'яті для локальних змінних функцій. Назва походить від структури даних "стек" (стопка) — останній прийшов, перший пішов (LIFO).

Коли ви викликаєте функцію, на стеку створюється "кадр" (frame) для її локальних змінних. Коли функція завершується, кадр зникає.

```text
┌─────────────────────────────────────────┐
│              СТЕК                       │
├─────────────────────────────────────────┤
│  ┌─────────────────────────────────┐   │
│  │ fn inner()                      │   │  ← Верхівка стеку
│  │   let z: i32 = 30    [4 байти]  │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │ fn outer()                      │   │
│  │   let y: i32 = 20    [4 байти]  │   │
│  └─────────────────────────────────┘   │
│  ┌─────────────────────────────────┐   │
│  │ fn main()                       │   │
│  │   let x: i32 = 10    [4 байти]  │   │
│  └─────────────────────────────────┘   │
│  ═══════════════════════════════════   │  ← Дно стеку
└─────────────────────────────────────────┘
```

**Характеристики стеку:**

| Властивість | Значення |
|-------------|----------|
| Швидкість | Дуже швидкий — просто зсув вказівника |
| Розмір даних | Має бути відомий при компіляції |
| Звільнення | Автоматичне при виході з функції |
| Загальний розмір | Обмежений (~1-8 МБ) |

**Що живе на стеку:**
- Примітиви: `i32`, `f64`, `bool`, `char`
- Масиви фіксованого розміру: `[i32; 10]`
- Кортежі: `(i32, f64, bool)`

### 7.1.2 Що таке heap

**Heap (купа)** — це область пам'яті для динамічних даних. Розмір може змінюватись під час виконання програми.

```text
┌─────────────────────────────────────────┐
│              HEAP                       │
├─────────────────────────────────────────┤
│  ┌───────────────────┐                  │
│  │ "Hello, World!"   │ ← String дані    │
│  └───────────────────┘                  │
│                                         │
│  ┌───────────────────────────────────┐  │
│  │ [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]   │  │ ← Vec дані
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
```

**Характеристики heap:**

| Властивість | Значення |
|-------------|----------|
| Швидкість | Повільніший — потрібен пошук вільного місця |
| Розмір даних | Може змінюватись під час виконання |
| Звільнення | Потребує явного або автоматичного керування |
| Загальний розмір | Великий (обмежений лише RAM) |

**Що живе на heap:**
- `String` — рядки змінної довжини
- `Vec<T>` — вектори (динамічні масиви)
- `Box<T>` — явне виділення на heap

### 7.1.3 Як влаштований String

`String` — це ключовий тип для розуміння ownership. Подивимось, як він зберігається в пам'яті.

**Коли ви створюєте String:**

```rust
let s = String::from("Hello");
```

**В пам'яті це виглядає так:**

```text
СТЕК                          HEAP
┌─────────────────┐           ┌─────────────────┐
│ s: String       │           │                 │
│ ┌─────────────┐ │           │ H e l l o       │
│ │ ptr ────────┼─┼───────────┼─►               │
│ │ len: 5      │ │           │                 │
│ │ capacity: 5 │ │           └─────────────────┘
│ └─────────────┘ │
└─────────────────┘
```

**На стеку зберігається структура з трьох полів:**
- `ptr` — вказівник на дані в heap
- `len` — поточна довжина рядка (5 символів)
- `capacity` — скільки пам'яті виділено (може бути більше len)

**На heap зберігаються самі символи** "Hello".

**Коли `s` виходить зі scope, Rust автоматично:**
1. Звільняє пам'ять на heap (5 байт для "Hello")
2. Прибирає структуру зі стеку

Це і є "drop" — автоматичне звільнення ресурсів.

---

## 7.2 ТРИ ПРАВИЛА OWNERSHIP

Ось серце системи ownership — три прості, але потужні правила.

### Правило 1: Кожне значення має єдиного власника

У кожен момент часу значення має **рівно одного** власника — не двох, не нуль, а одного.

```rust
let s = String::from("Hello");
//  ↑
//  s є власником цього String
```

Змінна `s` володіє рядком "Hello". Вона відповідальна за його звільнення.

### Правило 2: Коли власник виходить зі scope, значення звільняється

```rust
{
    let s = String::from("Hello");
    // s існує тут
    // можемо використовувати s
}  // ← s виходить зі scope
   // Rust автоматично викликає drop
   // Пам'ять звільняється
```

Це називається **RAII** (Resource Acquisition Is Initialization) — ресурс звільняється, коли змінна-власник зникає.

### Правило 3: Володіння можна передати (move)

```rust
let s1 = String::from("Hello");
let s2 = s1;  // Володіння ПЕРЕДАНО від s1 до s2
// s1 більше НЕ валідна!
// s2 тепер єдиний власник
```

Після `let s2 = s1`, змінна `s1` стає "пустою" — вона більше не володіє нічим і не може використовуватись.

---

## 7.3 MOVE SEMANTICS: ДЕТАЛЬНИЙ РОЗБІР

### 7.3.1 Що таке move і навіщо він потрібен

**Проблема:** Уявіть, що при `let s2 = s1` ми просто копіюємо структуру на стеку:

```text
СТЕК                          HEAP
┌─────────────────┐
│ s1:             │           ┌─────────────────┐
│   ptr ──────────┼───────────┼─► "Hello"       │
│   len: 5        │           │                 │
└─────────────────┘           │                 │
┌─────────────────┐           │                 │
│ s2:             │           │                 │
│   ptr ──────────┼───────────┼─►               │
│   len: 5        │           └─────────────────┘
└─────────────────┘
```

Тепер `s1` і `s2` вказують на **одні й ті самі дані**! Що станеться, коли обидві змінні вийдуть зі scope?

1. `s2` виходить зі scope → Rust звільняє "Hello"
2. `s1` виходить зі scope → Rust намагається звільнити "Hello" ще раз!

Це **double free** — серйозна помилка пам'яті, яка може призвести до крашу або вразливості безпеки.

**Рішення Rust: Move**

Замість копіювання Rust **переміщує** володіння. Після `let s2 = s1`:

```text
СТЕК                          HEAP
┌─────────────────┐
│ s1: (невалідна) │           ┌─────────────────┐
│                 │           │ "Hello"         │
└─────────────────┘           └─────────────────┘
┌─────────────────┐                   ↑
│ s2:             │                   │
│   ptr ──────────┼───────────────────┘
│   len: 5        │
└─────────────────┘
```

`s1` стає невалідною. Тільки `s2` володіє даними. Подвійного звільнення не буде.

### 7.3.2 Демонстрація move при присвоєнні

**Постановка задачі:** Покажемо, що відбувається при присвоєнні String від однієї змінної до іншої. Ми хочемо побачити, що оригінальна змінна стає недоступною після move.

```rust
fn main() {
    // Крок 1: Створюємо String
    // s1 стає власником рядка "Patrol mission Alpha"
    let s1 = String::from("Patrol mission Alpha");
    
    // Крок 2: Використовуємо s1 — все працює
    println!("s1 містить: {}", s1);
    
    // Крок 3: Присвоюємо s1 до s2 — відбувається MOVE
    // Володіння переходить від s1 до s2
    let s2 = s1;
    
    // Крок 4: s2 тепер власник — можемо використовувати
    println!("s2 містить: {}", s2);
    
    // Крок 5: s1 більше не валідна!
    // Якщо розкоментувати наступний рядок — помилка компіляції
    // println!("s1 містить: {}", s1);  // error: value borrowed after move
}
```

**Як працює цей код:**

1. **Рядок 4:** `String::from("Patrol mission Alpha")` створює новий String на heap. Змінна `s1` стає власником.

2. **Рядок 7:** Виводимо `s1` — все працює, бо `s1` все ще володіє значенням.

3. **Рядок 11:** `let s2 = s1` — це **move**. Rust копіює структуру (ptr, len, capacity) зі стеку, але `s1` позначається як "переміщена". Дані на heap залишаються на місці.

4. **Рядок 14:** `s2` тепер володіє рядком — можемо його використовувати.

5. **Рядок 18:** Спроба використати `s1` призведе до помилки компіляції. Rust не дозволить.

**Результат виконання:**
```text
s1 містить: Patrol mission Alpha
s2 містить: Patrol mission Alpha
```

### 7.3.3 Демонстрація move при передачі у функцію

**Постановка задачі:** Передача значення у функцію також спричиняє move. Після виклику функції оригінальна змінна стає недоступною. Покажемо це на прикладі.

```rust
fn main() {
    // Створюємо місію
    let mission = String::from("Reconnaissance");
    println!("1. Місія створена: {}", mission);
    
    // Передаємо місію у функцію — відбувається MOVE
    // mission більше не наша!
    execute_mission(mission);
    
    // mission тепер невалідна
    // println!("3. Після виконання: {}", mission);  // ПОМИЛКА!
    
    println!("3. Функція завершилась, mission знищена");
}

/// Функція приймає String за значенням — отримує володіння.
/// Коли функція завершується, plan автоматично звільняється (drop).
fn execute_mission(plan: String) {
    println!("2. Виконуємо місію: {}", plan);
    // plan drop'ається тут, в кінці функції
}
```

**Як працює цей код:**

1. **Рядок 3:** Створюємо `mission` — вона володіє рядком "Reconnaissance".

2. **Рядок 8:** Викликаємо `execute_mission(mission)`. Це **move** — володіння переходить до параметра `plan` всередині функції.

3. **Рядок 19:** Функція використовує `plan` — виводить його.

4. **Кінець функції:** `plan` виходить зі scope → Rust викликає drop → пам'ять звільняється.

5. **Рядок 11:** Назад у `main`, змінна `mission` вже невалідна — вона "віддала" своє значення функції.

**Результат виконання:**
```text
1. Місія створена: Reconnaissance
2. Виконуємо місію: Reconnaissance
3. Функція завершилась, mission знищена
```

**Важливий інсайт:** Передача у функцію = присвоєння параметру. `execute_mission(mission)` концептуально еквівалентне `let plan = mission` всередині функції.

### 7.3.4 Повернення володіння з функції

**Постановка задачі:** Функція може не тільки приймати володіння, але й повертати його назад. Це дозволяє "позичити" значення функції, а потім отримати його назад.

```rust
fn main() {
    // Крок 1: Створюємо місію
    let mission = String::from("Patrol");
    println!("1. Створено: {}", mission);
    
    // Крок 2: Передаємо у функцію і отримуємо назад (можливо модифіковану)
    // mission -> функція -> нова mission
    let mission = process_and_return(mission);
    println!("3. Отримано назад: {}", mission);
    
    // Крок 3: mission знову валідна — можемо використовувати
    println!("4. Все ще доступна: {}", mission);
}

/// Функція приймає String, модифікує і повертає володіння назад.
fn process_and_return(mut plan: String) -> String {
    // Додаємо текст до рядка
    plan.push_str(" - COMPLETED");
    println!("2. Оброблено: {}", plan);
    
    // Повертаємо String — володіння передається викликаючому коду
    plan
}
```

**Як працює цей код:**

1. **Рядок 3:** Створюємо `mission` з "Patrol".

2. **Рядок 8:** Викликаємо `process_and_return(mission)`:
   - `mission` переміщується у параметр `plan`
   - Функція модифікує `plan` (додає " - COMPLETED")
   - Функція повертає `plan` — володіння передається назовні
   - Ми присвоюємо результат знову до `mission`

3. **Рядок 9-12:** `mission` знову валідна, бо отримала володіння з функції.

**Результат виконання:**
```text
1. Створено: Patrol
2. Оброблено: Patrol - COMPLETED
3. Отримано назад: Patrol - COMPLETED
4. Все ще доступна: Patrol - COMPLETED
```

**Зверніть увагу:** Ми перевикористали ім'я `mission` через shadowing. Це ідіоматичний Rust — якщо логічно це "та сама" місія, можна залишити те саме ім'я.

---

## 7.4 COPY VS MOVE: ДВА ТИПИ ПОВЕДІНКИ

### 7.4.1 Чому примітиви поводяться інакше

**Спостереження:** З числами move не відбувається:

```rust
let x = 42;
let y = x;
println!("x = {}", x);  // OK! x все ще валідна
println!("y = {}", y);  // y = 42
```

**Чому?** Тому що `i32` — це **Copy** тип.

### 7.4.2 Що таке Copy

**Copy** — це спеціальний trait (інтерфейс), який позначає типи, що можна безпечно копіювати побітово.

Для Copy типів при присвоєнні `let y = x` відбувається **копіювання**, а не переміщення. Обидві змінні залишаються валідними.

**Які типи є Copy:**

| Тип | Чому Copy |
|-----|-----------|
| `i8`, `i16`, `i32`, `i64`, `i128` | Прості числа, повністю на стеку |
| `u8`, `u16`, `u32`, `u64`, `u128` | Прості числа |
| `f32`, `f64` | Прості числа |
| `bool` | 1 байт |
| `char` | 4 байти |
| `(i32, i32)` | Кортеж з Copy елементів |
| `[i32; 5]` | Масив з Copy елементів |

**Які типи НЕ Copy (тобто Move):**

| Тип | Чому НЕ Copy |
|-----|--------------|
| `String` | Володіє даними на heap |
| `Vec<T>` | Володіє даними на heap |
| `Box<T>` | Володіє даними на heap |

### 7.4.3 Чому String не може бути Copy

**Уявімо, що String був би Copy:**

```rust
При let s2 = s1 для String:

СТЕК                          HEAP
s1: [ptr, len, cap] ────────► "Hello"
                                ↑
s2: [ptr, len, cap] ────────────┘  (копія вказівника)
```

Обидві змінні вказують на ТІ САМІ дані! Це призведе до double free.

**Тому String є Move:** При присвоєнні s1 інвалідується, тільки s2 володіє даними.

**А для i32:**

```rust
СТЕК
x: [42]        (4 байти)
y: [42]        (4 байти, незалежна копія)
```

Дані повністю на стеку, копіювання дешеве, незалежні копії. Жодних проблем!

### 7.4.4 Демонстрація Copy типів

**Постановка задачі:** Покажемо, що Copy типи (числа, кортежі з чисел) можна вільно присвоювати і передавати — оригінал залишається доступним.

```rust
fn main() {
    println!("=== Демонстрація Copy типів ===\n");
    
    // --- Числа: Copy ---
    let battery_level: u8 = 85;
    let backup_level = battery_level;  // КОПІЮВАННЯ, не move
    
    // Обидві змінні валідні!
    println!("Поточний рівень батареї: {}%", battery_level);
    println!("Резервна копія: {}%", backup_level);
    
    // --- Кортежі з чисел: теж Copy ---
    let position: (i32, i32) = (100, 200);
    let saved_position = position;  // КОПІЮВАННЯ
    
    // Обидві валідні!
    println!("Поточна позиція: {:?}", position);
    println!("Збережена позиція: {:?}", saved_position);
    
    // --- Передача у функцію: теж копіювання ---
    print_coordinates(position);
    
    // position все ще доступна після виклику!
    println!("Після функції: {:?}", position);
}

fn print_coordinates(pos: (i32, i32)) {
    println!("Координати: ({}, {})", pos.0, pos.1);
}
```

**Як працює цей код:**

1. **Рядки 6-10:** Присвоюємо `battery_level` до `backup_level`. Оскільки `u8` — Copy, відбувається копіювання. Обидві змінні мають власні незалежні копії числа 85.

2. **Рядки 13-18:** Те саме з кортежем. `(i32, i32)` — Copy (бо обидва елементи Copy). Копіюється весь кортеж.

3. **Рядки 21-24:** Передаємо `position` у функцію. Для Copy типів передача — це копіювання. Оригінал залишається.

**Результат виконання:**
```rust
=== Демонстрація Copy типів ===

Поточний рівень батареї: 85%
Резервна копія: 85%
Поточна позиція: (100, 200)
Збережена позиція: (100, 200)
Координати: (100, 200)
Після функції: (100, 200)
```

### 7.4.5 Clone: явне глибоке копіювання

**Постановка задачі:** Іноді нам ПОТРІБНА справжня копія String або Vec. Для цього існує метод `.clone()`, який робить глибоку копію — виділяє нову пам'ять на heap і копіює дані.

```rust
fn main() {
    println!("=== Демонстрація Clone ===\n");
    
    let original_mission = String::from("Patrol perimeter");
    
    // .clone() створює повну незалежну копію
    let backup_mission = original_mission.clone();
    
    // Тепер є ДВА рядки в пам'яті!
    // original_mission → "Patrol perimeter" (heap область 1)
    // backup_mission   → "Patrol perimeter" (heap область 2)
    
    // Обидва валідні та незалежні
    println!("Оригінал: {}", original_mission);
    println!("Копія: {}", backup_mission);
    
    // Можемо передати один, інший залишиться
    execute(original_mission);  // original_mission moved
    
    // backup_mission все ще наша!
    println!("Backup все ще доступний: {}", backup_mission);
}

fn execute(plan: String) {
    println!("Виконуємо: {}", plan);
}
```

**Як працює цей код:**

1. **Рядок 4:** Створюємо `original_mission` — вона володіє рядком на heap.

2. **Рядок 7:** `.clone()` робить повну копію:
   - Виділяє нову пам'ять на heap
   - Копіює всі байти "Patrol perimeter"
   - Повертає новий String, що володіє цією копією

3. **Після clone:** Маємо два незалежних String, кожен володіє своєю копією даних.

4. **Рядок 18:** Передаємо `original_mission` у функцію — вона переміщується і знищується.

5. **Рядок 21:** `backup_mission` не залежить від original — вона все ще валідна.

**Результат виконання:**
```text
=== Демонстрація Clone ===

Оригінал: Patrol perimeter
Копія: Patrol perimeter
Виконуємо: Patrol perimeter
Backup все ще доступний: Patrol perimeter
```

**Застереження:** `.clone()` може бути дорогим для великих даних. Якщо рядок має 1 МБ, clone скопіює весь мегабайт. Використовуйте обережно!

---

## 7.5 SCOPE ТА DROP

### 7.5.1 Що таке scope

**Scope** (область видимості) — це блок коду `{ }`, в якому змінна існує та доступна.

```rust
fn main() {             // Scope main починається
    let x = 5;          // x існує з цього моменту
    
    {                   // Вкладений scope починається
        let y = 10;     // y існує з цього моменту
        println!("{} {}", x, y);  // Обидві доступні
    }                   // Вкладений scope закінчується, y DROP
    
    println!("{}", x);  // x доступна
    // println!("{}", y);  // ПОМИЛКА! y вже не існує
    
}                       // main scope закінчується, x DROP
```

### 7.5.2 Коли викликається drop

**Drop** викликається автоматично, коли змінна-власник виходить зі scope. Порядок — **зворотний** до порядку створення (LIFO).

**Постановка задачі:** Покажемо порядок виклику drop для кількох змінних та вкладених scope.

```rust
fn main() {
    println!("=== Scope та Drop ===\n");
    
    println!("1. Входимо в main");
    
    // Створюємо першу змінну
    let commander = String::from("COMMAND-001");
    println!("2. Commander створено: {}", commander);
    
    // Вкладений scope
    {
        println!("3. Входимо у вкладений scope");
        
        let scout = String::from("SCOUT-001");
        println!("4. Scout створено: {}", scout);
        
        let support = String::from("SUPPORT-001");
        println!("5. Support створено: {}", support);
        
        println!("6. Виходимо з вкладеного scope");
        // support DROP (останній створений — перший звільнений)
        // scout DROP
    }
    println!("7. Вкладений scope завершено, scout і support знищені");
    
    // commander все ще існує
    println!("8. Commander все ще доступний: {}", commander);
    
    println!("9. Виходимо з main");
    // commander DROP
}
```

**Як працює цей код:**

1. **Рядок 7:** Створюємо `commander` — перша змінна в main.

2. **Рядки 11-22:** Вкладений scope:
   - Створюємо `scout` (рядок 14)
   - Створюємо `support` (рядок 17)
   - На рядку 22 (закриваюча дужка) обидві змінні виходять зі scope
   - Drop викликається у **зворотному** порядку: спочатку `support`, потім `scout`

3. **Рядок 27:** `commander` все ще існує, бо його scope (main) ще не завершився.

4. **Рядок 30:** Закриваюча дужка main — `commander` drop.

**Результат виконання:**
```text
=== Scope та Drop ===

1. Входимо в main
2. Commander створено: COMMAND-001
3. Входимо у вкладений scope
4. Scout створено: SCOUT-001
5. Support створено: SUPPORT-001
6. Виходимо з вкладеного scope
7. Вкладений scope завершено, scout і support знищені
8. Commander все ще доступний: COMMAND-001
9. Виходимо з main
```

### 7.5.3 Drop не викликається для переміщених значень

**Важливе правило:** Якщо значення було переміщено (move), drop НЕ викликається для старого власника.

```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = s1;  // s1 переміщено
    
}  // Тільки s2.drop() викликається
   // s1 "пуста" — drop не потрібен
```

Rust відстежує, які змінні "живі", а які "порожні" після move.

---

## 7.6 МЕТАФОРА АГЕНТА-ВЛАСНИКА

Щоб краще запам'ятати ownership, уявіть агента БПЛА як власника ресурсів.

### 7.6.1 Агент володіє ресурсами

```text
┌─────────────────────────────────────────────────────────────┐
│                     АГЕНТ "SCOUT-001"                       │
├─────────────────────────────────────────────────────────────┤
│   Володіє:                                                  │
│   ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│   │  Батарея    │  │  Сенсори    │  │ План місії  │        │
│   │  (String)   │  │  (Vec)      │  │ (String)    │        │
│   └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

В коді:
```rust
let battery = String::from("LiPo 6S 5000mAh");
let mission = String::from("Patrol Zone Alpha");
// Агент "володіє" цими ресурсами
```

### 7.6.2 Передача ресурсу = втрата володіння

Якщо SCOUT-001 передає батарею SCOUT-002:

```text
ДО:
SCOUT-001: володіє [Батарея]
SCOUT-002: володіє []

ПІСЛЯ:
SCOUT-001: володіє []         (втратив батарею!)
SCOUT-002: володіє [Батарея]  (отримав батарею)
```

В коді:
```rust
let scout1_battery = String::from("LiPo 6S");
let scout2_battery = scout1_battery;  // MOVE!
// scout1_battery більше не існує
```

### 7.6.3 Чому це добре

1. **Немає конфліктів:** Тільки один агент може модифікувати план місії
2. **Немає витоків:** Коли агент "гине", всі його ресурси автоматично звільняються
3. **Передбачуваність:** Завжди зрозуміло, хто за що відповідає

---

## 7.7 ПРАКТИЧНІ ВПРАВИ

### Вправа 1: Передбачте результат

**Завдання:** Визначте, що виведе програма, або яку помилку видасть компілятор.

```rust
fn main() {
    let a = String::from("Alpha");
    let b = a;
    let c = b;
    println!("{}", c);
}
```

<details>
<summary>Відповідь</summary>

Виведе: `Alpha`

Пояснення: `a` → `b` (move), `b` → `c` (move). В кінці тільки `c` валідна.
</details>

### Вправа 2: Виправте код

**Завдання:** Код не компілюється. Виправте його, не видаляючи жодного `println!`.

```rust
fn main() {
    let mission = String::from("Patrol");
    execute(mission);
    println!("Mission was: {}", mission);
}

fn execute(m: String) {
    println!("Executing: {}", m);
}
```

<details>
<summary>Відповідь</summary>

Варіант 1 — Clone:
```rust
let mission = String::from("Patrol");
execute(mission.clone());
println!("Mission was: {}", mission);
```

Варіант 2 — Повернути володіння:
```rust
let mission = String::from("Patrol");
let mission = execute(mission);
println!("Mission was: {}", mission);

fn execute(m: String) -> String {
    println!("Executing: {}", m);
    m
}
```
</details>

---

## 7.8 ЛАБОРАТОРНА РОБОТА

### Завдання

Створіть програму, що демонструє всі аспекти ownership:

1. Створіть String і покажіть move при присвоєнні
2. Створіть функцію, що приймає String і знищує її
3. Створіть функцію, що приймає і повертає String
4. Покажіть різницю між Copy (числа) та Move (String)
5. Використайте clone для створення копії

### Критерії оцінювання

| Критерій | Бали |
|----------|------|
| Move при присвоєнні | 2 |
| Move у функцію | 2 |
| Повернення володіння | 2 |
| Copy vs Move | 2 |
| Clone | 2 |
| **Максимум** | **10** |

---

## 📝 РЕЗЮМЕ

### Три правила Ownership

1. **Кожне значення має єдиного власника**
2. **Коли власник виходить зі scope — значення звільняється (drop)**
3. **Володіння можна передати (move)**

### Copy vs Move

| Тип | Поведінка | Оригінал після присвоєння |
|-----|-----------|---------------------------|
| `i32`, `bool`, `f64` | Copy | Валідний |
| `String`, `Vec<T>` | Move | Невалідний |

### Ключові інсайти

- Ownership — це **compile-time** система, жодних runtime-витрат
- Move НЕ копіює дані на heap — тільки структуру на стеку
- Clone — явна глибока копія, може бути дорогою
- Drop викликається автоматично у зворотному порядку створення

---

## 🔗 ЗВ'ЯЗОК З НАСТУПНИМ РОЗДІЛОМ

Ownership дає гарантії безпеки, але здається обмежувальним. Як передати значення у функцію і продовжити ним користуватись? Відповідь — **Borrowing** (позичання).

У **Розділі 8** ви вивчите практичні помилки компілятора та як їх виправляти.

У **Розділі 9** — як "позичати" значення через посилання `&T`.

---

> **Наступний розділ:** [Розділ 8: Ownership — Практика помилок компілятора](./08_Ownership_praktyka.md)
