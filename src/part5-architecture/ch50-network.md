# Розділ 50: Мережева комунікація агентів

---

## 📋 Анотація

До цього моменту наші агенти працювали на одній машині — спілкувались через канали в пам'яті, ділили `Arc<RwLock<World>>`, використовували локальні actors. Але справжній рій БПЛА — це **розподілена система**: кожен дрон це окремий комп'ютер з власним процесором, пам'яттю та операційною системою, а зв'язок відбувається через радіоканал або мережу.

Мережева комунікація кардинально відрізняється від локальної. З'являються нові виклики: **затримки** (latency) від мілісекунд до секунд, **втрати пакетів** (packet loss) до 10-20%, **обмежена пропускна здатність** (bandwidth), **відмови вузлів** (node failures), **network partitions** коли частина рою втрачає зв'язок з іншою.

Цей розділ охоплює фундаментальну теорію мережевих протоколів, класичні проблеми розподілених систем, та практичну реалізацію мережевої комунікації агентів на Rust з використанням tokio::net.

---

## 🎯 Цілі навчання

Після завершення цього розділу ви зможете:

1. **Пояснити** фундаментальну різницю між TCP та UDP
2. **Описати** CAP-теорему та її наслідки для рою агентів
3. **Порівняти** топології мережі рою (зірка, mesh, ієрархія)
4. **Реалізувати** базову TCP/UDP комунікацію на tokio
5. **Спроектувати** протокол повідомлень для рою агентів
6. **Застосувати** механізми discovery та heartbeat

---

## 📚 Ключові терміни

| Термін | Визначення |
|--------|------------|
| **TCP** | Transmission Control Protocol — надійний, впорядкований потік |
| **UDP** | User Datagram Protocol — ненадійні, швидкі датаграми |
| **Latency** | Затримка передачі пакета від відправника до отримувача |
| **Bandwidth** | Пропускна здатність каналу (біт/секунду) |
| **Packet loss** | Відсоток втрачених пакетів |
| **Heartbeat** | Періодичне повідомлення "я живий" |
| **Discovery** | Процес автоматичного знаходження інших агентів |
| **Serialization** | Перетворення структур даних у байти для передачі |
| **Network partition** | Розділення мережі, коли частина вузлів не може зв'язатись |

---

## 💡 Мотиваційний кейс: Рій над океаном

Уявімо рій з 20 БПЛА, що виконує розвідку над океаном:

**Фізичні умови:**
- Відстань між дронами: 1-10 км
- Зв'язок: радіо 900 МГц
- Пропускна здатність: 100 кбіт/с на канал
- Затримка: 10-100 мс (змінна)
- Втрати пакетів: 5-15% (погіршується при відстані)

**Комунікаційні потреби:**
- Кожен дрон повідомляє позицію 10 разів на секунду
- Команди від лідера мають бути гарантовано доставлені
- При виявленні цілі — негайне оповіщення всього рою
- Якщо дрон втрачає зв'язок — інші мають дізнатись за секунди
- Рій має продовжувати роботу при втраті зв'язку з базою

Це **реальні умови** для морських, рятувальних та військових операцій. Проста відправка повідомлень по мережі недостатня — потрібна продумана архітектура.

---

## 50.1 ОСНОВИ МЕРЕЖЕВОЇ КОМУНІКАЦІЇ

### 50.1.1 Модель OSI та місце наших протоколів

Мережева комунікація організована в шари. Модель OSI (Open Systems Interconnection) визначає 7 рівнів:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    МОДЕЛЬ OSI                                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  РІВЕНЬ 7: Application (Прикладний)                                │
│  └── HTTP, WebSocket, MQTT, **ваш протокол агентів**               │
│                                                                     │
│  РІВЕНЬ 6: Presentation (Представлення)                            │
│  └── SSL/TLS, **серіалізація (JSON, Bincode)**                     │
│                                                                     │
│  РІВЕНЬ 5: Session (Сесійний)                                      │
│  └── Сесії, логічні з'єднання                                      │
│                                                                     │
│  РІВЕНЬ 4: Transport (Транспортний)     ← НАША ТОЧКА ВИБОРУ       │
│  └── **TCP, UDP**                                                  │
│                                                                     │
│  РІВЕНЬ 3: Network (Мережевий)                                     │
│  └── IP, маршрутизація                                             │
│                                                                     │
│  РІВЕНЬ 2: Data Link (Канальний)                                   │
│  └── Ethernet, WiFi, 802.15.4                                      │
│                                                                     │
│  РІВЕНЬ 1: Physical (Фізичний)                                     │
│  └── Кабелі, радіохвилі, оптика                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

Для агентів ми працюємо на рівнях **4-7**:
- **Transport (4)**: обираємо TCP або UDP
- **Presentation (6)**: обираємо формат серіалізації
- **Application (7)**: проектуємо протокол повідомлень агентів

### 50.1.2 TCP: надійність за рахунок швидкості

**TCP (Transmission Control Protocol)** — протокол, що гарантує надійну, впорядковану доставку даних.

**Як працює TCP:**

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    TCP: ТРЬОХЕТАПНЕ РУКОСТИСКАННЯ                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  КЛІЄНТ                              СЕРВЕР                         │
│     │                                   │                           │
│     │─────── SYN (seq=100) ────────────►│  "Хочу з'єднатись"       │
│     │                                   │                           │
│     │◄────── SYN-ACK (seq=300,          │  "Готовий, підтверджую"  │
│     │        ack=101) ──────────────────│                           │
│     │                                   │                           │
│     │─────── ACK (ack=301) ────────────►│  "Підтверджую"           │
│     │                                   │                           │
│     │◄══════ НАДІЙНИЙ ПОТІК ═══════════►│  З'єднання встановлено   │
│     │                                   │                           │
└─────────────────────────────────────────────────────────────────────┘
```

**Гарантії TCP:**
1. **Доставка**: кожен пакет підтверджується (ACK), втрачені — повторюються
2. **Порядок**: пакети нумеруються, отримувач збирає в правильному порядку
3. **Контроль потоку**: відправник не перевантажує отримувача
4. **Контроль перевантаження**: адаптація до стану мережі

**Недоліки TCP:**
1. **Затримка з'єднання**: 3 пакети тільки на handshake (1.5 RTT)
2. **Head-of-line blocking**: один втрачений пакет блокує всю чергу
3. **Overhead**: заголовок 20+ байт, ACK на кожен пакет
4. **Не підходить для broadcast**: TCP — point-to-point

### 50.1.3 UDP: швидкість за рахунок надійності

**UDP (User Datagram Protocol)** — простий протокол "fire and forget".

**Як працює UDP:**

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    UDP: ДАТАГРАМИ                                    │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ВІДПРАВНИК                          ОТРИМУВАЧ                      │
│     │                                   │                           │
│     │─────── Датаграма 1 ──────────────►│  Може дійти              │
│     │                                   │                           │
│     │─────── Датаграма 2 ────────── X   │  Може загубитись         │
│     │                                   │                           │
│     │─────── Датаграма 3 ──────────────►│  Може дійти              │
│     │                                   │                           │
│     │─────── Датаграма 4 ──────────────►│  Може дійти раніше за 3  │
│     │                                   │                           │
│  Немає підтверджень!                    Немає гарантій порядку!    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Характеристики UDP:**
1. **Без з'єднання**: просто відправляємо, без handshake
2. **Без гарантій**: пакет може загубитись, дублюватись, прийти не в порядку
3. **Мінімальний overhead**: заголовок лише 8 байт
4. **Підтримує broadcast/multicast**: один пакет багатьом отримувачам

**Переваги UDP:**
- Мінімальна затримка (немає handshake)
- Немає head-of-line blocking
- Ефективний для частих невеликих повідомлень
- Підходить для real-time даних (втрата краще за затримку)

### 50.1.4 TCP vs UDP: таблиця вибору

| Тип повідомлення | Протокол | Причина |
|------------------|----------|---------|
| Команди (StartMission, Abort) | **TCP** | Має бути гарантовано доставлено |
| Конфігурація, параметри | **TCP** | Цілісність критична |
| Позиція агента (10 Гц) | **UDP** | Часті оновлення, старі неактуальні |
| Heartbeat | **UDP** | Втрата одного — не критична |
| Дані сенсорів (відео) | **UDP** | Real-time важливіше повноти |
| Критичний алерт | **TCP** або Reliable UDP | Має дійти гарантовано |

### 50.1.5 Гібридний підхід

Більшість реальних систем використовують **обидва протоколи** одночасно:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    ГІБРИДНА КОМУНІКАЦІЯ                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  АГЕНТ A                                                АГЕНТ B     │
│     │                                                      │        │
│     │═══════════════ TCP З'ЄДНАННЯ ══════════════════════│        │
│     │  • Команди: StartMission, Abort, Reroute            │        │
│     │  • Конфігурація: UpdateParams, SetWaypoints         │        │
│     │  • Критичні алерти: EnemyDetected, Emergency        │        │
│     │  • Файли: MapData, MissionPlan                      │        │
│     │                                                      │        │
│     │─────────────── UDP ДАТАГРАМИ ───────────────────────│        │
│     │  • Телеметрія: Position, Velocity, Attitude         │        │
│     │  • Heartbeat: Alive, Status                         │        │
│     │  • Сенсори: RadarPing, CameraFrame                  │        │
│     │                                                      │        │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 50.2 ПРОБЛЕМИ РОЗПОДІЛЕНИХ СИСТЕМ

### 50.2.1 CAP-теорема

**Теорема Брюера** (Eric Brewer, 2000) — фундаментальне обмеження розподілених систем:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    CAP-ТЕОРЕМА                                       │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                     Consistency (C)                                 │
│                          ▲                                          │
│                         / \                                         │
│                        /   \                                        │
│                       /     \                                       │
│                      / ВИБЕРІТЬ\                                    │
│                     /   ЛИШЕ   \                                    │
│                    /    ДВА     \                                   │
│                   /              \                                  │
│  Availability (A) ◄──────────────► Partition Tolerance (P)         │
│                                                                     │
│  C — Всі вузли бачать однакові дані одночасно                      │
│  A — Система відповідає на кожен запит                             │
│  P — Система працює при розриві мережі                             │
│                                                                     │
│  НЕМОЖЛИВО мати всі три одночасно!                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Для рою агентів:**

Network partitions — **реальність** (дрони можуть втратити зв'язок). Тому P — обов'язкове.

Залишається вибір C або A:
- **CP (Consistency + Partition tolerance)**: зупинити роботу при втраті зв'язку з лідером
- **AP (Availability + Partition tolerance)**: продовжити автономно, синхронізувати пізніше

**Для БПЛА зазвичай обирають AP** — безпечніше, якщо дрон продовжить місію автономно, ніж зависне в повітрі.

### 50.2.2 Вісім помилкових припущень про мережу

**Peter Deutsch** та колеги з Sun Microsystems сформулювали "8 Fallacies of Distributed Computing" — помилкові припущення, які роблять розробники:

```text
┌─────────────────────────────────────────────────────────────────────┐
│            8 ПОМИЛКОВИХ ПРИПУЩЕНЬ (FALLACIES)                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. Мережа надійна               → Пакети губляться                │
│  2. Затримка нульова             → Затримка 10-1000+ мс            │
│  3. Bandwidth нескінченний       → Обмежений, конкурентний         │
│  4. Мережа безпечна              → Можливе перехоплення            │
│  5. Топологія не змінюється      → Вузли з'являються і зникають    │
│  6. Є один адміністратор         → Різні зони відповідальності     │
│  7. Транспорт безкоштовний       → Трафік коштує (особливо radio)  │
│  8. Мережа гомогенна             → Різні пристрої, протоколи       │
│                                                                     │
│  ПРОЕКТУЙТЕ, ПРИПУСКАЮЧИ ПРОТИЛЕЖНЕ!                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 50.2.3 Наслідки для рою агентів

**Часткова відмова (Partial failure):**
- В локальній програмі: або все працює, або все падає
- В розподіленій: частина агентів працює, частина — ні, і ви не знаєте яка

**Асинхронність:**
- Немає глобального часу
- Повідомлення можуть йти різними шляхами різний час
- Неможливо відрізнити "повільний" від "мертвого"

**Split brain:**
- Мережа розділилась на дві частини
- Кожна частина вважає себе "головною"
- При відновленні — конфлікт

### 50.2.4 Стратегії подолання

**Timeouts:**
- Не чекати вічно — ставити timeout
- При timeout — retry або fallback

**Retry з exponential backoff:**
- 1-а спроба: одразу
- 2-а: через 100мс
- 3-а: через 200мс
- 4-а: через 400мс
- Запобігає перевантаженню при масових відмовах

**Heartbeats:**
- Періодичні повідомлення "я живий"
- Якщо немає heartbeat N секунд — вважати мертвим

**Eventual consistency:**
- Не вимагати миттєвої консистентності
- Погодитись, що дані синхронізуються "врешті-решт"

---

## 50.3 СЕРІАЛІЗАЦІЯ ДЛЯ МЕРЕЖІ

### 50.3.1 Формати серіалізації

Перед відправкою по мережі дані потрібно **серіалізувати** — перетворити структури Rust у байти.

| Формат | Тип | Розмір | Швидкість | Human-readable |
|--------|-----|--------|-----------|----------------|
| **JSON** | Текстовий | Великий | Повільно | ✅ Так |
| **MessagePack** | Бінарний | Середній | Швидко | ❌ Ні |
| **Bincode** | Бінарний | Малий | Дуже швидко | ❌ Ні |
| **Protobuf** | Бінарний | Малий | Швидко | ❌ Ні |

**Для агентів рекомендується:**
- **Bincode** — для production (компактний, швидкий)
- **JSON** — для дебагу та логування (читабельний)

### 50.3.2 Структура повідомлень

**Постановка задачі:** Визначимо базові типи повідомлень для комунікації агентів.

```rust
use serde::{Serialize, Deserialize};

/// Унікальний ідентифікатор агента
pub type AgentId = u32;

/// Позиція в просторі
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct Position {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}

/// Тип повідомлення
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum MessageType {
    /// Періодичне "я живий"
    Heartbeat,
    /// Оновлення позиції
    PositionUpdate,
    /// Команда від лідера
    Command,
    /// Тривога (виявлено ціль/загрозу)
    Alert,
    /// Запит на з'єднання
    JoinRequest,
    /// Підтвердження з'єднання
    JoinAck,
}

/// Повідомлення агента
#[derive(Serialize, Deserialize, Clone, Debug)]
pub struct AgentMessage {
    /// Хто надіслав
    pub sender_id: AgentId,
    /// Тип повідомлення
    pub msg_type: MessageType,
    /// Час відправлення (unix timestamp)
    pub timestamp: u64,
    /// Корисне навантаження
    pub payload: MessagePayload,
}

/// Варіанти корисного навантаження
#[derive(Serialize, Deserialize, Clone, Debug)]
pub enum MessagePayload {
    /// Порожнє (для Heartbeat)
    Empty,
    /// Позиція та стан
    Status {
        position: Position,
        battery: u8,
        speed: f32,
    },
    /// Команда
    Command {
        command_type: String,
        parameters: Vec<String>,
    },
    /// Алерт
    Alert {
        alert_type: String,
        location: Position,
        priority: u8,
    },
}
```

### 50.3.3 Серіалізація з Bincode

**Постановка задачі:** Продемонструємо серіалізацію та десеріалізацію повідомлення.

```rust
use bincode::{serialize, deserialize};

fn example_serialization() {
    // Створюємо повідомлення
    let message = AgentMessage {
        sender_id: 42,
        msg_type: MessageType::PositionUpdate,
        timestamp: 1234567890,
        payload: MessagePayload::Status {
            position: Position { x: 100.0, y: 200.0, z: 50.0 },
            battery: 85,
            speed: 12.5,
        },
    };
    
    // Серіалізуємо в байти
    let bytes: Vec<u8> = serialize(&message).expect("Serialization failed");
    println!("Serialized size: {} bytes", bytes.len());
    
    // Десеріалізуємо назад
    let decoded: AgentMessage = deserialize(&bytes).expect("Deserialization failed");
    println!("Decoded sender: {}", decoded.sender_id);
}
```

**Розглянемо ключові моменти:**

1. **`#[derive(Serialize, Deserialize)]`** — макроси serde для автоматичної серіалізації
2. **`serialize(&message)`** — перетворює структуру в `Vec<u8>`
3. **`deserialize(&bytes)`** — перетворює байти назад у структуру
4. **Розмір** — Bincode дуже компактний (десятки байт замість сотень для JSON)

### 50.3.4 Версіонування протоколу

При оновленні протоколу старі та нові агенти можуть не розуміти один одного. Рішення — **версія в заголовку**:

```rust
/// Заголовок мережевого пакета
#[derive(Serialize, Deserialize)]
pub struct PacketHeader {
    /// Магічне число для валідації (0xAGNT)
    pub magic: u32,
    /// Версія протоколу
    pub version: u16,
    /// Довжина payload
    pub payload_len: u32,
}

impl PacketHeader {
    pub const MAGIC: u32 = 0x41474E54; // "AGNT" in hex
    pub const VERSION: u16 = 1;
    
    pub fn new(payload_len: u32) -> Self {
        Self {
            magic: Self::MAGIC,
            version: Self::VERSION,
            payload_len,
        }
    }
    
    pub fn is_valid(&self) -> bool {
        self.magic == Self::MAGIC && self.version == Self::VERSION
    }
}
```

---

## 50.4 ТОПОЛОГІЇ МЕРЕЖІ РОЮ

### 50.4.1 Чотири основні топології

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    ТОПОЛОГІЇ МЕРЕЖІ РОЮ                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  1. ЗІРКОВА (Star)           2. MESH (Повнозв'язна)                │
│                                                                     │
│         [A1]                      [A1]───[A2]                       │
│           \                       /│\   /│\                         │
│       [A2]─[HUB]─[A3]           [A3]─+─[A4]                        │
│           /                       \│/ \ \│/                         │
│         [A4]                      [A5]───[A6]                       │
│                                                                     │
│  + Простий контроль             + Надійність (багато шляхів)       │
│  + Низька затримка до hub       + Немає single point of failure    │
│  - Single point of failure      - O(n²) з'єднань                   │
│  - Hub = bottleneck             - Складне керування                │
│                                                                     │
│  3. ІЄРАРХІЧНА (Hierarchical)  4. GOSSIP (Пліткова)                │
│                                                                     │
│        [COMMANDER]                   [A1]╌╌╌[A2]                    │
│         /       \                    ╱ ╲   ╱ ╲                      │
│    [LEADER1] [LEADER2]            [A3]╌╌[A4]╌╌[A5]                  │
│     /    \     /    \              ╲   ╳   ╳   ╱                    │
│   [A1] [A2] [A3] [A4]              [A6]╌╌[A7]╌╌[A8]                 │
│                                                                     │
│  + Масштабується               + Дуже надійний                     │
│  + Чітка структура             + Саморганізується                  │
│  - Складна координація         - Повільне поширення                │
│  - Відмова лідера критична     - Непередбачуваність                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 50.4.2 Гібридна архітектура для рою БПЛА

На практиці використовують комбінацію:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    ГІБРИДНА АРХІТЕКТУРА                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│                    [GROUND CONTROL]                                 │
│                          │                                          │
│                    TCP   │   Команди, конфігурація                  │
│                          │                                          │
│                    [SWARM LEADER]                                   │
│                     ╱    │    ╲                                     │
│                TCP ╱     │     ╲ TCP    Координація груп            │
│                   ╱      │      ╲                                   │
│            [GROUP A] [GROUP B] [GROUP C]                           │
│              │  │      │  │      │  │                              │
│              ▼  ▼      ▼  ▼      ▼  ▼                              │
│            [A1][A2]  [B1][B2]  [C1][C2]                            │
│              ╲  ╱      ╲  ╱      ╲  ╱                              │
│               ╲╱        ╲╱        ╲╱                               │
│              UDP       UDP       UDP    Gossip в межах групи       │
│           (Telemetry) (Telemetry) (Telemetry)                      │
│                                                                     │
│  TCP: вертикальна комунікація (команди)                            │
│  UDP: горизонтальна комунікація (позиції, heartbeat)               │
│  Gossip: швидке поширення інформації в межах групи                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 50.5 DISCOVERY: ПОШУК АГЕНТІВ

### 50.5.1 Проблема виявлення

Коли новий агент стартує, він не знає адреси інших агентів. Як їх знайти?

**Підхід 1: Статична конфігурація**

```rust
/// Статичний список відомих агентів
const KNOWN_PEERS: &[&str] = &[
    "192.168.1.10:8000",
    "192.168.1.11:8000",
    "192.168.1.12:8000",
];
```

Просто, але негнучко — потрібно оновлювати при зміні складу.

**Підхід 2: Multicast Discovery**

Агент надсилає "хто тут?" на спеціальну multicast адресу, всі в мережі відповідають:

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    MULTICAST DISCOVERY                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  НОВИЙ АГЕНТ                    ІСНУЮЧІ АГЕНТИ                      │
│      │                          [A1] [A2] [A3]                      │
│      │                            │    │    │                       │
│      │──── "WHO_IS_HERE?" ───────►│────│────│   (Multicast)        │
│      │     (239.255.255.250)      │    │    │                       │
│      │                            │    │    │                       │
│      │◄─── "I_AM_HERE" ───────────│    │    │   (Unicast reply)    │
│      │     (id=1, addr=...)       │    │    │                       │
│      │◄─── "I_AM_HERE" ────────────────│    │                       │
│      │     (id=2, addr=...)            │    │                       │
│      │◄─── "I_AM_HERE" ─────────────────────│                       │
│      │     (id=3, addr=...)                 │                       │
│      │                                                              │
│   Тепер знає всіх!                                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**Підхід 3: Rendezvous Server**

Центральний сервер, де агенти реєструються:

```rust
/// Клієнт rendezvous сервера
async fn register_with_rendezvous(
    server_addr: &str,
    my_info: &AgentInfo,
) -> Result<Vec<AgentInfo>, Error> {
    let client = reqwest::Client::new();
    
    // Реєструємося
    client.post(&format!("{}/register", server_addr))
        .json(my_info)
        .send()
        .await?;
    
    // Отримуємо список інших
    let peers: Vec<AgentInfo> = client
        .get(&format!("{}/peers", server_addr))
        .send()
        .await?
        .json()
        .await?;
    
    Ok(peers)
}
```

---

## 50.6 TCP КОМУНІКАЦІЯ З TOKIO

### 50.6.1 Базова структура TCP сервера

**Постановка задачі:** Створимо TCP сервер, що приймає з'єднання від агентів.

```rust
use tokio::net::{TcpListener, TcpStream};
use tokio::io::{AsyncReadExt, AsyncWriteExt};

/// Запускає TCP сервер для прийому з'єднань
async fn run_tcp_server(addr: &str) -> Result<(), Box<dyn std::error::Error>> {
    // Прив'язуємось до адреси
    let listener = TcpListener::bind(addr).await?;
    println!("TCP server listening on {}", addr);
    
    loop {
        // Приймаємо нове з'єднання
        let (socket, peer_addr) = listener.accept().await?;
        println!("New connection from {}", peer_addr);
        
        // Обробляємо в окремій задачі
        tokio::spawn(async move {
            if let Err(e) = handle_connection(socket).await {
                eprintln!("Connection error: {}", e);
            }
        });
    }
}

/// Обробляє одне з'єднання
async fn handle_connection(mut socket: TcpStream) -> Result<(), Box<dyn std::error::Error>> {
    let mut buffer = vec![0u8; 1024];
    
    loop {
        // Читаємо дані
        let n = socket.read(&mut buffer).await?;
        if n == 0 {
            // З'єднання закрито
            break;
        }
        
        // Десеріалізуємо повідомлення
        let message: AgentMessage = bincode::deserialize(&buffer[..n])?;
        println!("Received: {:?}", message);
        
        // Відповідаємо ACK
        let ack = AgentMessage {
            sender_id: 0, // server
            msg_type: MessageType::Heartbeat,
            timestamp: current_timestamp(),
            payload: MessagePayload::Empty,
        };
        let response = bincode::serialize(&ack)?;
        socket.write_all(&response).await?;
    }
    
    Ok(())
}

fn current_timestamp() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_secs()
}
```

**Розглянемо ключові елементи:**

1. **`TcpListener::bind()`** — створює socket, прив'язаний до адреси
2. **`listener.accept()`** — блокується до нового з'єднання
3. **`tokio::spawn()`** — кожне з'єднання в окремій async задачі
4. **`socket.read()`** — async читання даних
5. **`socket.write_all()`** — async запис даних

### 50.6.2 TCP клієнт

**Постановка задачі:** Створимо клієнта для з'єднання з сервером.

```rust
use tokio::net::TcpStream;
use tokio::io::{AsyncReadExt, AsyncWriteExt};

/// Підключається до сервера та надсилає повідомлення
async fn connect_and_send(
    server_addr: &str,
    message: AgentMessage,
) -> Result<(), Box<dyn std::error::Error>> {
    // Підключаємось
    let mut stream = TcpStream::connect(server_addr).await?;
    println!("Connected to {}", server_addr);
    
    // Серіалізуємо та відправляємо
    let bytes = bincode::serialize(&message)?;
    stream.write_all(&bytes).await?;
    
    // Читаємо відповідь
    let mut buffer = vec![0u8; 1024];
    let n = stream.read(&mut buffer).await?;
    
    let response: AgentMessage = bincode::deserialize(&buffer[..n])?;
    println!("Response: {:?}", response);
    
    Ok(())
}
```

---

## 50.7 UDP КОМУНІКАЦІЯ З TOKIO

### 50.7.1 UDP сокет

**Постановка задачі:** Створимо UDP комунікацію для телеметрії.

```rust
use tokio::net::UdpSocket;

/// Надсилає UDP датаграми (для телеметрії)
async fn send_telemetry(
    local_addr: &str,
    peers: Vec<String>,
    my_id: AgentId,
) -> Result<(), Box<dyn std::error::Error>> {
    // Створюємо UDP сокет
    let socket = UdpSocket::bind(local_addr).await?;
    
    loop {
        // Формуємо повідомлення телеметрії
        let message = AgentMessage {
            sender_id: my_id,
            msg_type: MessageType::PositionUpdate,
            timestamp: current_timestamp(),
            payload: MessagePayload::Status {
                position: Position { x: 100.0, y: 200.0, z: 50.0 },
                battery: 85,
                speed: 12.5,
            },
        };
        
        let bytes = bincode::serialize(&message)?;
        
        // Надсилаємо всім peers
        for peer in &peers {
            socket.send_to(&bytes, peer).await?;
        }
        
        // 10 Hz — кожні 100мс
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
}

/// Отримує UDP датаграми
async fn receive_telemetry(
    bind_addr: &str,
) -> Result<(), Box<dyn std::error::Error>> {
    let socket = UdpSocket::bind(bind_addr).await?;
    let mut buffer = vec![0u8; 1024];
    
    loop {
        // Отримуємо датаграму
        let (len, src_addr) = socket.recv_from(&mut buffer).await?;
        
        // Десеріалізуємо
        let message: AgentMessage = bincode::deserialize(&buffer[..len])?;
        
        println!("From {}: Agent {} at {:?}", 
                 src_addr, 
                 message.sender_id,
                 message.payload);
    }
}
```

---

## 50.8 HEARTBEAT ТА FAILURE DETECTION

### 50.8.1 Концепція Heartbeat

**Heartbeat** — періодичне повідомлення "я живий". Якщо heartbeat не приходить — вважаємо агента мертвим.

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    HEARTBEAT MECHANISM                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  Агент A                                          Агент B           │
│     │                                                │              │
│     │──────────── Heartbeat (t=0) ──────────────────►│              │
│     │                                                │              │
│     │              ... 1 секунда ...                 │              │
│     │                                                │              │
│     │──────────── Heartbeat (t=1) ──────────────────►│              │
│     │                                                │              │
│     │              ... 1 секунда ...                 │              │
│     │                                                │              │
│     │──────────── Heartbeat (t=2) ────── X          │  ВТРАЧЕНО    │
│     │                                                │              │
│     │              ... 3 секунди ...                 │              │
│     │                                                │              │
│     │                                    [B думає:   │              │
│     │                                     A мертвий  │              │
│     │                                     timeout=3s]│              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 50.8.2 Реалізація failure detection

**Постановка задачі:** Створимо систему відстеження живих агентів.

```rust
use std::collections::HashMap;
use std::time::{Duration, Instant};

/// Трекер живих агентів
pub struct PeerTracker {
    /// Час останнього heartbeat від кожного агента
    last_seen: HashMap<AgentId, Instant>,
    /// Таймаут для визначення "мертвого" агента
    timeout: Duration,
}

impl PeerTracker {
    pub fn new(timeout_secs: u64) -> Self {
        Self {
            last_seen: HashMap::new(),
            timeout: Duration::from_secs(timeout_secs),
        }
    }
    
    /// Реєструє heartbeat від агента
    pub fn record_heartbeat(&mut self, agent_id: AgentId) {
        self.last_seen.insert(agent_id, Instant::now());
    }
    
    /// Перевіряє, чи агент живий
    pub fn is_alive(&self, agent_id: AgentId) -> bool {
        if let Some(last) = self.last_seen.get(&agent_id) {
            last.elapsed() < self.timeout
        } else {
            false
        }
    }
    
    /// Повертає список мертвих агентів
    pub fn get_dead_peers(&self) -> Vec<AgentId> {
        self.last_seen
            .iter()
            .filter(|(_, last)| last.elapsed() >= self.timeout)
            .map(|(id, _)| *id)
            .collect()
    }
    
    /// Очищає мертвих агентів
    pub fn cleanup_dead(&mut self) {
        self.last_seen.retain(|_, last| last.elapsed() < self.timeout);
    }
}
```

---

## 50.9 ЛАБОРАТОРНА РОБОТА

### Мета роботи

Реалізувати базову мережеву комунікацію між агентами.

### Завдання 1: Echo-сервер (3 бали)

Створіть TCP сервер, що:
- Приймає текстові повідомлення
- Повертає їх у верхньому регістрі
- Логує всі з'єднання

### Завдання 2: UDP телеметрія (3 бали)

Створіть систему де:
- Один агент надсилає позицію кожні 100мс
- Інший агент приймає та виводить
- Підрахуйте % втрачених пакетів

### Завдання 3: Heartbeat система (4 бали)

Реалізуйте:
- 3 агенти надсилають heartbeat раз на секунду
- Центральний монітор відстежує всіх
- Виводить попередження при втраті зв'язку

---

## 50.10 РЕЗЮМЕ

### Ключові концепції

**TCP vs UDP**: TCP для надійності, UDP для швидкості. Використовуйте обидва.

**CAP-теорема**: для рою обираємо AP (Available + Partition-tolerant).

**8 Fallacies**: мережа ненадійна, не безкоштовна, не гомогенна.

**Серіалізація**: Bincode для production, JSON для дебагу.

**Discovery**: Multicast для локальної мережі, Rendezvous для глобальної.

**Heartbeat**: основа failure detection — періодичне "я живий".

### Архітектурні рішення для рою

| Потреба | Рішення |
|---------|---------|
| Команди | TCP |
| Телеметрія | UDP |
| Виявлення агентів | Multicast або Rendezvous |
| Виявлення відмов | Heartbeat з timeout |
| Масштабування | Ієрархічна топологія |
| Надійність | Gossip на нижньому рівні |

---

## 🔗 ЗВ'ЯЗОК З НАСТУПНИМ РОЗДІЛОМ

Мережева комунікація дозволяє агентам працювати на різних машинах. Але як **візуалізувати** рій? Як дати людині-оператору інтерфейс для моніторингу та керування?

У **Розділі 51: WebAssembly — Агенти у браузері** ви:
- Дізнаєтесь про WebAssembly та його роль
- Скомпілюєте Rust-код у WASM
- Створите візуалізацію рою в браузері
- Побудуєте інтерактивний інтерфейс керування

---

> **Наступний розділ:** [Розділ 51: WebAssembly — Агенти у браузері](./51_WebAssembly.md)
